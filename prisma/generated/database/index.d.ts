
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model superAdmin
 * 
 */
export type superAdmin = $Result.DefaultSelection<Prisma.$superAdminPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Physician
 * 
 */
export type Physician = $Result.DefaultSelection<Prisma.$PhysicianPayload>
/**
 * Model Queue
 * 
 */
export type Queue = $Result.DefaultSelection<Prisma.$QueuePayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model VitalSigns
 * 
 */
export type VitalSigns = $Result.DefaultSelection<Prisma.$VitalSignsPayload>
/**
 * Model Consultation
 * 
 */
export type Consultation = $Result.DefaultSelection<Prisma.$ConsultationPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model PrescriptionItem
 * 
 */
export type PrescriptionItem = $Result.DefaultSelection<Prisma.$PrescriptionItemPayload>
/**
 * Model DrugDispensal
 * 
 */
export type DrugDispensal = $Result.DefaultSelection<Prisma.$DrugDispensalPayload>
/**
 * Model MedicalRecord
 * 
 */
export type MedicalRecord = $Result.DefaultSelection<Prisma.$MedicalRecordPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model PurchaseItem
 * 
 */
export type PurchaseItem = $Result.DefaultSelection<Prisma.$PurchaseItemPayload>
/**
 * Model BalanceTransaction
 * 
 */
export type BalanceTransaction = $Result.DefaultSelection<Prisma.$BalanceTransactionPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model ReceiptSettings
 * 
 */
export type ReceiptSettings = $Result.DefaultSelection<Prisma.$ReceiptSettingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const mode: {
  dark: 'dark',
  light: 'light'
};

export type mode = (typeof mode)[keyof typeof mode]


export const role: {
  admin: 'admin',
  physician: 'physician',
  pharmacist: 'pharmacist',
  receptionist: 'receptionist',
  nurse: 'nurse'
};

export type role = (typeof role)[keyof typeof role]


export const unit: {
  kg: 'kg',
  piece: 'piece',
  liter: 'liter',
  meter: 'meter',
  tablet: 'tablet',
  capsule: 'capsule',
  ml: 'ml',
  mg: 'mg',
  bottle: 'bottle',
  tube: 'tube',
  sachet: 'sachet'
};

export type unit = (typeof unit)[keyof typeof unit]


export const type: {
  COMPANY: 'COMPANY',
  INDIVIDUAL: 'INDIVIDUAL',
  GOVERNMENT: 'GOVERNMENT',
  NON_PROFIT: 'NON_PROFIT',
  retail: 'retail',
  wholesale: 'wholesale'
};

export type type = (typeof type)[keyof typeof type]


export const priority: {
  emergency: 'emergency',
  urgent: 'urgent',
  normal: 'normal'
};

export type priority = (typeof priority)[keyof typeof priority]


export const consultationStatus: {
  waiting: 'waiting',
  in_progress: 'in_progress',
  completed: 'completed',
  cancelled: 'cancelled',
  referred: 'referred'
};

export type consultationStatus = (typeof consultationStatus)[keyof typeof consultationStatus]


export const prescriptionStatus: {
  pending: 'pending',
  approved: 'approved',
  dispensed: 'dispensed',
  partially_dispensed: 'partially_dispensed',
  cancelled: 'cancelled',
  expired: 'expired'
};

export type prescriptionStatus = (typeof prescriptionStatus)[keyof typeof prescriptionStatus]

}

export type mode = $Enums.mode

export const mode: typeof $Enums.mode

export type role = $Enums.role

export const role: typeof $Enums.role

export type unit = $Enums.unit

export const unit: typeof $Enums.unit

export type type = $Enums.type

export const type: typeof $Enums.type

export type priority = $Enums.priority

export const priority: typeof $Enums.priority

export type consultationStatus = $Enums.consultationStatus

export const consultationStatus: typeof $Enums.consultationStatus

export type prescriptionStatus = $Enums.prescriptionStatus

export const prescriptionStatus: typeof $Enums.prescriptionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SuperAdmins
 * const superAdmins = await prisma.superAdmin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SuperAdmins
   * const superAdmins = await prisma.superAdmin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.superAdmin`: Exposes CRUD operations for the **superAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdmins
    * const superAdmins = await prisma.superAdmin.findMany()
    * ```
    */
  get superAdmin(): Prisma.superAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.physician`: Exposes CRUD operations for the **Physician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Physicians
    * const physicians = await prisma.physician.findMany()
    * ```
    */
  get physician(): Prisma.PhysicianDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queue`: Exposes CRUD operations for the **Queue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queues
    * const queues = await prisma.queue.findMany()
    * ```
    */
  get queue(): Prisma.QueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vitalSigns`: Exposes CRUD operations for the **VitalSigns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitalSigns
    * const vitalSigns = await prisma.vitalSigns.findMany()
    * ```
    */
  get vitalSigns(): Prisma.VitalSignsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consultation`: Exposes CRUD operations for the **Consultation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultations
    * const consultations = await prisma.consultation.findMany()
    * ```
    */
  get consultation(): Prisma.ConsultationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescriptionItem`: Exposes CRUD operations for the **PrescriptionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionItems
    * const prescriptionItems = await prisma.prescriptionItem.findMany()
    * ```
    */
  get prescriptionItem(): Prisma.PrescriptionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drugDispensal`: Exposes CRUD operations for the **DrugDispensal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DrugDispensals
    * const drugDispensals = await prisma.drugDispensal.findMany()
    * ```
    */
  get drugDispensal(): Prisma.DrugDispensalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalRecord`: Exposes CRUD operations for the **MedicalRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalRecords
    * const medicalRecords = await prisma.medicalRecord.findMany()
    * ```
    */
  get medicalRecord(): Prisma.MedicalRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseItem`: Exposes CRUD operations for the **PurchaseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItem.findMany()
    * ```
    */
  get purchaseItem(): Prisma.PurchaseItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balanceTransaction`: Exposes CRUD operations for the **BalanceTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BalanceTransactions
    * const balanceTransactions = await prisma.balanceTransaction.findMany()
    * ```
    */
  get balanceTransaction(): Prisma.BalanceTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receiptSettings`: Exposes CRUD operations for the **ReceiptSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceiptSettings
    * const receiptSettings = await prisma.receiptSettings.findMany()
    * ```
    */
  get receiptSettings(): Prisma.ReceiptSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    superAdmin: 'superAdmin',
    users: 'users',
    Settings: 'Settings',
    Student: 'Student',
    Physician: 'Physician',
    Queue: 'Queue',
    Appointment: 'Appointment',
    VitalSigns: 'VitalSigns',
    Consultation: 'Consultation',
    Prescription: 'Prescription',
    PrescriptionItem: 'PrescriptionItem',
    DrugDispensal: 'DrugDispensal',
    MedicalRecord: 'MedicalRecord',
    Product: 'Product',
    Purchase: 'Purchase',
    PurchaseItem: 'PurchaseItem',
    BalanceTransaction: 'BalanceTransaction',
    Supplier: 'Supplier',
    ReceiptSettings: 'ReceiptSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "superAdmin" | "users" | "settings" | "student" | "physician" | "queue" | "appointment" | "vitalSigns" | "consultation" | "prescription" | "prescriptionItem" | "drugDispensal" | "medicalRecord" | "product" | "purchase" | "purchaseItem" | "balanceTransaction" | "supplier" | "receiptSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      superAdmin: {
        payload: Prisma.$superAdminPayload<ExtArgs>
        fields: Prisma.superAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.superAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.superAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>
          }
          findFirst: {
            args: Prisma.superAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.superAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>
          }
          findMany: {
            args: Prisma.superAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>[]
          }
          create: {
            args: Prisma.superAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>
          }
          createMany: {
            args: Prisma.superAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.superAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>[]
          }
          delete: {
            args: Prisma.superAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>
          }
          update: {
            args: Prisma.superAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>
          }
          deleteMany: {
            args: Prisma.superAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.superAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.superAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>[]
          }
          upsert: {
            args: Prisma.superAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$superAdminPayload>
          }
          aggregate: {
            args: Prisma.SuperAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdmin>
          }
          groupBy: {
            args: Prisma.superAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.superAdminCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Physician: {
        payload: Prisma.$PhysicianPayload<ExtArgs>
        fields: Prisma.PhysicianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhysicianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhysicianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          findFirst: {
            args: Prisma.PhysicianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhysicianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          findMany: {
            args: Prisma.PhysicianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>[]
          }
          create: {
            args: Prisma.PhysicianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          createMany: {
            args: Prisma.PhysicianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhysicianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>[]
          }
          delete: {
            args: Prisma.PhysicianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          update: {
            args: Prisma.PhysicianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          deleteMany: {
            args: Prisma.PhysicianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhysicianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhysicianUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>[]
          }
          upsert: {
            args: Prisma.PhysicianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhysicianPayload>
          }
          aggregate: {
            args: Prisma.PhysicianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhysician>
          }
          groupBy: {
            args: Prisma.PhysicianGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhysicianGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhysicianCountArgs<ExtArgs>
            result: $Utils.Optional<PhysicianCountAggregateOutputType> | number
          }
        }
      }
      Queue: {
        payload: Prisma.$QueuePayload<ExtArgs>
        fields: Prisma.QueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          findFirst: {
            args: Prisma.QueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          findMany: {
            args: Prisma.QueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[]
          }
          create: {
            args: Prisma.QueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          createMany: {
            args: Prisma.QueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[]
          }
          delete: {
            args: Prisma.QueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          update: {
            args: Prisma.QueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          deleteMany: {
            args: Prisma.QueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[]
          }
          upsert: {
            args: Prisma.QueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          aggregate: {
            args: Prisma.QueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueue>
          }
          groupBy: {
            args: Prisma.QueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueCountArgs<ExtArgs>
            result: $Utils.Optional<QueueCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      VitalSigns: {
        payload: Prisma.$VitalSignsPayload<ExtArgs>
        fields: Prisma.VitalSignsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VitalSignsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VitalSignsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          findFirst: {
            args: Prisma.VitalSignsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VitalSignsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          findMany: {
            args: Prisma.VitalSignsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>[]
          }
          create: {
            args: Prisma.VitalSignsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          createMany: {
            args: Prisma.VitalSignsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VitalSignsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>[]
          }
          delete: {
            args: Prisma.VitalSignsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          update: {
            args: Prisma.VitalSignsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          deleteMany: {
            args: Prisma.VitalSignsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VitalSignsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VitalSignsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>[]
          }
          upsert: {
            args: Prisma.VitalSignsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          aggregate: {
            args: Prisma.VitalSignsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVitalSigns>
          }
          groupBy: {
            args: Prisma.VitalSignsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VitalSignsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VitalSignsCountArgs<ExtArgs>
            result: $Utils.Optional<VitalSignsCountAggregateOutputType> | number
          }
        }
      }
      Consultation: {
        payload: Prisma.$ConsultationPayload<ExtArgs>
        fields: Prisma.ConsultationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findFirst: {
            args: Prisma.ConsultationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findMany: {
            args: Prisma.ConsultationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          create: {
            args: Prisma.ConsultationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          createMany: {
            args: Prisma.ConsultationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          delete: {
            args: Prisma.ConsultationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          update: {
            args: Prisma.ConsultationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConsultationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          upsert: {
            args: Prisma.ConsultationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          aggregate: {
            args: Prisma.ConsultationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultation>
          }
          groupBy: {
            args: Prisma.ConsultationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionItem: {
        payload: Prisma.$PrescriptionItemPayload<ExtArgs>
        fields: Prisma.PrescriptionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findMany: {
            args: Prisma.PrescriptionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          create: {
            args: Prisma.PrescriptionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          createMany: {
            args: Prisma.PrescriptionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          update: {
            args: Prisma.PrescriptionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionItem>
          }
          groupBy: {
            args: Prisma.PrescriptionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionItemCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemCountAggregateOutputType> | number
          }
        }
      }
      DrugDispensal: {
        payload: Prisma.$DrugDispensalPayload<ExtArgs>
        fields: Prisma.DrugDispensalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DrugDispensalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrugDispensalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>
          }
          findFirst: {
            args: Prisma.DrugDispensalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrugDispensalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>
          }
          findMany: {
            args: Prisma.DrugDispensalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>[]
          }
          create: {
            args: Prisma.DrugDispensalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>
          }
          createMany: {
            args: Prisma.DrugDispensalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DrugDispensalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>[]
          }
          delete: {
            args: Prisma.DrugDispensalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>
          }
          update: {
            args: Prisma.DrugDispensalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>
          }
          deleteMany: {
            args: Prisma.DrugDispensalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DrugDispensalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DrugDispensalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>[]
          }
          upsert: {
            args: Prisma.DrugDispensalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugDispensalPayload>
          }
          aggregate: {
            args: Prisma.DrugDispensalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrugDispensal>
          }
          groupBy: {
            args: Prisma.DrugDispensalGroupByArgs<ExtArgs>
            result: $Utils.Optional<DrugDispensalGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrugDispensalCountArgs<ExtArgs>
            result: $Utils.Optional<DrugDispensalCountAggregateOutputType> | number
          }
        }
      }
      MedicalRecord: {
        payload: Prisma.$MedicalRecordPayload<ExtArgs>
        fields: Prisma.MedicalRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          findFirst: {
            args: Prisma.MedicalRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          findMany: {
            args: Prisma.MedicalRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          create: {
            args: Prisma.MedicalRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          createMany: {
            args: Prisma.MedicalRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          delete: {
            args: Prisma.MedicalRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          update: {
            args: Prisma.MedicalRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          deleteMany: {
            args: Prisma.MedicalRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          upsert: {
            args: Prisma.MedicalRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          aggregate: {
            args: Prisma.MedicalRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalRecord>
          }
          groupBy: {
            args: Prisma.MedicalRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalRecordCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      PurchaseItem: {
        payload: Prisma.$PurchaseItemPayload<ExtArgs>
        fields: Prisma.PurchaseItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          update: {
            args: Prisma.PurchaseItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseItem>
          }
          groupBy: {
            args: Prisma.PurchaseItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemCountAggregateOutputType> | number
          }
        }
      }
      BalanceTransaction: {
        payload: Prisma.$BalanceTransactionPayload<ExtArgs>
        fields: Prisma.BalanceTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>
          }
          findFirst: {
            args: Prisma.BalanceTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>
          }
          findMany: {
            args: Prisma.BalanceTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>[]
          }
          create: {
            args: Prisma.BalanceTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>
          }
          createMany: {
            args: Prisma.BalanceTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>[]
          }
          delete: {
            args: Prisma.BalanceTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>
          }
          update: {
            args: Prisma.BalanceTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BalanceTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BalanceTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>[]
          }
          upsert: {
            args: Prisma.BalanceTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceTransactionPayload>
          }
          aggregate: {
            args: Prisma.BalanceTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalanceTransaction>
          }
          groupBy: {
            args: Prisma.BalanceTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceTransactionCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      ReceiptSettings: {
        payload: Prisma.$ReceiptSettingsPayload<ExtArgs>
        fields: Prisma.ReceiptSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>
          }
          findFirst: {
            args: Prisma.ReceiptSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>
          }
          findMany: {
            args: Prisma.ReceiptSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>[]
          }
          create: {
            args: Prisma.ReceiptSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>
          }
          createMany: {
            args: Prisma.ReceiptSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceiptSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>[]
          }
          delete: {
            args: Prisma.ReceiptSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>
          }
          update: {
            args: Prisma.ReceiptSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>
          }
          deleteMany: {
            args: Prisma.ReceiptSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceiptSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>[]
          }
          upsert: {
            args: Prisma.ReceiptSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptSettingsPayload>
          }
          aggregate: {
            args: Prisma.ReceiptSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceiptSettings>
          }
          groupBy: {
            args: Prisma.ReceiptSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    superAdmin?: superAdminOmit
    users?: usersOmit
    settings?: SettingsOmit
    student?: StudentOmit
    physician?: PhysicianOmit
    queue?: QueueOmit
    appointment?: AppointmentOmit
    vitalSigns?: VitalSignsOmit
    consultation?: ConsultationOmit
    prescription?: PrescriptionOmit
    prescriptionItem?: PrescriptionItemOmit
    drugDispensal?: DrugDispensalOmit
    medicalRecord?: MedicalRecordOmit
    product?: ProductOmit
    purchase?: PurchaseOmit
    purchaseItem?: PurchaseItemOmit
    balanceTransaction?: BalanceTransactionOmit
    supplier?: SupplierOmit
    receiptSettings?: ReceiptSettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    consultations: number
    prescriptions: number
    drugDispensals: number
    medicalRecords: number
    vitalSigns: number
    appointments: number
    queue: number
    balanceTransaction: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | StudentCountOutputTypeCountConsultationsArgs
    prescriptions?: boolean | StudentCountOutputTypeCountPrescriptionsArgs
    drugDispensals?: boolean | StudentCountOutputTypeCountDrugDispensalsArgs
    medicalRecords?: boolean | StudentCountOutputTypeCountMedicalRecordsArgs
    vitalSigns?: boolean | StudentCountOutputTypeCountVitalSignsArgs
    appointments?: boolean | StudentCountOutputTypeCountAppointmentsArgs
    queue?: boolean | StudentCountOutputTypeCountQueueArgs
    balanceTransaction?: boolean | StudentCountOutputTypeCountBalanceTransactionArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountDrugDispensalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrugDispensalWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountVitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignsWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountBalanceTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceTransactionWhereInput
  }


  /**
   * Count Type PhysicianCountOutputType
   */

  export type PhysicianCountOutputType = {
    consultations: number
    prescriptions: number
    appointments: number
  }

  export type PhysicianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | PhysicianCountOutputTypeCountConsultationsArgs
    prescriptions?: boolean | PhysicianCountOutputTypeCountPrescriptionsArgs
    appointments?: boolean | PhysicianCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhysicianCountOutputType
     */
    select?: PhysicianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeCountConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }

  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * PhysicianCountOutputType without action
   */
  export type PhysicianCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type ConsultationCountOutputType
   */

  export type ConsultationCountOutputType = {
    vitalSigns: number
    prescriptions: number
  }

  export type ConsultationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vitalSigns?: boolean | ConsultationCountOutputTypeCountVitalSignsArgs
    prescriptions?: boolean | ConsultationCountOutputTypeCountPrescriptionsArgs
  }

  // Custom InputTypes
  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationCountOutputType
     */
    select?: ConsultationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountVitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignsWhereInput
  }

  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    prescriptionItems: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptionItems?: boolean | PrescriptionCountOutputTypeCountPrescriptionItemsArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountPrescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    prescriptionItems: number
    purchaseItem: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptionItems?: boolean | ProductCountOutputTypeCountPrescriptionItemsArgs
    purchaseItem?: boolean | ProductCountOutputTypeCountPurchaseItemArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPrescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    purchaseItem: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItem?: boolean | PurchaseCountOutputTypeCountPurchaseItemArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountPurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    purchase: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | SupplierCountOutputTypeCountPurchaseArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model superAdmin
   */

  export type AggregateSuperAdmin = {
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  export type SuperAdminMinAggregateOutputType = {
    id: string | null
    userName: string | null
    email: string | null
    password: string | null
    role: string | null
    lastLogin: Date | null
    sync: boolean | null
    syncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type SuperAdminMaxAggregateOutputType = {
    id: string | null
    userName: string | null
    email: string | null
    password: string | null
    role: string | null
    lastLogin: Date | null
    sync: boolean | null
    syncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type SuperAdminCountAggregateOutputType = {
    id: number
    userName: number
    email: number
    password: number
    role: number
    lastLogin: number
    sync: number
    syncedAt: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type SuperAdminMinAggregateInputType = {
    id?: true
    userName?: true
    email?: true
    password?: true
    role?: true
    lastLogin?: true
    sync?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type SuperAdminMaxAggregateInputType = {
    id?: true
    userName?: true
    email?: true
    password?: true
    role?: true
    lastLogin?: true
    sync?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type SuperAdminCountAggregateInputType = {
    id?: true
    userName?: true
    email?: true
    password?: true
    role?: true
    lastLogin?: true
    sync?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type SuperAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which superAdmin to aggregate.
     */
    where?: superAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superAdmins to fetch.
     */
    orderBy?: superAdminOrderByWithRelationInput | superAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: superAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned superAdmins
    **/
    _count?: true | SuperAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminMaxAggregateInputType
  }

  export type GetSuperAdminAggregateType<T extends SuperAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdmin[P]>
      : GetScalarType<T[P], AggregateSuperAdmin[P]>
  }




  export type superAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: superAdminWhereInput
    orderBy?: superAdminOrderByWithAggregationInput | superAdminOrderByWithAggregationInput[]
    by: SuperAdminScalarFieldEnum[] | SuperAdminScalarFieldEnum
    having?: superAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminCountAggregateInputType | true
    _min?: SuperAdminMinAggregateInputType
    _max?: SuperAdminMaxAggregateInputType
  }

  export type SuperAdminGroupByOutputType = {
    id: string
    userName: string
    email: string
    password: string
    role: string
    lastLogin: Date | null
    sync: boolean
    syncedAt: Date | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  type GetSuperAdminGroupByPayload<T extends superAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
        }
      >
    >


  export type superAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    lastLogin?: boolean
    sync?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type superAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    lastLogin?: boolean
    sync?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type superAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    lastLogin?: boolean
    sync?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type superAdminSelectScalar = {
    id?: boolean
    userName?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    lastLogin?: boolean
    sync?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type superAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userName" | "email" | "password" | "role" | "lastLogin" | "sync" | "syncedAt" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["superAdmin"]>

  export type $superAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "superAdmin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userName: string
      email: string
      password: string
      role: string
      lastLogin: Date | null
      sync: boolean
      syncedAt: Date | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["superAdmin"]>
    composites: {}
  }

  type superAdminGetPayload<S extends boolean | null | undefined | superAdminDefaultArgs> = $Result.GetResult<Prisma.$superAdminPayload, S>

  type superAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<superAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminCountAggregateInputType | true
    }

  export interface superAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['superAdmin'], meta: { name: 'superAdmin' } }
    /**
     * Find zero or one SuperAdmin that matches the filter.
     * @param {superAdminFindUniqueArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends superAdminFindUniqueArgs>(args: SelectSubset<T, superAdminFindUniqueArgs<ExtArgs>>): Prisma__superAdminClient<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {superAdminFindUniqueOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends superAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, superAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__superAdminClient<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superAdminFindFirstArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends superAdminFindFirstArgs>(args?: SelectSubset<T, superAdminFindFirstArgs<ExtArgs>>): Prisma__superAdminClient<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superAdminFindFirstOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends superAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, superAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__superAdminClient<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany()
     * 
     * // Get first 10 SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends superAdminFindManyArgs>(args?: SelectSubset<T, superAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdmin.
     * @param {superAdminCreateArgs} args - Arguments to create a SuperAdmin.
     * @example
     * // Create one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.create({
     *   data: {
     *     // ... data to create a SuperAdmin
     *   }
     * })
     * 
     */
    create<T extends superAdminCreateArgs>(args: SelectSubset<T, superAdminCreateArgs<ExtArgs>>): Prisma__superAdminClient<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdmins.
     * @param {superAdminCreateManyArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends superAdminCreateManyArgs>(args?: SelectSubset<T, superAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdmins and returns the data saved in the database.
     * @param {superAdminCreateManyAndReturnArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends superAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, superAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdmin.
     * @param {superAdminDeleteArgs} args - Arguments to delete one SuperAdmin.
     * @example
     * // Delete one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.delete({
     *   where: {
     *     // ... filter to delete one SuperAdmin
     *   }
     * })
     * 
     */
    delete<T extends superAdminDeleteArgs>(args: SelectSubset<T, superAdminDeleteArgs<ExtArgs>>): Prisma__superAdminClient<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdmin.
     * @param {superAdminUpdateArgs} args - Arguments to update one SuperAdmin.
     * @example
     * // Update one SuperAdmin
     * const superAdmin = await prisma.superAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends superAdminUpdateArgs>(args: SelectSubset<T, superAdminUpdateArgs<ExtArgs>>): Prisma__superAdminClient<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdmins.
     * @param {superAdminDeleteManyArgs} args - Arguments to filter SuperAdmins to delete.
     * @example
     * // Delete a few SuperAdmins
     * const { count } = await prisma.superAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends superAdminDeleteManyArgs>(args?: SelectSubset<T, superAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends superAdminUpdateManyArgs>(args: SelectSubset<T, superAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins and returns the data updated in the database.
     * @param {superAdminUpdateManyAndReturnArgs} args - Arguments to update many SuperAdmins.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends superAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, superAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdmin.
     * @param {superAdminUpsertArgs} args - Arguments to update or create a SuperAdmin.
     * @example
     * // Update or create a SuperAdmin
     * const superAdmin = await prisma.superAdmin.upsert({
     *   create: {
     *     // ... data to create a SuperAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdmin we want to update
     *   }
     * })
     */
    upsert<T extends superAdminUpsertArgs>(args: SelectSubset<T, superAdminUpsertArgs<ExtArgs>>): Prisma__superAdminClient<$Result.GetResult<Prisma.$superAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superAdminCountArgs} args - Arguments to filter SuperAdmins to count.
     * @example
     * // Count the number of SuperAdmins
     * const count = await prisma.superAdmin.count({
     *   where: {
     *     // ... the filter for the SuperAdmins we want to count
     *   }
     * })
    **/
    count<T extends superAdminCountArgs>(
      args?: Subset<T, superAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminAggregateArgs>(args: Subset<T, SuperAdminAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminAggregateType<T>>

    /**
     * Group by SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {superAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends superAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: superAdminGroupByArgs['orderBy'] }
        : { orderBy?: superAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, superAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the superAdmin model
   */
  readonly fields: superAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for superAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__superAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the superAdmin model
   */
  interface superAdminFieldRefs {
    readonly id: FieldRef<"superAdmin", 'String'>
    readonly userName: FieldRef<"superAdmin", 'String'>
    readonly email: FieldRef<"superAdmin", 'String'>
    readonly password: FieldRef<"superAdmin", 'String'>
    readonly role: FieldRef<"superAdmin", 'String'>
    readonly lastLogin: FieldRef<"superAdmin", 'DateTime'>
    readonly sync: FieldRef<"superAdmin", 'Boolean'>
    readonly syncedAt: FieldRef<"superAdmin", 'DateTime'>
    readonly createdAt: FieldRef<"superAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"superAdmin", 'DateTime'>
    readonly isDeleted: FieldRef<"superAdmin", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * superAdmin findUnique
   */
  export type superAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * Filter, which superAdmin to fetch.
     */
    where: superAdminWhereUniqueInput
  }

  /**
   * superAdmin findUniqueOrThrow
   */
  export type superAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * Filter, which superAdmin to fetch.
     */
    where: superAdminWhereUniqueInput
  }

  /**
   * superAdmin findFirst
   */
  export type superAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * Filter, which superAdmin to fetch.
     */
    where?: superAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superAdmins to fetch.
     */
    orderBy?: superAdminOrderByWithRelationInput | superAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for superAdmins.
     */
    cursor?: superAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of superAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * superAdmin findFirstOrThrow
   */
  export type superAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * Filter, which superAdmin to fetch.
     */
    where?: superAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superAdmins to fetch.
     */
    orderBy?: superAdminOrderByWithRelationInput | superAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for superAdmins.
     */
    cursor?: superAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of superAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * superAdmin findMany
   */
  export type superAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * Filter, which superAdmins to fetch.
     */
    where?: superAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of superAdmins to fetch.
     */
    orderBy?: superAdminOrderByWithRelationInput | superAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing superAdmins.
     */
    cursor?: superAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` superAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` superAdmins.
     */
    skip?: number
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * superAdmin create
   */
  export type superAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * The data needed to create a superAdmin.
     */
    data: XOR<superAdminCreateInput, superAdminUncheckedCreateInput>
  }

  /**
   * superAdmin createMany
   */
  export type superAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many superAdmins.
     */
    data: superAdminCreateManyInput | superAdminCreateManyInput[]
  }

  /**
   * superAdmin createManyAndReturn
   */
  export type superAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * The data used to create many superAdmins.
     */
    data: superAdminCreateManyInput | superAdminCreateManyInput[]
  }

  /**
   * superAdmin update
   */
  export type superAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * The data needed to update a superAdmin.
     */
    data: XOR<superAdminUpdateInput, superAdminUncheckedUpdateInput>
    /**
     * Choose, which superAdmin to update.
     */
    where: superAdminWhereUniqueInput
  }

  /**
   * superAdmin updateMany
   */
  export type superAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update superAdmins.
     */
    data: XOR<superAdminUpdateManyMutationInput, superAdminUncheckedUpdateManyInput>
    /**
     * Filter which superAdmins to update
     */
    where?: superAdminWhereInput
    /**
     * Limit how many superAdmins to update.
     */
    limit?: number
  }

  /**
   * superAdmin updateManyAndReturn
   */
  export type superAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * The data used to update superAdmins.
     */
    data: XOR<superAdminUpdateManyMutationInput, superAdminUncheckedUpdateManyInput>
    /**
     * Filter which superAdmins to update
     */
    where?: superAdminWhereInput
    /**
     * Limit how many superAdmins to update.
     */
    limit?: number
  }

  /**
   * superAdmin upsert
   */
  export type superAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * The filter to search for the superAdmin to update in case it exists.
     */
    where: superAdminWhereUniqueInput
    /**
     * In case the superAdmin found by the `where` argument doesn't exist, create a new superAdmin with this data.
     */
    create: XOR<superAdminCreateInput, superAdminUncheckedCreateInput>
    /**
     * In case the superAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<superAdminUpdateInput, superAdminUncheckedUpdateInput>
  }

  /**
   * superAdmin delete
   */
  export type superAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
    /**
     * Filter which superAdmin to delete.
     */
    where: superAdminWhereUniqueInput
  }

  /**
   * superAdmin deleteMany
   */
  export type superAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which superAdmins to delete
     */
    where?: superAdminWhereInput
    /**
     * Limit how many superAdmins to delete.
     */
    limit?: number
  }

  /**
   * superAdmin without action
   */
  export type superAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the superAdmin
     */
    select?: superAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the superAdmin
     */
    omit?: superAdminOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    userName: string | null
    phoneNumber: string | null
    password: string | null
    role: $Enums.role | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    syncedAt: Date | null
    isDeleted: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    userName: string | null
    phoneNumber: string | null
    password: string | null
    role: $Enums.role | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    syncedAt: Date | null
    isDeleted: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    userName: number
    phoneNumber: number
    password: number
    role: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    sync: number
    syncedAt: number
    isDeleted: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    userName?: true
    phoneNumber?: true
    password?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    userName?: true
    phoneNumber?: true
    password?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    userName?: true
    phoneNumber?: true
    password?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    userName: string
    phoneNumber: string
    password: string
    role: $Enums.role
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    sync: boolean
    syncedAt: Date | null
    isDeleted: boolean
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    userName?: boolean
    phoneNumber?: boolean
    password?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    userName?: boolean
    phoneNumber?: boolean
    password?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    userName?: boolean
    phoneNumber?: boolean
    password?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    userName?: boolean
    phoneNumber?: boolean
    password?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "userName" | "phoneNumber" | "password" | "role" | "lastLogin" | "createdAt" | "updatedAt" | "sync" | "syncedAt" | "isDeleted", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      userName: string
      phoneNumber: string
      password: string
      role: $Enums.role
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
      sync: boolean
      syncedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly userName: FieldRef<"users", 'String'>
    readonly phoneNumber: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'role'>
    readonly lastLogin: FieldRef<"users", 'DateTime'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly sync: FieldRef<"users", 'Boolean'>
    readonly syncedAt: FieldRef<"users", 'DateTime'>
    readonly isDeleted: FieldRef<"users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    setting_id: number | null
    taxRate: number | null
    itermsPerPage: number | null
  }

  export type SettingsSumAggregateOutputType = {
    setting_id: number | null
    taxRate: number | null
    itermsPerPage: number | null
  }

  export type SettingsMinAggregateOutputType = {
    setting_id: number | null
    companyName: string | null
    companyEmail: string | null
    phoneNumber: string | null
    websiteURL: string | null
    address: string | null
    logoUrl: string | null
    defaultCurrency: string | null
    taxRate: number | null
    mode: $Enums.mode | null
    itermsPerPage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    syncedAt: Date | null
    isDeleted: boolean | null
  }

  export type SettingsMaxAggregateOutputType = {
    setting_id: number | null
    companyName: string | null
    companyEmail: string | null
    phoneNumber: string | null
    websiteURL: string | null
    address: string | null
    logoUrl: string | null
    defaultCurrency: string | null
    taxRate: number | null
    mode: $Enums.mode | null
    itermsPerPage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    syncedAt: Date | null
    isDeleted: boolean | null
  }

  export type SettingsCountAggregateOutputType = {
    setting_id: number
    companyName: number
    companyEmail: number
    phoneNumber: number
    websiteURL: number
    address: number
    logoUrl: number
    defaultCurrency: number
    taxRate: number
    mode: number
    itermsPerPage: number
    createdAt: number
    updatedAt: number
    sync: number
    syncedAt: number
    isDeleted: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    setting_id?: true
    taxRate?: true
    itermsPerPage?: true
  }

  export type SettingsSumAggregateInputType = {
    setting_id?: true
    taxRate?: true
    itermsPerPage?: true
  }

  export type SettingsMinAggregateInputType = {
    setting_id?: true
    companyName?: true
    companyEmail?: true
    phoneNumber?: true
    websiteURL?: true
    address?: true
    logoUrl?: true
    defaultCurrency?: true
    taxRate?: true
    mode?: true
    itermsPerPage?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
  }

  export type SettingsMaxAggregateInputType = {
    setting_id?: true
    companyName?: true
    companyEmail?: true
    phoneNumber?: true
    websiteURL?: true
    address?: true
    logoUrl?: true
    defaultCurrency?: true
    taxRate?: true
    mode?: true
    itermsPerPage?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
  }

  export type SettingsCountAggregateInputType = {
    setting_id?: true
    companyName?: true
    companyEmail?: true
    phoneNumber?: true
    websiteURL?: true
    address?: true
    logoUrl?: true
    defaultCurrency?: true
    taxRate?: true
    mode?: true
    itermsPerPage?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    setting_id: number
    companyName: string
    companyEmail: string
    phoneNumber: string
    websiteURL: string
    address: string
    logoUrl: string
    defaultCurrency: string
    taxRate: number
    mode: $Enums.mode
    itermsPerPage: number
    createdAt: Date
    updatedAt: Date
    sync: boolean
    syncedAt: Date | null
    isDeleted: boolean
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    setting_id?: boolean
    companyName?: boolean
    companyEmail?: boolean
    phoneNumber?: boolean
    websiteURL?: boolean
    address?: boolean
    logoUrl?: boolean
    defaultCurrency?: boolean
    taxRate?: boolean
    mode?: boolean
    itermsPerPage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    setting_id?: boolean
    companyName?: boolean
    companyEmail?: boolean
    phoneNumber?: boolean
    websiteURL?: boolean
    address?: boolean
    logoUrl?: boolean
    defaultCurrency?: boolean
    taxRate?: boolean
    mode?: boolean
    itermsPerPage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    setting_id?: boolean
    companyName?: boolean
    companyEmail?: boolean
    phoneNumber?: boolean
    websiteURL?: boolean
    address?: boolean
    logoUrl?: boolean
    defaultCurrency?: boolean
    taxRate?: boolean
    mode?: boolean
    itermsPerPage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    setting_id?: boolean
    companyName?: boolean
    companyEmail?: boolean
    phoneNumber?: boolean
    websiteURL?: boolean
    address?: boolean
    logoUrl?: boolean
    defaultCurrency?: boolean
    taxRate?: boolean
    mode?: boolean
    itermsPerPage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"setting_id" | "companyName" | "companyEmail" | "phoneNumber" | "websiteURL" | "address" | "logoUrl" | "defaultCurrency" | "taxRate" | "mode" | "itermsPerPage" | "createdAt" | "updatedAt" | "sync" | "syncedAt" | "isDeleted", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      setting_id: number
      companyName: string
      companyEmail: string
      phoneNumber: string
      websiteURL: string
      address: string
      logoUrl: string
      defaultCurrency: string
      taxRate: number
      mode: $Enums.mode
      itermsPerPage: number
      createdAt: Date
      updatedAt: Date
      sync: boolean
      syncedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `setting_id`
     * const settingsWithSetting_idOnly = await prisma.settings.findMany({ select: { setting_id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `setting_id`
     * const settingsWithSetting_idOnly = await prisma.settings.createManyAndReturn({
     *   select: { setting_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `setting_id`
     * const settingsWithSetting_idOnly = await prisma.settings.updateManyAndReturn({
     *   select: { setting_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly setting_id: FieldRef<"Settings", 'Int'>
    readonly companyName: FieldRef<"Settings", 'String'>
    readonly companyEmail: FieldRef<"Settings", 'String'>
    readonly phoneNumber: FieldRef<"Settings", 'String'>
    readonly websiteURL: FieldRef<"Settings", 'String'>
    readonly address: FieldRef<"Settings", 'String'>
    readonly logoUrl: FieldRef<"Settings", 'String'>
    readonly defaultCurrency: FieldRef<"Settings", 'String'>
    readonly taxRate: FieldRef<"Settings", 'Int'>
    readonly mode: FieldRef<"Settings", 'mode'>
    readonly itermsPerPage: FieldRef<"Settings", 'Int'>
    readonly createdAt: FieldRef<"Settings", 'DateTime'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
    readonly sync: FieldRef<"Settings", 'Boolean'>
    readonly syncedAt: FieldRef<"Settings", 'DateTime'>
    readonly isDeleted: FieldRef<"Settings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    matricNumber: string | null
    firstName: string | null
    lastName: string | null
    otherNames: string | null
    email: string | null
    phone: string | null
    department: string | null
    level: string | null
    faculty: string | null
    dateOfBirth: Date | null
    gender: string | null
    bloodGroup: string | null
    genotype: string | null
    allergies: string | null
    chronicConditions: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    emergencyRelationship: string | null
    profilePhoto: string | null
    address: string | null
    stateOfOrigin: string | null
    nationality: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    isDeleted: boolean | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    matricNumber: string | null
    firstName: string | null
    lastName: string | null
    otherNames: string | null
    email: string | null
    phone: string | null
    department: string | null
    level: string | null
    faculty: string | null
    dateOfBirth: Date | null
    gender: string | null
    bloodGroup: string | null
    genotype: string | null
    allergies: string | null
    chronicConditions: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    emergencyRelationship: string | null
    profilePhoto: string | null
    address: string | null
    stateOfOrigin: string | null
    nationality: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    isDeleted: boolean | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    matricNumber: number
    firstName: number
    lastName: number
    otherNames: number
    email: number
    phone: number
    department: number
    level: number
    faculty: number
    dateOfBirth: number
    gender: number
    bloodGroup: number
    genotype: number
    allergies: number
    chronicConditions: number
    emergencyContact: number
    emergencyPhone: number
    emergencyRelationship: number
    profilePhoto: number
    address: number
    stateOfOrigin: number
    nationality: number
    isActive: number
    createdAt: number
    updatedAt: number
    sync: number
    isDeleted: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    matricNumber?: true
    firstName?: true
    lastName?: true
    otherNames?: true
    email?: true
    phone?: true
    department?: true
    level?: true
    faculty?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    genotype?: true
    allergies?: true
    chronicConditions?: true
    emergencyContact?: true
    emergencyPhone?: true
    emergencyRelationship?: true
    profilePhoto?: true
    address?: true
    stateOfOrigin?: true
    nationality?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    matricNumber?: true
    firstName?: true
    lastName?: true
    otherNames?: true
    email?: true
    phone?: true
    department?: true
    level?: true
    faculty?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    genotype?: true
    allergies?: true
    chronicConditions?: true
    emergencyContact?: true
    emergencyPhone?: true
    emergencyRelationship?: true
    profilePhoto?: true
    address?: true
    stateOfOrigin?: true
    nationality?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    matricNumber?: true
    firstName?: true
    lastName?: true
    otherNames?: true
    email?: true
    phone?: true
    department?: true
    level?: true
    faculty?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    genotype?: true
    allergies?: true
    chronicConditions?: true
    emergencyContact?: true
    emergencyPhone?: true
    emergencyRelationship?: true
    profilePhoto?: true
    address?: true
    stateOfOrigin?: true
    nationality?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames: string | null
    email: string | null
    phone: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date
    gender: string
    bloodGroup: string | null
    genotype: string | null
    allergies: string | null
    chronicConditions: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship: string | null
    profilePhoto: string | null
    address: string | null
    stateOfOrigin: string | null
    nationality: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    sync: boolean
    isDeleted: boolean
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    otherNames?: boolean
    email?: boolean
    phone?: boolean
    department?: boolean
    level?: boolean
    faculty?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    genotype?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    emergencyRelationship?: boolean
    profilePhoto?: boolean
    address?: boolean
    stateOfOrigin?: boolean
    nationality?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
    consultations?: boolean | Student$consultationsArgs<ExtArgs>
    prescriptions?: boolean | Student$prescriptionsArgs<ExtArgs>
    drugDispensals?: boolean | Student$drugDispensalsArgs<ExtArgs>
    medicalRecords?: boolean | Student$medicalRecordsArgs<ExtArgs>
    vitalSigns?: boolean | Student$vitalSignsArgs<ExtArgs>
    appointments?: boolean | Student$appointmentsArgs<ExtArgs>
    queue?: boolean | Student$queueArgs<ExtArgs>
    balanceTransaction?: boolean | Student$balanceTransactionArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    otherNames?: boolean
    email?: boolean
    phone?: boolean
    department?: boolean
    level?: boolean
    faculty?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    genotype?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    emergencyRelationship?: boolean
    profilePhoto?: boolean
    address?: boolean
    stateOfOrigin?: boolean
    nationality?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    otherNames?: boolean
    email?: boolean
    phone?: boolean
    department?: boolean
    level?: boolean
    faculty?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    genotype?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    emergencyRelationship?: boolean
    profilePhoto?: boolean
    address?: boolean
    stateOfOrigin?: boolean
    nationality?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    matricNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    otherNames?: boolean
    email?: boolean
    phone?: boolean
    department?: boolean
    level?: boolean
    faculty?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    genotype?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    emergencyRelationship?: boolean
    profilePhoto?: boolean
    address?: boolean
    stateOfOrigin?: boolean
    nationality?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matricNumber" | "firstName" | "lastName" | "otherNames" | "email" | "phone" | "department" | "level" | "faculty" | "dateOfBirth" | "gender" | "bloodGroup" | "genotype" | "allergies" | "chronicConditions" | "emergencyContact" | "emergencyPhone" | "emergencyRelationship" | "profilePhoto" | "address" | "stateOfOrigin" | "nationality" | "isActive" | "createdAt" | "updatedAt" | "sync" | "isDeleted", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | Student$consultationsArgs<ExtArgs>
    prescriptions?: boolean | Student$prescriptionsArgs<ExtArgs>
    drugDispensals?: boolean | Student$drugDispensalsArgs<ExtArgs>
    medicalRecords?: boolean | Student$medicalRecordsArgs<ExtArgs>
    vitalSigns?: boolean | Student$vitalSignsArgs<ExtArgs>
    appointments?: boolean | Student$appointmentsArgs<ExtArgs>
    queue?: boolean | Student$queueArgs<ExtArgs>
    balanceTransaction?: boolean | Student$balanceTransactionArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      consultations: Prisma.$ConsultationPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      drugDispensals: Prisma.$DrugDispensalPayload<ExtArgs>[]
      medicalRecords: Prisma.$MedicalRecordPayload<ExtArgs>[]
      vitalSigns: Prisma.$VitalSignsPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      queue: Prisma.$QueuePayload<ExtArgs>[]
      balanceTransaction: Prisma.$BalanceTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      matricNumber: string
      firstName: string
      lastName: string
      otherNames: string | null
      email: string | null
      phone: string | null
      department: string
      level: string
      faculty: string
      dateOfBirth: Date
      gender: string
      bloodGroup: string | null
      genotype: string | null
      allergies: string | null
      chronicConditions: string | null
      emergencyContact: string
      emergencyPhone: string
      emergencyRelationship: string | null
      profilePhoto: string | null
      address: string | null
      stateOfOrigin: string | null
      nationality: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      sync: boolean
      isDeleted: boolean
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultations<T extends Student$consultationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$consultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Student$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Student$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    drugDispensals<T extends Student$drugDispensalsArgs<ExtArgs> = {}>(args?: Subset<T, Student$drugDispensalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalRecords<T extends Student$medicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$medicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vitalSigns<T extends Student$vitalSignsArgs<ExtArgs> = {}>(args?: Subset<T, Student$vitalSignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Student$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queue<T extends Student$queueArgs<ExtArgs> = {}>(args?: Subset<T, Student$queueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    balanceTransaction<T extends Student$balanceTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Student$balanceTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly matricNumber: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly otherNames: FieldRef<"Student", 'String'>
    readonly email: FieldRef<"Student", 'String'>
    readonly phone: FieldRef<"Student", 'String'>
    readonly department: FieldRef<"Student", 'String'>
    readonly level: FieldRef<"Student", 'String'>
    readonly faculty: FieldRef<"Student", 'String'>
    readonly dateOfBirth: FieldRef<"Student", 'DateTime'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly bloodGroup: FieldRef<"Student", 'String'>
    readonly genotype: FieldRef<"Student", 'String'>
    readonly allergies: FieldRef<"Student", 'String'>
    readonly chronicConditions: FieldRef<"Student", 'String'>
    readonly emergencyContact: FieldRef<"Student", 'String'>
    readonly emergencyPhone: FieldRef<"Student", 'String'>
    readonly emergencyRelationship: FieldRef<"Student", 'String'>
    readonly profilePhoto: FieldRef<"Student", 'String'>
    readonly address: FieldRef<"Student", 'String'>
    readonly stateOfOrigin: FieldRef<"Student", 'String'>
    readonly nationality: FieldRef<"Student", 'String'>
    readonly isActive: FieldRef<"Student", 'Boolean'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
    readonly sync: FieldRef<"Student", 'Boolean'>
    readonly isDeleted: FieldRef<"Student", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.consultations
   */
  export type Student$consultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Student.prescriptions
   */
  export type Student$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Student.drugDispensals
   */
  export type Student$drugDispensalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    where?: DrugDispensalWhereInput
    orderBy?: DrugDispensalOrderByWithRelationInput | DrugDispensalOrderByWithRelationInput[]
    cursor?: DrugDispensalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DrugDispensalScalarFieldEnum | DrugDispensalScalarFieldEnum[]
  }

  /**
   * Student.medicalRecords
   */
  export type Student$medicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * Student.vitalSigns
   */
  export type Student$vitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    where?: VitalSignsWhereInput
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    cursor?: VitalSignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * Student.appointments
   */
  export type Student$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Student.queue
   */
  export type Student$queueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    cursor?: QueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Student.balanceTransaction
   */
  export type Student$balanceTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    where?: BalanceTransactionWhereInput
    orderBy?: BalanceTransactionOrderByWithRelationInput | BalanceTransactionOrderByWithRelationInput[]
    cursor?: BalanceTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceTransactionScalarFieldEnum | BalanceTransactionScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Physician
   */

  export type AggregatePhysician = {
    _count: PhysicianCountAggregateOutputType | null
    _min: PhysicianMinAggregateOutputType | null
    _max: PhysicianMaxAggregateOutputType | null
  }

  export type PhysicianMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    firstName: string | null
    lastName: string | null
    otherNames: string | null
    specialization: string | null
    qualification: string | null
    licenseNumber: string | null
    email: string | null
    phone: string | null
    profilePhoto: string | null
    isActive: boolean | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    isDeleted: boolean | null
  }

  export type PhysicianMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    firstName: string | null
    lastName: string | null
    otherNames: string | null
    specialization: string | null
    qualification: string | null
    licenseNumber: string | null
    email: string | null
    phone: string | null
    profilePhoto: string | null
    isActive: boolean | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    isDeleted: boolean | null
  }

  export type PhysicianCountAggregateOutputType = {
    id: number
    staffId: number
    firstName: number
    lastName: number
    otherNames: number
    specialization: number
    qualification: number
    licenseNumber: number
    email: number
    phone: number
    profilePhoto: number
    isActive: number
    isAvailable: number
    createdAt: number
    updatedAt: number
    sync: number
    isDeleted: number
    _all: number
  }


  export type PhysicianMinAggregateInputType = {
    id?: true
    staffId?: true
    firstName?: true
    lastName?: true
    otherNames?: true
    specialization?: true
    qualification?: true
    licenseNumber?: true
    email?: true
    phone?: true
    profilePhoto?: true
    isActive?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
  }

  export type PhysicianMaxAggregateInputType = {
    id?: true
    staffId?: true
    firstName?: true
    lastName?: true
    otherNames?: true
    specialization?: true
    qualification?: true
    licenseNumber?: true
    email?: true
    phone?: true
    profilePhoto?: true
    isActive?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
  }

  export type PhysicianCountAggregateInputType = {
    id?: true
    staffId?: true
    firstName?: true
    lastName?: true
    otherNames?: true
    specialization?: true
    qualification?: true
    licenseNumber?: true
    email?: true
    phone?: true
    profilePhoto?: true
    isActive?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
    _all?: true
  }

  export type PhysicianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Physician to aggregate.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Physicians
    **/
    _count?: true | PhysicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhysicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhysicianMaxAggregateInputType
  }

  export type GetPhysicianAggregateType<T extends PhysicianAggregateArgs> = {
        [P in keyof T & keyof AggregatePhysician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhysician[P]>
      : GetScalarType<T[P], AggregatePhysician[P]>
  }




  export type PhysicianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhysicianWhereInput
    orderBy?: PhysicianOrderByWithAggregationInput | PhysicianOrderByWithAggregationInput[]
    by: PhysicianScalarFieldEnum[] | PhysicianScalarFieldEnum
    having?: PhysicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhysicianCountAggregateInputType | true
    _min?: PhysicianMinAggregateInputType
    _max?: PhysicianMaxAggregateInputType
  }

  export type PhysicianGroupByOutputType = {
    id: string
    staffId: string
    firstName: string
    lastName: string
    otherNames: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto: string | null
    isActive: boolean
    isAvailable: boolean
    createdAt: Date
    updatedAt: Date
    sync: boolean
    isDeleted: boolean
    _count: PhysicianCountAggregateOutputType | null
    _min: PhysicianMinAggregateOutputType | null
    _max: PhysicianMaxAggregateOutputType | null
  }

  type GetPhysicianGroupByPayload<T extends PhysicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhysicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhysicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhysicianGroupByOutputType[P]>
            : GetScalarType<T[P], PhysicianGroupByOutputType[P]>
        }
      >
    >


  export type PhysicianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    firstName?: boolean
    lastName?: boolean
    otherNames?: boolean
    specialization?: boolean
    qualification?: boolean
    licenseNumber?: boolean
    email?: boolean
    phone?: boolean
    profilePhoto?: boolean
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
    consultations?: boolean | Physician$consultationsArgs<ExtArgs>
    prescriptions?: boolean | Physician$prescriptionsArgs<ExtArgs>
    appointments?: boolean | Physician$appointmentsArgs<ExtArgs>
    _count?: boolean | PhysicianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["physician"]>

  export type PhysicianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    firstName?: boolean
    lastName?: boolean
    otherNames?: boolean
    specialization?: boolean
    qualification?: boolean
    licenseNumber?: boolean
    email?: boolean
    phone?: boolean
    profilePhoto?: boolean
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["physician"]>

  export type PhysicianSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    firstName?: boolean
    lastName?: boolean
    otherNames?: boolean
    specialization?: boolean
    qualification?: boolean
    licenseNumber?: boolean
    email?: boolean
    phone?: boolean
    profilePhoto?: boolean
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["physician"]>

  export type PhysicianSelectScalar = {
    id?: boolean
    staffId?: boolean
    firstName?: boolean
    lastName?: boolean
    otherNames?: boolean
    specialization?: boolean
    qualification?: boolean
    licenseNumber?: boolean
    email?: boolean
    phone?: boolean
    profilePhoto?: boolean
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
  }

  export type PhysicianOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "firstName" | "lastName" | "otherNames" | "specialization" | "qualification" | "licenseNumber" | "email" | "phone" | "profilePhoto" | "isActive" | "isAvailable" | "createdAt" | "updatedAt" | "sync" | "isDeleted", ExtArgs["result"]["physician"]>
  export type PhysicianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | Physician$consultationsArgs<ExtArgs>
    prescriptions?: boolean | Physician$prescriptionsArgs<ExtArgs>
    appointments?: boolean | Physician$appointmentsArgs<ExtArgs>
    _count?: boolean | PhysicianCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PhysicianIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PhysicianIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PhysicianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Physician"
    objects: {
      consultations: Prisma.$ConsultationPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string
      firstName: string
      lastName: string
      otherNames: string | null
      specialization: string
      qualification: string
      licenseNumber: string
      email: string
      phone: string
      profilePhoto: string | null
      isActive: boolean
      isAvailable: boolean
      createdAt: Date
      updatedAt: Date
      sync: boolean
      isDeleted: boolean
    }, ExtArgs["result"]["physician"]>
    composites: {}
  }

  type PhysicianGetPayload<S extends boolean | null | undefined | PhysicianDefaultArgs> = $Result.GetResult<Prisma.$PhysicianPayload, S>

  type PhysicianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhysicianFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhysicianCountAggregateInputType | true
    }

  export interface PhysicianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Physician'], meta: { name: 'Physician' } }
    /**
     * Find zero or one Physician that matches the filter.
     * @param {PhysicianFindUniqueArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhysicianFindUniqueArgs>(args: SelectSubset<T, PhysicianFindUniqueArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Physician that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhysicianFindUniqueOrThrowArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhysicianFindUniqueOrThrowArgs>(args: SelectSubset<T, PhysicianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Physician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindFirstArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhysicianFindFirstArgs>(args?: SelectSubset<T, PhysicianFindFirstArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Physician that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindFirstOrThrowArgs} args - Arguments to find a Physician
     * @example
     * // Get one Physician
     * const physician = await prisma.physician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhysicianFindFirstOrThrowArgs>(args?: SelectSubset<T, PhysicianFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Physicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Physicians
     * const physicians = await prisma.physician.findMany()
     * 
     * // Get first 10 Physicians
     * const physicians = await prisma.physician.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const physicianWithIdOnly = await prisma.physician.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhysicianFindManyArgs>(args?: SelectSubset<T, PhysicianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Physician.
     * @param {PhysicianCreateArgs} args - Arguments to create a Physician.
     * @example
     * // Create one Physician
     * const Physician = await prisma.physician.create({
     *   data: {
     *     // ... data to create a Physician
     *   }
     * })
     * 
     */
    create<T extends PhysicianCreateArgs>(args: SelectSubset<T, PhysicianCreateArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Physicians.
     * @param {PhysicianCreateManyArgs} args - Arguments to create many Physicians.
     * @example
     * // Create many Physicians
     * const physician = await prisma.physician.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhysicianCreateManyArgs>(args?: SelectSubset<T, PhysicianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Physicians and returns the data saved in the database.
     * @param {PhysicianCreateManyAndReturnArgs} args - Arguments to create many Physicians.
     * @example
     * // Create many Physicians
     * const physician = await prisma.physician.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Physicians and only return the `id`
     * const physicianWithIdOnly = await prisma.physician.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhysicianCreateManyAndReturnArgs>(args?: SelectSubset<T, PhysicianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Physician.
     * @param {PhysicianDeleteArgs} args - Arguments to delete one Physician.
     * @example
     * // Delete one Physician
     * const Physician = await prisma.physician.delete({
     *   where: {
     *     // ... filter to delete one Physician
     *   }
     * })
     * 
     */
    delete<T extends PhysicianDeleteArgs>(args: SelectSubset<T, PhysicianDeleteArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Physician.
     * @param {PhysicianUpdateArgs} args - Arguments to update one Physician.
     * @example
     * // Update one Physician
     * const physician = await prisma.physician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhysicianUpdateArgs>(args: SelectSubset<T, PhysicianUpdateArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Physicians.
     * @param {PhysicianDeleteManyArgs} args - Arguments to filter Physicians to delete.
     * @example
     * // Delete a few Physicians
     * const { count } = await prisma.physician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhysicianDeleteManyArgs>(args?: SelectSubset<T, PhysicianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Physicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Physicians
     * const physician = await prisma.physician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhysicianUpdateManyArgs>(args: SelectSubset<T, PhysicianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Physicians and returns the data updated in the database.
     * @param {PhysicianUpdateManyAndReturnArgs} args - Arguments to update many Physicians.
     * @example
     * // Update many Physicians
     * const physician = await prisma.physician.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Physicians and only return the `id`
     * const physicianWithIdOnly = await prisma.physician.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhysicianUpdateManyAndReturnArgs>(args: SelectSubset<T, PhysicianUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Physician.
     * @param {PhysicianUpsertArgs} args - Arguments to update or create a Physician.
     * @example
     * // Update or create a Physician
     * const physician = await prisma.physician.upsert({
     *   create: {
     *     // ... data to create a Physician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Physician we want to update
     *   }
     * })
     */
    upsert<T extends PhysicianUpsertArgs>(args: SelectSubset<T, PhysicianUpsertArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Physicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianCountArgs} args - Arguments to filter Physicians to count.
     * @example
     * // Count the number of Physicians
     * const count = await prisma.physician.count({
     *   where: {
     *     // ... the filter for the Physicians we want to count
     *   }
     * })
    **/
    count<T extends PhysicianCountArgs>(
      args?: Subset<T, PhysicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhysicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Physician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhysicianAggregateArgs>(args: Subset<T, PhysicianAggregateArgs>): Prisma.PrismaPromise<GetPhysicianAggregateType<T>>

    /**
     * Group by Physician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhysicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhysicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhysicianGroupByArgs['orderBy'] }
        : { orderBy?: PhysicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhysicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhysicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Physician model
   */
  readonly fields: PhysicianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Physician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhysicianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultations<T extends Physician$consultationsArgs<ExtArgs> = {}>(args?: Subset<T, Physician$consultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Physician$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Physician$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Physician$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Physician$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Physician model
   */
  interface PhysicianFieldRefs {
    readonly id: FieldRef<"Physician", 'String'>
    readonly staffId: FieldRef<"Physician", 'String'>
    readonly firstName: FieldRef<"Physician", 'String'>
    readonly lastName: FieldRef<"Physician", 'String'>
    readonly otherNames: FieldRef<"Physician", 'String'>
    readonly specialization: FieldRef<"Physician", 'String'>
    readonly qualification: FieldRef<"Physician", 'String'>
    readonly licenseNumber: FieldRef<"Physician", 'String'>
    readonly email: FieldRef<"Physician", 'String'>
    readonly phone: FieldRef<"Physician", 'String'>
    readonly profilePhoto: FieldRef<"Physician", 'String'>
    readonly isActive: FieldRef<"Physician", 'Boolean'>
    readonly isAvailable: FieldRef<"Physician", 'Boolean'>
    readonly createdAt: FieldRef<"Physician", 'DateTime'>
    readonly updatedAt: FieldRef<"Physician", 'DateTime'>
    readonly sync: FieldRef<"Physician", 'Boolean'>
    readonly isDeleted: FieldRef<"Physician", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Physician findUnique
   */
  export type PhysicianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician findUniqueOrThrow
   */
  export type PhysicianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician findFirst
   */
  export type PhysicianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Physicians.
     */
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician findFirstOrThrow
   */
  export type PhysicianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physician to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Physicians.
     */
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician findMany
   */
  export type PhysicianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter, which Physicians to fetch.
     */
    where?: PhysicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Physicians to fetch.
     */
    orderBy?: PhysicianOrderByWithRelationInput | PhysicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Physicians.
     */
    cursor?: PhysicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Physicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Physicians.
     */
    skip?: number
    distinct?: PhysicianScalarFieldEnum | PhysicianScalarFieldEnum[]
  }

  /**
   * Physician create
   */
  export type PhysicianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The data needed to create a Physician.
     */
    data: XOR<PhysicianCreateInput, PhysicianUncheckedCreateInput>
  }

  /**
   * Physician createMany
   */
  export type PhysicianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Physicians.
     */
    data: PhysicianCreateManyInput | PhysicianCreateManyInput[]
  }

  /**
   * Physician createManyAndReturn
   */
  export type PhysicianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * The data used to create many Physicians.
     */
    data: PhysicianCreateManyInput | PhysicianCreateManyInput[]
  }

  /**
   * Physician update
   */
  export type PhysicianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The data needed to update a Physician.
     */
    data: XOR<PhysicianUpdateInput, PhysicianUncheckedUpdateInput>
    /**
     * Choose, which Physician to update.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician updateMany
   */
  export type PhysicianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Physicians.
     */
    data: XOR<PhysicianUpdateManyMutationInput, PhysicianUncheckedUpdateManyInput>
    /**
     * Filter which Physicians to update
     */
    where?: PhysicianWhereInput
    /**
     * Limit how many Physicians to update.
     */
    limit?: number
  }

  /**
   * Physician updateManyAndReturn
   */
  export type PhysicianUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * The data used to update Physicians.
     */
    data: XOR<PhysicianUpdateManyMutationInput, PhysicianUncheckedUpdateManyInput>
    /**
     * Filter which Physicians to update
     */
    where?: PhysicianWhereInput
    /**
     * Limit how many Physicians to update.
     */
    limit?: number
  }

  /**
   * Physician upsert
   */
  export type PhysicianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * The filter to search for the Physician to update in case it exists.
     */
    where: PhysicianWhereUniqueInput
    /**
     * In case the Physician found by the `where` argument doesn't exist, create a new Physician with this data.
     */
    create: XOR<PhysicianCreateInput, PhysicianUncheckedCreateInput>
    /**
     * In case the Physician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhysicianUpdateInput, PhysicianUncheckedUpdateInput>
  }

  /**
   * Physician delete
   */
  export type PhysicianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    /**
     * Filter which Physician to delete.
     */
    where: PhysicianWhereUniqueInput
  }

  /**
   * Physician deleteMany
   */
  export type PhysicianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Physicians to delete
     */
    where?: PhysicianWhereInput
    /**
     * Limit how many Physicians to delete.
     */
    limit?: number
  }

  /**
   * Physician.consultations
   */
  export type Physician$consultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Physician.prescriptions
   */
  export type Physician$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Physician.appointments
   */
  export type Physician$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Physician without action
   */
  export type PhysicianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
  }


  /**
   * Model Queue
   */

  export type AggregateQueue = {
    _count: QueueCountAggregateOutputType | null
    _avg: QueueAvgAggregateOutputType | null
    _sum: QueueSumAggregateOutputType | null
    _min: QueueMinAggregateOutputType | null
    _max: QueueMaxAggregateOutputType | null
  }

  export type QueueAvgAggregateOutputType = {
    queueNumber: number | null
  }

  export type QueueSumAggregateOutputType = {
    queueNumber: number | null
  }

  export type QueueMinAggregateOutputType = {
    id: string | null
    queueNumber: number | null
    studentId: string | null
    priority: $Enums.priority | null
    status: string | null
    checkInTime: Date | null
    calledTime: Date | null
    completedTime: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type QueueMaxAggregateOutputType = {
    id: string | null
    queueNumber: number | null
    studentId: string | null
    priority: $Enums.priority | null
    status: string | null
    checkInTime: Date | null
    calledTime: Date | null
    completedTime: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type QueueCountAggregateOutputType = {
    id: number
    queueNumber: number
    studentId: number
    priority: number
    status: number
    checkInTime: number
    calledTime: number
    completedTime: number
    notes: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type QueueAvgAggregateInputType = {
    queueNumber?: true
  }

  export type QueueSumAggregateInputType = {
    queueNumber?: true
  }

  export type QueueMinAggregateInputType = {
    id?: true
    queueNumber?: true
    studentId?: true
    priority?: true
    status?: true
    checkInTime?: true
    calledTime?: true
    completedTime?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type QueueMaxAggregateInputType = {
    id?: true
    queueNumber?: true
    studentId?: true
    priority?: true
    status?: true
    checkInTime?: true
    calledTime?: true
    completedTime?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type QueueCountAggregateInputType = {
    id?: true
    queueNumber?: true
    studentId?: true
    priority?: true
    status?: true
    checkInTime?: true
    calledTime?: true
    completedTime?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type QueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queue to aggregate.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Queues
    **/
    _count?: true | QueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueMaxAggregateInputType
  }

  export type GetQueueAggregateType<T extends QueueAggregateArgs> = {
        [P in keyof T & keyof AggregateQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueue[P]>
      : GetScalarType<T[P], AggregateQueue[P]>
  }




  export type QueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithAggregationInput | QueueOrderByWithAggregationInput[]
    by: QueueScalarFieldEnum[] | QueueScalarFieldEnum
    having?: QueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueCountAggregateInputType | true
    _avg?: QueueAvgAggregateInputType
    _sum?: QueueSumAggregateInputType
    _min?: QueueMinAggregateInputType
    _max?: QueueMaxAggregateInputType
  }

  export type QueueGroupByOutputType = {
    id: string
    queueNumber: number
    studentId: string
    priority: $Enums.priority
    status: string
    checkInTime: Date
    calledTime: Date | null
    completedTime: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: QueueCountAggregateOutputType | null
    _avg: QueueAvgAggregateOutputType | null
    _sum: QueueSumAggregateOutputType | null
    _min: QueueMinAggregateOutputType | null
    _max: QueueMaxAggregateOutputType | null
  }

  type GetQueueGroupByPayload<T extends QueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueGroupByOutputType[P]>
            : GetScalarType<T[P], QueueGroupByOutputType[P]>
        }
      >
    >


  export type QueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueNumber?: boolean
    studentId?: boolean
    priority?: boolean
    status?: boolean
    checkInTime?: boolean
    calledTime?: boolean
    completedTime?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queue"]>

  export type QueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueNumber?: boolean
    studentId?: boolean
    priority?: boolean
    status?: boolean
    checkInTime?: boolean
    calledTime?: boolean
    completedTime?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queue"]>

  export type QueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queueNumber?: boolean
    studentId?: boolean
    priority?: boolean
    status?: boolean
    checkInTime?: boolean
    calledTime?: boolean
    completedTime?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queue"]>

  export type QueueSelectScalar = {
    id?: boolean
    queueNumber?: boolean
    studentId?: boolean
    priority?: boolean
    status?: boolean
    checkInTime?: boolean
    calledTime?: boolean
    completedTime?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type QueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queueNumber" | "studentId" | "priority" | "status" | "checkInTime" | "calledTime" | "completedTime" | "notes" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["queue"]>
  export type QueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type QueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type QueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $QueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Queue"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queueNumber: number
      studentId: string
      priority: $Enums.priority
      status: string
      checkInTime: Date
      calledTime: Date | null
      completedTime: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["queue"]>
    composites: {}
  }

  type QueueGetPayload<S extends boolean | null | undefined | QueueDefaultArgs> = $Result.GetResult<Prisma.$QueuePayload, S>

  type QueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueueCountAggregateInputType | true
    }

  export interface QueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Queue'], meta: { name: 'Queue' } }
    /**
     * Find zero or one Queue that matches the filter.
     * @param {QueueFindUniqueArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueFindUniqueArgs>(args: SelectSubset<T, QueueFindUniqueArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Queue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueFindUniqueOrThrowArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Queue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindFirstArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueFindFirstArgs>(args?: SelectSubset<T, QueueFindFirstArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Queue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindFirstOrThrowArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Queues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queues
     * const queues = await prisma.queue.findMany()
     * 
     * // Get first 10 Queues
     * const queues = await prisma.queue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueWithIdOnly = await prisma.queue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueFindManyArgs>(args?: SelectSubset<T, QueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Queue.
     * @param {QueueCreateArgs} args - Arguments to create a Queue.
     * @example
     * // Create one Queue
     * const Queue = await prisma.queue.create({
     *   data: {
     *     // ... data to create a Queue
     *   }
     * })
     * 
     */
    create<T extends QueueCreateArgs>(args: SelectSubset<T, QueueCreateArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Queues.
     * @param {QueueCreateManyArgs} args - Arguments to create many Queues.
     * @example
     * // Create many Queues
     * const queue = await prisma.queue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueCreateManyArgs>(args?: SelectSubset<T, QueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Queues and returns the data saved in the database.
     * @param {QueueCreateManyAndReturnArgs} args - Arguments to create many Queues.
     * @example
     * // Create many Queues
     * const queue = await prisma.queue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Queues and only return the `id`
     * const queueWithIdOnly = await prisma.queue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueueCreateManyAndReturnArgs>(args?: SelectSubset<T, QueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Queue.
     * @param {QueueDeleteArgs} args - Arguments to delete one Queue.
     * @example
     * // Delete one Queue
     * const Queue = await prisma.queue.delete({
     *   where: {
     *     // ... filter to delete one Queue
     *   }
     * })
     * 
     */
    delete<T extends QueueDeleteArgs>(args: SelectSubset<T, QueueDeleteArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Queue.
     * @param {QueueUpdateArgs} args - Arguments to update one Queue.
     * @example
     * // Update one Queue
     * const queue = await prisma.queue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueUpdateArgs>(args: SelectSubset<T, QueueUpdateArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Queues.
     * @param {QueueDeleteManyArgs} args - Arguments to filter Queues to delete.
     * @example
     * // Delete a few Queues
     * const { count } = await prisma.queue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueDeleteManyArgs>(args?: SelectSubset<T, QueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queues
     * const queue = await prisma.queue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueUpdateManyArgs>(args: SelectSubset<T, QueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queues and returns the data updated in the database.
     * @param {QueueUpdateManyAndReturnArgs} args - Arguments to update many Queues.
     * @example
     * // Update many Queues
     * const queue = await prisma.queue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Queues and only return the `id`
     * const queueWithIdOnly = await prisma.queue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueueUpdateManyAndReturnArgs>(args: SelectSubset<T, QueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Queue.
     * @param {QueueUpsertArgs} args - Arguments to update or create a Queue.
     * @example
     * // Update or create a Queue
     * const queue = await prisma.queue.upsert({
     *   create: {
     *     // ... data to create a Queue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Queue we want to update
     *   }
     * })
     */
    upsert<T extends QueueUpsertArgs>(args: SelectSubset<T, QueueUpsertArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueCountArgs} args - Arguments to filter Queues to count.
     * @example
     * // Count the number of Queues
     * const count = await prisma.queue.count({
     *   where: {
     *     // ... the filter for the Queues we want to count
     *   }
     * })
    **/
    count<T extends QueueCountArgs>(
      args?: Subset<T, QueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueAggregateArgs>(args: Subset<T, QueueAggregateArgs>): Prisma.PrismaPromise<GetQueueAggregateType<T>>

    /**
     * Group by Queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueGroupByArgs['orderBy'] }
        : { orderBy?: QueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Queue model
   */
  readonly fields: QueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Queue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Queue model
   */
  interface QueueFieldRefs {
    readonly id: FieldRef<"Queue", 'String'>
    readonly queueNumber: FieldRef<"Queue", 'Int'>
    readonly studentId: FieldRef<"Queue", 'String'>
    readonly priority: FieldRef<"Queue", 'priority'>
    readonly status: FieldRef<"Queue", 'String'>
    readonly checkInTime: FieldRef<"Queue", 'DateTime'>
    readonly calledTime: FieldRef<"Queue", 'DateTime'>
    readonly completedTime: FieldRef<"Queue", 'DateTime'>
    readonly notes: FieldRef<"Queue", 'String'>
    readonly createdAt: FieldRef<"Queue", 'DateTime'>
    readonly updatedAt: FieldRef<"Queue", 'DateTime'>
    readonly isDeleted: FieldRef<"Queue", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Queue findUnique
   */
  export type QueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where: QueueWhereUniqueInput
  }

  /**
   * Queue findUniqueOrThrow
   */
  export type QueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where: QueueWhereUniqueInput
  }

  /**
   * Queue findFirst
   */
  export type QueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queues.
     */
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Queue findFirstOrThrow
   */
  export type QueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queues.
     */
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Queue findMany
   */
  export type QueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queues to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Queue create
   */
  export type QueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The data needed to create a Queue.
     */
    data: XOR<QueueCreateInput, QueueUncheckedCreateInput>
  }

  /**
   * Queue createMany
   */
  export type QueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Queues.
     */
    data: QueueCreateManyInput | QueueCreateManyInput[]
  }

  /**
   * Queue createManyAndReturn
   */
  export type QueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * The data used to create many Queues.
     */
    data: QueueCreateManyInput | QueueCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Queue update
   */
  export type QueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The data needed to update a Queue.
     */
    data: XOR<QueueUpdateInput, QueueUncheckedUpdateInput>
    /**
     * Choose, which Queue to update.
     */
    where: QueueWhereUniqueInput
  }

  /**
   * Queue updateMany
   */
  export type QueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Queues.
     */
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyInput>
    /**
     * Filter which Queues to update
     */
    where?: QueueWhereInput
    /**
     * Limit how many Queues to update.
     */
    limit?: number
  }

  /**
   * Queue updateManyAndReturn
   */
  export type QueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * The data used to update Queues.
     */
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyInput>
    /**
     * Filter which Queues to update
     */
    where?: QueueWhereInput
    /**
     * Limit how many Queues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Queue upsert
   */
  export type QueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The filter to search for the Queue to update in case it exists.
     */
    where: QueueWhereUniqueInput
    /**
     * In case the Queue found by the `where` argument doesn't exist, create a new Queue with this data.
     */
    create: XOR<QueueCreateInput, QueueUncheckedCreateInput>
    /**
     * In case the Queue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueUpdateInput, QueueUncheckedUpdateInput>
  }

  /**
   * Queue delete
   */
  export type QueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter which Queue to delete.
     */
    where: QueueWhereUniqueInput
  }

  /**
   * Queue deleteMany
   */
  export type QueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queues to delete
     */
    where?: QueueWhereInput
    /**
     * Limit how many Queues to delete.
     */
    limit?: number
  }

  /**
   * Queue without action
   */
  export type QueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    appointmentNo: string | null
    studentId: string | null
    physicianId: string | null
    appointmentDate: Date | null
    appointmentTime: string | null
    reason: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    appointmentNo: string | null
    studentId: string | null
    physicianId: string | null
    appointmentDate: Date | null
    appointmentTime: string | null
    reason: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    appointmentNo: number
    studentId: number
    physicianId: number
    appointmentDate: number
    appointmentTime: number
    reason: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    appointmentNo?: true
    studentId?: true
    physicianId?: true
    appointmentDate?: true
    appointmentTime?: true
    reason?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    appointmentNo?: true
    studentId?: true
    physicianId?: true
    appointmentDate?: true
    appointmentTime?: true
    reason?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    appointmentNo?: true
    studentId?: true
    physicianId?: true
    appointmentDate?: true
    appointmentTime?: true
    reason?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    appointmentNo: string
    studentId: string
    physicianId: string | null
    appointmentDate: Date
    appointmentTime: string
    reason: string
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    appointmentDate?: boolean
    appointmentTime?: boolean
    reason?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | Appointment$physicianArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    appointmentDate?: boolean
    appointmentTime?: boolean
    reason?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | Appointment$physicianArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    appointmentDate?: boolean
    appointmentTime?: boolean
    reason?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | Appointment$physicianArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    appointmentNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    appointmentDate?: boolean
    appointmentTime?: boolean
    reason?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentNo" | "studentId" | "physicianId" | "appointmentDate" | "appointmentTime" | "reason" | "status" | "notes" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | Appointment$physicianArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | Appointment$physicianArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | Appointment$physicianArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      physician: Prisma.$PhysicianPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentNo: string
      studentId: string
      physicianId: string | null
      appointmentDate: Date
      appointmentTime: string
      reason: string
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    physician<T extends Appointment$physicianArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$physicianArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly appointmentNo: FieldRef<"Appointment", 'String'>
    readonly studentId: FieldRef<"Appointment", 'String'>
    readonly physicianId: FieldRef<"Appointment", 'String'>
    readonly appointmentDate: FieldRef<"Appointment", 'DateTime'>
    readonly appointmentTime: FieldRef<"Appointment", 'String'>
    readonly reason: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'String'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
    readonly isDeleted: FieldRef<"Appointment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.physician
   */
  export type Appointment$physicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Physician
     */
    select?: PhysicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Physician
     */
    omit?: PhysicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhysicianInclude<ExtArgs> | null
    where?: PhysicianWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model VitalSigns
   */

  export type AggregateVitalSigns = {
    _count: VitalSignsCountAggregateOutputType | null
    _avg: VitalSignsAvgAggregateOutputType | null
    _sum: VitalSignsSumAggregateOutputType | null
    _min: VitalSignsMinAggregateOutputType | null
    _max: VitalSignsMaxAggregateOutputType | null
  }

  export type VitalSignsAvgAggregateOutputType = {
    temperature: number | null
    pulse: number | null
    respiratoryRate: number | null
    weight: number | null
    height: number | null
    bmi: number | null
    oxygenSaturation: number | null
  }

  export type VitalSignsSumAggregateOutputType = {
    temperature: number | null
    pulse: number | null
    respiratoryRate: number | null
    weight: number | null
    height: number | null
    bmi: number | null
    oxygenSaturation: number | null
  }

  export type VitalSignsMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    consultationId: string | null
    temperature: number | null
    bloodPressure: string | null
    pulse: number | null
    respiratoryRate: number | null
    weight: number | null
    height: number | null
    bmi: number | null
    oxygenSaturation: number | null
    recordedBy: string | null
    createdAt: Date | null
    isDeleted: boolean | null
  }

  export type VitalSignsMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    consultationId: string | null
    temperature: number | null
    bloodPressure: string | null
    pulse: number | null
    respiratoryRate: number | null
    weight: number | null
    height: number | null
    bmi: number | null
    oxygenSaturation: number | null
    recordedBy: string | null
    createdAt: Date | null
    isDeleted: boolean | null
  }

  export type VitalSignsCountAggregateOutputType = {
    id: number
    studentId: number
    consultationId: number
    temperature: number
    bloodPressure: number
    pulse: number
    respiratoryRate: number
    weight: number
    height: number
    bmi: number
    oxygenSaturation: number
    recordedBy: number
    createdAt: number
    isDeleted: number
    _all: number
  }


  export type VitalSignsAvgAggregateInputType = {
    temperature?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    bmi?: true
    oxygenSaturation?: true
  }

  export type VitalSignsSumAggregateInputType = {
    temperature?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    bmi?: true
    oxygenSaturation?: true
  }

  export type VitalSignsMinAggregateInputType = {
    id?: true
    studentId?: true
    consultationId?: true
    temperature?: true
    bloodPressure?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    bmi?: true
    oxygenSaturation?: true
    recordedBy?: true
    createdAt?: true
    isDeleted?: true
  }

  export type VitalSignsMaxAggregateInputType = {
    id?: true
    studentId?: true
    consultationId?: true
    temperature?: true
    bloodPressure?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    bmi?: true
    oxygenSaturation?: true
    recordedBy?: true
    createdAt?: true
    isDeleted?: true
  }

  export type VitalSignsCountAggregateInputType = {
    id?: true
    studentId?: true
    consultationId?: true
    temperature?: true
    bloodPressure?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    bmi?: true
    oxygenSaturation?: true
    recordedBy?: true
    createdAt?: true
    isDeleted?: true
    _all?: true
  }

  export type VitalSignsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to aggregate.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitalSigns
    **/
    _count?: true | VitalSignsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitalSignsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitalSignsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitalSignsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitalSignsMaxAggregateInputType
  }

  export type GetVitalSignsAggregateType<T extends VitalSignsAggregateArgs> = {
        [P in keyof T & keyof AggregateVitalSigns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitalSigns[P]>
      : GetScalarType<T[P], AggregateVitalSigns[P]>
  }




  export type VitalSignsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignsWhereInput
    orderBy?: VitalSignsOrderByWithAggregationInput | VitalSignsOrderByWithAggregationInput[]
    by: VitalSignsScalarFieldEnum[] | VitalSignsScalarFieldEnum
    having?: VitalSignsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitalSignsCountAggregateInputType | true
    _avg?: VitalSignsAvgAggregateInputType
    _sum?: VitalSignsSumAggregateInputType
    _min?: VitalSignsMinAggregateInputType
    _max?: VitalSignsMaxAggregateInputType
  }

  export type VitalSignsGroupByOutputType = {
    id: string
    studentId: string
    consultationId: string | null
    temperature: number | null
    bloodPressure: string | null
    pulse: number | null
    respiratoryRate: number | null
    weight: number | null
    height: number | null
    bmi: number | null
    oxygenSaturation: number | null
    recordedBy: string
    createdAt: Date
    isDeleted: boolean
    _count: VitalSignsCountAggregateOutputType | null
    _avg: VitalSignsAvgAggregateOutputType | null
    _sum: VitalSignsSumAggregateOutputType | null
    _min: VitalSignsMinAggregateOutputType | null
    _max: VitalSignsMaxAggregateOutputType | null
  }

  type GetVitalSignsGroupByPayload<T extends VitalSignsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VitalSignsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitalSignsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitalSignsGroupByOutputType[P]>
            : GetScalarType<T[P], VitalSignsGroupByOutputType[P]>
        }
      >
    >


  export type VitalSignsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    consultationId?: boolean
    temperature?: boolean
    bloodPressure?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    bmi?: boolean
    oxygenSaturation?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultation?: boolean | VitalSigns$consultationArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSigns"]>

  export type VitalSignsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    consultationId?: boolean
    temperature?: boolean
    bloodPressure?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    bmi?: boolean
    oxygenSaturation?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultation?: boolean | VitalSigns$consultationArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSigns"]>

  export type VitalSignsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    consultationId?: boolean
    temperature?: boolean
    bloodPressure?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    bmi?: boolean
    oxygenSaturation?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultation?: boolean | VitalSigns$consultationArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSigns"]>

  export type VitalSignsSelectScalar = {
    id?: boolean
    studentId?: boolean
    consultationId?: boolean
    temperature?: boolean
    bloodPressure?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    bmi?: boolean
    oxygenSaturation?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    isDeleted?: boolean
  }

  export type VitalSignsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "consultationId" | "temperature" | "bloodPressure" | "pulse" | "respiratoryRate" | "weight" | "height" | "bmi" | "oxygenSaturation" | "recordedBy" | "createdAt" | "isDeleted", ExtArgs["result"]["vitalSigns"]>
  export type VitalSignsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultation?: boolean | VitalSigns$consultationArgs<ExtArgs>
  }
  export type VitalSignsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultation?: boolean | VitalSigns$consultationArgs<ExtArgs>
  }
  export type VitalSignsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultation?: boolean | VitalSigns$consultationArgs<ExtArgs>
  }

  export type $VitalSignsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VitalSigns"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      consultation: Prisma.$ConsultationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      consultationId: string | null
      temperature: number | null
      bloodPressure: string | null
      pulse: number | null
      respiratoryRate: number | null
      weight: number | null
      height: number | null
      bmi: number | null
      oxygenSaturation: number | null
      recordedBy: string
      createdAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["vitalSigns"]>
    composites: {}
  }

  type VitalSignsGetPayload<S extends boolean | null | undefined | VitalSignsDefaultArgs> = $Result.GetResult<Prisma.$VitalSignsPayload, S>

  type VitalSignsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VitalSignsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VitalSignsCountAggregateInputType | true
    }

  export interface VitalSignsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VitalSigns'], meta: { name: 'VitalSigns' } }
    /**
     * Find zero or one VitalSigns that matches the filter.
     * @param {VitalSignsFindUniqueArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VitalSignsFindUniqueArgs>(args: SelectSubset<T, VitalSignsFindUniqueArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VitalSigns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VitalSignsFindUniqueOrThrowArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VitalSignsFindUniqueOrThrowArgs>(args: SelectSubset<T, VitalSignsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindFirstArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VitalSignsFindFirstArgs>(args?: SelectSubset<T, VitalSignsFindFirstArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSigns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindFirstOrThrowArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VitalSignsFindFirstOrThrowArgs>(args?: SelectSubset<T, VitalSignsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findMany()
     * 
     * // Get first 10 VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitalSignsWithIdOnly = await prisma.vitalSigns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VitalSignsFindManyArgs>(args?: SelectSubset<T, VitalSignsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VitalSigns.
     * @param {VitalSignsCreateArgs} args - Arguments to create a VitalSigns.
     * @example
     * // Create one VitalSigns
     * const VitalSigns = await prisma.vitalSigns.create({
     *   data: {
     *     // ... data to create a VitalSigns
     *   }
     * })
     * 
     */
    create<T extends VitalSignsCreateArgs>(args: SelectSubset<T, VitalSignsCreateArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VitalSigns.
     * @param {VitalSignsCreateManyArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VitalSignsCreateManyArgs>(args?: SelectSubset<T, VitalSignsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VitalSigns and returns the data saved in the database.
     * @param {VitalSignsCreateManyAndReturnArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VitalSigns and only return the `id`
     * const vitalSignsWithIdOnly = await prisma.vitalSigns.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VitalSignsCreateManyAndReturnArgs>(args?: SelectSubset<T, VitalSignsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VitalSigns.
     * @param {VitalSignsDeleteArgs} args - Arguments to delete one VitalSigns.
     * @example
     * // Delete one VitalSigns
     * const VitalSigns = await prisma.vitalSigns.delete({
     *   where: {
     *     // ... filter to delete one VitalSigns
     *   }
     * })
     * 
     */
    delete<T extends VitalSignsDeleteArgs>(args: SelectSubset<T, VitalSignsDeleteArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VitalSigns.
     * @param {VitalSignsUpdateArgs} args - Arguments to update one VitalSigns.
     * @example
     * // Update one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VitalSignsUpdateArgs>(args: SelectSubset<T, VitalSignsUpdateArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VitalSigns.
     * @param {VitalSignsDeleteManyArgs} args - Arguments to filter VitalSigns to delete.
     * @example
     * // Delete a few VitalSigns
     * const { count } = await prisma.vitalSigns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VitalSignsDeleteManyArgs>(args?: SelectSubset<T, VitalSignsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VitalSignsUpdateManyArgs>(args: SelectSubset<T, VitalSignsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns and returns the data updated in the database.
     * @param {VitalSignsUpdateManyAndReturnArgs} args - Arguments to update many VitalSigns.
     * @example
     * // Update many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VitalSigns and only return the `id`
     * const vitalSignsWithIdOnly = await prisma.vitalSigns.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VitalSignsUpdateManyAndReturnArgs>(args: SelectSubset<T, VitalSignsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VitalSigns.
     * @param {VitalSignsUpsertArgs} args - Arguments to update or create a VitalSigns.
     * @example
     * // Update or create a VitalSigns
     * const vitalSigns = await prisma.vitalSigns.upsert({
     *   create: {
     *     // ... data to create a VitalSigns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitalSigns we want to update
     *   }
     * })
     */
    upsert<T extends VitalSignsUpsertArgs>(args: SelectSubset<T, VitalSignsUpsertArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsCountArgs} args - Arguments to filter VitalSigns to count.
     * @example
     * // Count the number of VitalSigns
     * const count = await prisma.vitalSigns.count({
     *   where: {
     *     // ... the filter for the VitalSigns we want to count
     *   }
     * })
    **/
    count<T extends VitalSignsCountArgs>(
      args?: Subset<T, VitalSignsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitalSignsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitalSignsAggregateArgs>(args: Subset<T, VitalSignsAggregateArgs>): Prisma.PrismaPromise<GetVitalSignsAggregateType<T>>

    /**
     * Group by VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitalSignsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitalSignsGroupByArgs['orderBy'] }
        : { orderBy?: VitalSignsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitalSignsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitalSignsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VitalSigns model
   */
  readonly fields: VitalSignsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitalSigns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VitalSignsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    consultation<T extends VitalSigns$consultationArgs<ExtArgs> = {}>(args?: Subset<T, VitalSigns$consultationArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VitalSigns model
   */
  interface VitalSignsFieldRefs {
    readonly id: FieldRef<"VitalSigns", 'String'>
    readonly studentId: FieldRef<"VitalSigns", 'String'>
    readonly consultationId: FieldRef<"VitalSigns", 'String'>
    readonly temperature: FieldRef<"VitalSigns", 'Float'>
    readonly bloodPressure: FieldRef<"VitalSigns", 'String'>
    readonly pulse: FieldRef<"VitalSigns", 'Int'>
    readonly respiratoryRate: FieldRef<"VitalSigns", 'Int'>
    readonly weight: FieldRef<"VitalSigns", 'Float'>
    readonly height: FieldRef<"VitalSigns", 'Float'>
    readonly bmi: FieldRef<"VitalSigns", 'Float'>
    readonly oxygenSaturation: FieldRef<"VitalSigns", 'Int'>
    readonly recordedBy: FieldRef<"VitalSigns", 'String'>
    readonly createdAt: FieldRef<"VitalSigns", 'DateTime'>
    readonly isDeleted: FieldRef<"VitalSigns", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * VitalSigns findUnique
   */
  export type VitalSignsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns findUniqueOrThrow
   */
  export type VitalSignsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns findFirst
   */
  export type VitalSignsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns findFirstOrThrow
   */
  export type VitalSignsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns findMany
   */
  export type VitalSignsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns create
   */
  export type VitalSignsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The data needed to create a VitalSigns.
     */
    data: XOR<VitalSignsCreateInput, VitalSignsUncheckedCreateInput>
  }

  /**
   * VitalSigns createMany
   */
  export type VitalSignsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignsCreateManyInput | VitalSignsCreateManyInput[]
  }

  /**
   * VitalSigns createManyAndReturn
   */
  export type VitalSignsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignsCreateManyInput | VitalSignsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSigns update
   */
  export type VitalSignsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The data needed to update a VitalSigns.
     */
    data: XOR<VitalSignsUpdateInput, VitalSignsUncheckedUpdateInput>
    /**
     * Choose, which VitalSigns to update.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns updateMany
   */
  export type VitalSignsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignsWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
  }

  /**
   * VitalSigns updateManyAndReturn
   */
  export type VitalSignsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignsWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VitalSigns upsert
   */
  export type VitalSignsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The filter to search for the VitalSigns to update in case it exists.
     */
    where: VitalSignsWhereUniqueInput
    /**
     * In case the VitalSigns found by the `where` argument doesn't exist, create a new VitalSigns with this data.
     */
    create: XOR<VitalSignsCreateInput, VitalSignsUncheckedCreateInput>
    /**
     * In case the VitalSigns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VitalSignsUpdateInput, VitalSignsUncheckedUpdateInput>
  }

  /**
   * VitalSigns delete
   */
  export type VitalSignsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter which VitalSigns to delete.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns deleteMany
   */
  export type VitalSignsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to delete
     */
    where?: VitalSignsWhereInput
    /**
     * Limit how many VitalSigns to delete.
     */
    limit?: number
  }

  /**
   * VitalSigns.consultation
   */
  export type VitalSigns$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
  }

  /**
   * VitalSigns without action
   */
  export type VitalSignsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
  }


  /**
   * Model Consultation
   */

  export type AggregateConsultation = {
    _count: ConsultationCountAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  export type ConsultationMinAggregateOutputType = {
    id: string | null
    consultationNo: string | null
    studentId: string | null
    physicianId: string | null
    chiefComplaint: string | null
    historyOfPresenting: string | null
    symptoms: string | null
    physicalExamination: string | null
    diagnosis: string | null
    differentialDiagnosis: string | null
    treatmentPlan: string | null
    notes: string | null
    followUpDate: Date | null
    status: $Enums.consultationStatus | null
    priority: $Enums.priority | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    isDeleted: boolean | null
  }

  export type ConsultationMaxAggregateOutputType = {
    id: string | null
    consultationNo: string | null
    studentId: string | null
    physicianId: string | null
    chiefComplaint: string | null
    historyOfPresenting: string | null
    symptoms: string | null
    physicalExamination: string | null
    diagnosis: string | null
    differentialDiagnosis: string | null
    treatmentPlan: string | null
    notes: string | null
    followUpDate: Date | null
    status: $Enums.consultationStatus | null
    priority: $Enums.priority | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    isDeleted: boolean | null
  }

  export type ConsultationCountAggregateOutputType = {
    id: number
    consultationNo: number
    studentId: number
    physicianId: number
    chiefComplaint: number
    historyOfPresenting: number
    symptoms: number
    physicalExamination: number
    diagnosis: number
    differentialDiagnosis: number
    treatmentPlan: number
    notes: number
    followUpDate: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    completedAt: number
    isDeleted: number
    _all: number
  }


  export type ConsultationMinAggregateInputType = {
    id?: true
    consultationNo?: true
    studentId?: true
    physicianId?: true
    chiefComplaint?: true
    historyOfPresenting?: true
    symptoms?: true
    physicalExamination?: true
    diagnosis?: true
    differentialDiagnosis?: true
    treatmentPlan?: true
    notes?: true
    followUpDate?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    isDeleted?: true
  }

  export type ConsultationMaxAggregateInputType = {
    id?: true
    consultationNo?: true
    studentId?: true
    physicianId?: true
    chiefComplaint?: true
    historyOfPresenting?: true
    symptoms?: true
    physicalExamination?: true
    diagnosis?: true
    differentialDiagnosis?: true
    treatmentPlan?: true
    notes?: true
    followUpDate?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    isDeleted?: true
  }

  export type ConsultationCountAggregateInputType = {
    id?: true
    consultationNo?: true
    studentId?: true
    physicianId?: true
    chiefComplaint?: true
    historyOfPresenting?: true
    symptoms?: true
    physicalExamination?: true
    diagnosis?: true
    differentialDiagnosis?: true
    treatmentPlan?: true
    notes?: true
    followUpDate?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type ConsultationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultation to aggregate.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consultations
    **/
    _count?: true | ConsultationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationMaxAggregateInputType
  }

  export type GetConsultationAggregateType<T extends ConsultationAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultation[P]>
      : GetScalarType<T[P], AggregateConsultation[P]>
  }




  export type ConsultationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithAggregationInput | ConsultationOrderByWithAggregationInput[]
    by: ConsultationScalarFieldEnum[] | ConsultationScalarFieldEnum
    having?: ConsultationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationCountAggregateInputType | true
    _min?: ConsultationMinAggregateInputType
    _max?: ConsultationMaxAggregateInputType
  }

  export type ConsultationGroupByOutputType = {
    id: string
    consultationNo: string
    studentId: string
    physicianId: string
    chiefComplaint: string
    historyOfPresenting: string | null
    symptoms: string
    physicalExamination: string | null
    diagnosis: string
    differentialDiagnosis: string | null
    treatmentPlan: string | null
    notes: string | null
    followUpDate: Date | null
    status: $Enums.consultationStatus
    priority: $Enums.priority
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    isDeleted: boolean
    _count: ConsultationCountAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  type GetConsultationGroupByPayload<T extends ConsultationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    chiefComplaint?: boolean
    historyOfPresenting?: boolean
    symptoms?: boolean
    physicalExamination?: boolean
    diagnosis?: boolean
    differentialDiagnosis?: boolean
    treatmentPlan?: boolean
    notes?: boolean
    followUpDate?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
    vitalSigns?: boolean | Consultation$vitalSignsArgs<ExtArgs>
    prescriptions?: boolean | Consultation$prescriptionsArgs<ExtArgs>
    _count?: boolean | ConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>

  export type ConsultationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    chiefComplaint?: boolean
    historyOfPresenting?: boolean
    symptoms?: boolean
    physicalExamination?: boolean
    diagnosis?: boolean
    differentialDiagnosis?: boolean
    treatmentPlan?: boolean
    notes?: boolean
    followUpDate?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>

  export type ConsultationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    chiefComplaint?: boolean
    historyOfPresenting?: boolean
    symptoms?: boolean
    physicalExamination?: boolean
    diagnosis?: boolean
    differentialDiagnosis?: boolean
    treatmentPlan?: boolean
    notes?: boolean
    followUpDate?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>

  export type ConsultationSelectScalar = {
    id?: boolean
    consultationNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    chiefComplaint?: boolean
    historyOfPresenting?: boolean
    symptoms?: boolean
    physicalExamination?: boolean
    diagnosis?: boolean
    differentialDiagnosis?: boolean
    treatmentPlan?: boolean
    notes?: boolean
    followUpDate?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    isDeleted?: boolean
  }

  export type ConsultationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "consultationNo" | "studentId" | "physicianId" | "chiefComplaint" | "historyOfPresenting" | "symptoms" | "physicalExamination" | "diagnosis" | "differentialDiagnosis" | "treatmentPlan" | "notes" | "followUpDate" | "status" | "priority" | "createdAt" | "updatedAt" | "completedAt" | "isDeleted", ExtArgs["result"]["consultation"]>
  export type ConsultationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
    vitalSigns?: boolean | Consultation$vitalSignsArgs<ExtArgs>
    prescriptions?: boolean | Consultation$prescriptionsArgs<ExtArgs>
    _count?: boolean | ConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConsultationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
  }
  export type ConsultationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
  }

  export type $ConsultationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consultation"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      physician: Prisma.$PhysicianPayload<ExtArgs>
      vitalSigns: Prisma.$VitalSignsPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultationNo: string
      studentId: string
      physicianId: string
      chiefComplaint: string
      historyOfPresenting: string | null
      symptoms: string
      physicalExamination: string | null
      diagnosis: string
      differentialDiagnosis: string | null
      treatmentPlan: string | null
      notes: string | null
      followUpDate: Date | null
      status: $Enums.consultationStatus
      priority: $Enums.priority
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["consultation"]>
    composites: {}
  }

  type ConsultationGetPayload<S extends boolean | null | undefined | ConsultationDefaultArgs> = $Result.GetResult<Prisma.$ConsultationPayload, S>

  type ConsultationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConsultationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultationCountAggregateInputType | true
    }

  export interface ConsultationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consultation'], meta: { name: 'Consultation' } }
    /**
     * Find zero or one Consultation that matches the filter.
     * @param {ConsultationFindUniqueArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationFindUniqueArgs>(args: SelectSubset<T, ConsultationFindUniqueArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consultation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsultationFindUniqueOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationFindFirstArgs>(args?: SelectSubset<T, ConsultationFindFirstArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultations
     * const consultations = await prisma.consultation.findMany()
     * 
     * // Get first 10 Consultations
     * const consultations = await prisma.consultation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationWithIdOnly = await prisma.consultation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationFindManyArgs>(args?: SelectSubset<T, ConsultationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consultation.
     * @param {ConsultationCreateArgs} args - Arguments to create a Consultation.
     * @example
     * // Create one Consultation
     * const Consultation = await prisma.consultation.create({
     *   data: {
     *     // ... data to create a Consultation
     *   }
     * })
     * 
     */
    create<T extends ConsultationCreateArgs>(args: SelectSubset<T, ConsultationCreateArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consultations.
     * @param {ConsultationCreateManyArgs} args - Arguments to create many Consultations.
     * @example
     * // Create many Consultations
     * const consultation = await prisma.consultation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationCreateManyArgs>(args?: SelectSubset<T, ConsultationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consultations and returns the data saved in the database.
     * @param {ConsultationCreateManyAndReturnArgs} args - Arguments to create many Consultations.
     * @example
     * // Create many Consultations
     * const consultation = await prisma.consultation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consultations and only return the `id`
     * const consultationWithIdOnly = await prisma.consultation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consultation.
     * @param {ConsultationDeleteArgs} args - Arguments to delete one Consultation.
     * @example
     * // Delete one Consultation
     * const Consultation = await prisma.consultation.delete({
     *   where: {
     *     // ... filter to delete one Consultation
     *   }
     * })
     * 
     */
    delete<T extends ConsultationDeleteArgs>(args: SelectSubset<T, ConsultationDeleteArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consultation.
     * @param {ConsultationUpdateArgs} args - Arguments to update one Consultation.
     * @example
     * // Update one Consultation
     * const consultation = await prisma.consultation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationUpdateArgs>(args: SelectSubset<T, ConsultationUpdateArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consultations.
     * @param {ConsultationDeleteManyArgs} args - Arguments to filter Consultations to delete.
     * @example
     * // Delete a few Consultations
     * const { count } = await prisma.consultation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationDeleteManyArgs>(args?: SelectSubset<T, ConsultationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultations
     * const consultation = await prisma.consultation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationUpdateManyArgs>(args: SelectSubset<T, ConsultationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations and returns the data updated in the database.
     * @param {ConsultationUpdateManyAndReturnArgs} args - Arguments to update many Consultations.
     * @example
     * // Update many Consultations
     * const consultation = await prisma.consultation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consultations and only return the `id`
     * const consultationWithIdOnly = await prisma.consultation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConsultationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConsultationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consultation.
     * @param {ConsultationUpsertArgs} args - Arguments to update or create a Consultation.
     * @example
     * // Update or create a Consultation
     * const consultation = await prisma.consultation.upsert({
     *   create: {
     *     // ... data to create a Consultation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultation we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationUpsertArgs>(args: SelectSubset<T, ConsultationUpsertArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationCountArgs} args - Arguments to filter Consultations to count.
     * @example
     * // Count the number of Consultations
     * const count = await prisma.consultation.count({
     *   where: {
     *     // ... the filter for the Consultations we want to count
     *   }
     * })
    **/
    count<T extends ConsultationCountArgs>(
      args?: Subset<T, ConsultationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationAggregateArgs>(args: Subset<T, ConsultationAggregateArgs>): Prisma.PrismaPromise<GetConsultationAggregateType<T>>

    /**
     * Group by Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consultation model
   */
  readonly fields: ConsultationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consultation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    physician<T extends PhysicianDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhysicianDefaultArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vitalSigns<T extends Consultation$vitalSignsArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$vitalSignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Consultation$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Consultation model
   */
  interface ConsultationFieldRefs {
    readonly id: FieldRef<"Consultation", 'String'>
    readonly consultationNo: FieldRef<"Consultation", 'String'>
    readonly studentId: FieldRef<"Consultation", 'String'>
    readonly physicianId: FieldRef<"Consultation", 'String'>
    readonly chiefComplaint: FieldRef<"Consultation", 'String'>
    readonly historyOfPresenting: FieldRef<"Consultation", 'String'>
    readonly symptoms: FieldRef<"Consultation", 'String'>
    readonly physicalExamination: FieldRef<"Consultation", 'String'>
    readonly diagnosis: FieldRef<"Consultation", 'String'>
    readonly differentialDiagnosis: FieldRef<"Consultation", 'String'>
    readonly treatmentPlan: FieldRef<"Consultation", 'String'>
    readonly notes: FieldRef<"Consultation", 'String'>
    readonly followUpDate: FieldRef<"Consultation", 'DateTime'>
    readonly status: FieldRef<"Consultation", 'consultationStatus'>
    readonly priority: FieldRef<"Consultation", 'priority'>
    readonly createdAt: FieldRef<"Consultation", 'DateTime'>
    readonly updatedAt: FieldRef<"Consultation", 'DateTime'>
    readonly completedAt: FieldRef<"Consultation", 'DateTime'>
    readonly isDeleted: FieldRef<"Consultation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Consultation findUnique
   */
  export type ConsultationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation findUniqueOrThrow
   */
  export type ConsultationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation findFirst
   */
  export type ConsultationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation findFirstOrThrow
   */
  export type ConsultationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation findMany
   */
  export type ConsultationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultations to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation create
   */
  export type ConsultationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to create a Consultation.
     */
    data: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
  }

  /**
   * Consultation createMany
   */
  export type ConsultationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consultations.
     */
    data: ConsultationCreateManyInput | ConsultationCreateManyInput[]
  }

  /**
   * Consultation createManyAndReturn
   */
  export type ConsultationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * The data used to create many Consultations.
     */
    data: ConsultationCreateManyInput | ConsultationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consultation update
   */
  export type ConsultationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to update a Consultation.
     */
    data: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
    /**
     * Choose, which Consultation to update.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation updateMany
   */
  export type ConsultationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consultations.
     */
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyInput>
    /**
     * Filter which Consultations to update
     */
    where?: ConsultationWhereInput
    /**
     * Limit how many Consultations to update.
     */
    limit?: number
  }

  /**
   * Consultation updateManyAndReturn
   */
  export type ConsultationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * The data used to update Consultations.
     */
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyInput>
    /**
     * Filter which Consultations to update
     */
    where?: ConsultationWhereInput
    /**
     * Limit how many Consultations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consultation upsert
   */
  export type ConsultationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The filter to search for the Consultation to update in case it exists.
     */
    where: ConsultationWhereUniqueInput
    /**
     * In case the Consultation found by the `where` argument doesn't exist, create a new Consultation with this data.
     */
    create: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
    /**
     * In case the Consultation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
  }

  /**
   * Consultation delete
   */
  export type ConsultationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter which Consultation to delete.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation deleteMany
   */
  export type ConsultationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultations to delete
     */
    where?: ConsultationWhereInput
    /**
     * Limit how many Consultations to delete.
     */
    limit?: number
  }

  /**
   * Consultation.vitalSigns
   */
  export type Consultation$vitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    where?: VitalSignsWhereInput
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    cursor?: VitalSignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * Consultation.prescriptions
   */
  export type Consultation$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Consultation without action
   */
  export type ConsultationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    totalCost: number | null
    amountPaid: number | null
    discount: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    totalCost: number | null
    amountPaid: number | null
    discount: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: string | null
    prescriptionNo: string | null
    studentId: string | null
    physicianId: string | null
    consultationId: string | null
    diagnosis: string | null
    instructions: string | null
    status: $Enums.prescriptionStatus | null
    priority: $Enums.priority | null
    isPaid: boolean | null
    isDispensed: boolean | null
    dispensedBy: string | null
    dispensedAt: Date | null
    totalCost: number | null
    amountPaid: number | null
    discount: number | null
    pharmacyNotified: boolean | null
    notifiedAt: Date | null
    studentNotified: boolean | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    isDeleted: boolean | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: string | null
    prescriptionNo: string | null
    studentId: string | null
    physicianId: string | null
    consultationId: string | null
    diagnosis: string | null
    instructions: string | null
    status: $Enums.prescriptionStatus | null
    priority: $Enums.priority | null
    isPaid: boolean | null
    isDispensed: boolean | null
    dispensedBy: string | null
    dispensedAt: Date | null
    totalCost: number | null
    amountPaid: number | null
    discount: number | null
    pharmacyNotified: boolean | null
    notifiedAt: Date | null
    studentNotified: boolean | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    isDeleted: boolean | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    prescriptionNo: number
    studentId: number
    physicianId: number
    consultationId: number
    diagnosis: number
    instructions: number
    status: number
    priority: number
    isPaid: number
    isDispensed: number
    dispensedBy: number
    dispensedAt: number
    totalCost: number
    amountPaid: number
    discount: number
    pharmacyNotified: number
    notifiedAt: number
    studentNotified: number
    validUntil: number
    createdAt: number
    updatedAt: number
    sync: number
    isDeleted: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    totalCost?: true
    amountPaid?: true
    discount?: true
  }

  export type PrescriptionSumAggregateInputType = {
    totalCost?: true
    amountPaid?: true
    discount?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    prescriptionNo?: true
    studentId?: true
    physicianId?: true
    consultationId?: true
    diagnosis?: true
    instructions?: true
    status?: true
    priority?: true
    isPaid?: true
    isDispensed?: true
    dispensedBy?: true
    dispensedAt?: true
    totalCost?: true
    amountPaid?: true
    discount?: true
    pharmacyNotified?: true
    notifiedAt?: true
    studentNotified?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    prescriptionNo?: true
    studentId?: true
    physicianId?: true
    consultationId?: true
    diagnosis?: true
    instructions?: true
    status?: true
    priority?: true
    isPaid?: true
    isDispensed?: true
    dispensedBy?: true
    dispensedAt?: true
    totalCost?: true
    amountPaid?: true
    discount?: true
    pharmacyNotified?: true
    notifiedAt?: true
    studentNotified?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    prescriptionNo?: true
    studentId?: true
    physicianId?: true
    consultationId?: true
    diagnosis?: true
    instructions?: true
    status?: true
    priority?: true
    isPaid?: true
    isDispensed?: true
    dispensedBy?: true
    dispensedAt?: true
    totalCost?: true
    amountPaid?: true
    discount?: true
    pharmacyNotified?: true
    notifiedAt?: true
    studentNotified?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    isDeleted?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: string
    prescriptionNo: string
    studentId: string
    physicianId: string
    consultationId: string
    diagnosis: string
    instructions: string | null
    status: $Enums.prescriptionStatus
    priority: $Enums.priority
    isPaid: boolean
    isDispensed: boolean
    dispensedBy: string | null
    dispensedAt: Date | null
    totalCost: number
    amountPaid: number
    discount: number
    pharmacyNotified: boolean
    notifiedAt: Date | null
    studentNotified: boolean
    validUntil: Date | null
    createdAt: Date
    updatedAt: Date
    sync: boolean
    isDeleted: boolean
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    consultationId?: boolean
    diagnosis?: boolean
    instructions?: boolean
    status?: boolean
    priority?: boolean
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: boolean
    dispensedAt?: boolean
    totalCost?: boolean
    amountPaid?: boolean
    discount?: boolean
    pharmacyNotified?: boolean
    notifiedAt?: boolean
    studentNotified?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
    prescriptionItems?: boolean | Prescription$prescriptionItemsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    consultationId?: boolean
    diagnosis?: boolean
    instructions?: boolean
    status?: boolean
    priority?: boolean
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: boolean
    dispensedAt?: boolean
    totalCost?: boolean
    amountPaid?: boolean
    discount?: boolean
    pharmacyNotified?: boolean
    notifiedAt?: boolean
    studentNotified?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    consultationId?: boolean
    diagnosis?: boolean
    instructions?: boolean
    status?: boolean
    priority?: boolean
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: boolean
    dispensedAt?: boolean
    totalCost?: boolean
    amountPaid?: boolean
    discount?: boolean
    pharmacyNotified?: boolean
    notifiedAt?: boolean
    studentNotified?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    prescriptionNo?: boolean
    studentId?: boolean
    physicianId?: boolean
    consultationId?: boolean
    diagnosis?: boolean
    instructions?: boolean
    status?: boolean
    priority?: boolean
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: boolean
    dispensedAt?: boolean
    totalCost?: boolean
    amountPaid?: boolean
    discount?: boolean
    pharmacyNotified?: boolean
    notifiedAt?: boolean
    studentNotified?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    isDeleted?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionNo" | "studentId" | "physicianId" | "consultationId" | "diagnosis" | "instructions" | "status" | "priority" | "isPaid" | "isDispensed" | "dispensedBy" | "dispensedAt" | "totalCost" | "amountPaid" | "discount" | "pharmacyNotified" | "notifiedAt" | "studentNotified" | "validUntil" | "createdAt" | "updatedAt" | "sync" | "isDeleted", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
    prescriptionItems?: boolean | Prescription$prescriptionItemsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    physician?: boolean | PhysicianDefaultArgs<ExtArgs>
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      physician: Prisma.$PhysicianPayload<ExtArgs>
      consultation: Prisma.$ConsultationPayload<ExtArgs>
      prescriptionItems: Prisma.$PrescriptionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prescriptionNo: string
      studentId: string
      physicianId: string
      consultationId: string
      diagnosis: string
      instructions: string | null
      status: $Enums.prescriptionStatus
      priority: $Enums.priority
      isPaid: boolean
      isDispensed: boolean
      dispensedBy: string | null
      dispensedAt: Date | null
      totalCost: number
      amountPaid: number
      discount: number
      pharmacyNotified: boolean
      notifiedAt: Date | null
      studentNotified: boolean
      validUntil: Date | null
      createdAt: Date
      updatedAt: Date
      sync: boolean
      isDeleted: boolean
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    physician<T extends PhysicianDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhysicianDefaultArgs<ExtArgs>>): Prisma__PhysicianClient<$Result.GetResult<Prisma.$PhysicianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    consultation<T extends ConsultationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationDefaultArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prescriptionItems<T extends Prescription$prescriptionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$prescriptionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'String'>
    readonly prescriptionNo: FieldRef<"Prescription", 'String'>
    readonly studentId: FieldRef<"Prescription", 'String'>
    readonly physicianId: FieldRef<"Prescription", 'String'>
    readonly consultationId: FieldRef<"Prescription", 'String'>
    readonly diagnosis: FieldRef<"Prescription", 'String'>
    readonly instructions: FieldRef<"Prescription", 'String'>
    readonly status: FieldRef<"Prescription", 'prescriptionStatus'>
    readonly priority: FieldRef<"Prescription", 'priority'>
    readonly isPaid: FieldRef<"Prescription", 'Boolean'>
    readonly isDispensed: FieldRef<"Prescription", 'Boolean'>
    readonly dispensedBy: FieldRef<"Prescription", 'String'>
    readonly dispensedAt: FieldRef<"Prescription", 'DateTime'>
    readonly totalCost: FieldRef<"Prescription", 'Float'>
    readonly amountPaid: FieldRef<"Prescription", 'Float'>
    readonly discount: FieldRef<"Prescription", 'Float'>
    readonly pharmacyNotified: FieldRef<"Prescription", 'Boolean'>
    readonly notifiedAt: FieldRef<"Prescription", 'DateTime'>
    readonly studentNotified: FieldRef<"Prescription", 'Boolean'>
    readonly validUntil: FieldRef<"Prescription", 'DateTime'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
    readonly updatedAt: FieldRef<"Prescription", 'DateTime'>
    readonly sync: FieldRef<"Prescription", 'Boolean'>
    readonly isDeleted: FieldRef<"Prescription", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to delete.
     */
    limit?: number
  }

  /**
   * Prescription.prescriptionItems
   */
  export type Prescription$prescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionItem
   */

  export type AggregatePrescriptionItem = {
    _count: PrescriptionItemCountAggregateOutputType | null
    _avg: PrescriptionItemAvgAggregateOutputType | null
    _sum: PrescriptionItemSumAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  export type PrescriptionItemAvgAggregateOutputType = {
    quantityPrescribed: number | null
    quantityDispensed: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type PrescriptionItemSumAggregateOutputType = {
    quantityPrescribed: number | null
    quantityDispensed: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type PrescriptionItemMinAggregateOutputType = {
    id: string | null
    prescriptionId: string | null
    productId: string | null
    drugName: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    route: string | null
    instructions: string | null
    quantityPrescribed: number | null
    quantityDispensed: number | null
    unitPrice: number | null
    totalPrice: number | null
    isDispensed: boolean | null
    dispensedAt: Date | null
    dispensedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type PrescriptionItemMaxAggregateOutputType = {
    id: string | null
    prescriptionId: string | null
    productId: string | null
    drugName: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    route: string | null
    instructions: string | null
    quantityPrescribed: number | null
    quantityDispensed: number | null
    unitPrice: number | null
    totalPrice: number | null
    isDispensed: boolean | null
    dispensedAt: Date | null
    dispensedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type PrescriptionItemCountAggregateOutputType = {
    id: number
    prescriptionId: number
    productId: number
    drugName: number
    dosage: number
    frequency: number
    duration: number
    route: number
    instructions: number
    quantityPrescribed: number
    quantityDispensed: number
    unitPrice: number
    totalPrice: number
    isDispensed: number
    dispensedAt: number
    dispensedBy: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type PrescriptionItemAvgAggregateInputType = {
    quantityPrescribed?: true
    quantityDispensed?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PrescriptionItemSumAggregateInputType = {
    quantityPrescribed?: true
    quantityDispensed?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PrescriptionItemMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    productId?: true
    drugName?: true
    dosage?: true
    frequency?: true
    duration?: true
    route?: true
    instructions?: true
    quantityPrescribed?: true
    quantityDispensed?: true
    unitPrice?: true
    totalPrice?: true
    isDispensed?: true
    dispensedAt?: true
    dispensedBy?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type PrescriptionItemMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    productId?: true
    drugName?: true
    dosage?: true
    frequency?: true
    duration?: true
    route?: true
    instructions?: true
    quantityPrescribed?: true
    quantityDispensed?: true
    unitPrice?: true
    totalPrice?: true
    isDispensed?: true
    dispensedAt?: true
    dispensedBy?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type PrescriptionItemCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    productId?: true
    drugName?: true
    dosage?: true
    frequency?: true
    duration?: true
    route?: true
    instructions?: true
    quantityPrescribed?: true
    quantityDispensed?: true
    unitPrice?: true
    totalPrice?: true
    isDispensed?: true
    dispensedAt?: true
    dispensedBy?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type PrescriptionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItem to aggregate.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionItems
    **/
    _count?: true | PrescriptionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type GetPrescriptionItemAggregateType<T extends PrescriptionItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionItem[P]>
      : GetScalarType<T[P], AggregatePrescriptionItem[P]>
  }




  export type PrescriptionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithAggregationInput | PrescriptionItemOrderByWithAggregationInput[]
    by: PrescriptionItemScalarFieldEnum[] | PrescriptionItemScalarFieldEnum
    having?: PrescriptionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionItemCountAggregateInputType | true
    _avg?: PrescriptionItemAvgAggregateInputType
    _sum?: PrescriptionItemSumAggregateInputType
    _min?: PrescriptionItemMinAggregateInputType
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type PrescriptionItemGroupByOutputType = {
    id: string
    prescriptionId: string
    productId: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed: number
    unitPrice: number
    totalPrice: number
    isDispensed: boolean
    dispensedAt: Date | null
    dispensedBy: string | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: PrescriptionItemCountAggregateOutputType | null
    _avg: PrescriptionItemAvgAggregateOutputType | null
    _sum: PrescriptionItemSumAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  type GetPrescriptionItemGroupByPayload<T extends PrescriptionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    productId?: boolean
    drugName?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    route?: boolean
    instructions?: boolean
    quantityPrescribed?: boolean
    quantityDispensed?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isDispensed?: boolean
    dispensedAt?: boolean
    dispensedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    productId?: boolean
    drugName?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    route?: boolean
    instructions?: boolean
    quantityPrescribed?: boolean
    quantityDispensed?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isDispensed?: boolean
    dispensedAt?: boolean
    dispensedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    productId?: boolean
    drugName?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    route?: boolean
    instructions?: boolean
    quantityPrescribed?: boolean
    quantityDispensed?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isDispensed?: boolean
    dispensedAt?: boolean
    dispensedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    productId?: boolean
    drugName?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    route?: boolean
    instructions?: boolean
    quantityPrescribed?: boolean
    quantityDispensed?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    isDispensed?: boolean
    dispensedAt?: boolean
    dispensedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type PrescriptionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionId" | "productId" | "drugName" | "dosage" | "frequency" | "duration" | "route" | "instructions" | "quantityPrescribed" | "quantityDispensed" | "unitPrice" | "totalPrice" | "isDispensed" | "dispensedAt" | "dispensedBy" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["prescriptionItem"]>
  export type PrescriptionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PrescriptionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PrescriptionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PrescriptionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionItem"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prescriptionId: string
      productId: string
      drugName: string
      dosage: string
      frequency: string
      duration: string
      route: string | null
      instructions: string
      quantityPrescribed: number
      quantityDispensed: number
      unitPrice: number
      totalPrice: number
      isDispensed: boolean
      dispensedAt: Date | null
      dispensedBy: string | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["prescriptionItem"]>
    composites: {}
  }

  type PrescriptionItemGetPayload<S extends boolean | null | undefined | PrescriptionItemDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionItemPayload, S>

  type PrescriptionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionItemCountAggregateInputType | true
    }

  export interface PrescriptionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionItem'], meta: { name: 'PrescriptionItem' } }
    /**
     * Find zero or one PrescriptionItem that matches the filter.
     * @param {PrescriptionItemFindUniqueArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionItemFindUniqueArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrescriptionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionItemFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionItemFindFirstArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrescriptionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany()
     * 
     * // Get first 10 PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionItemFindManyArgs>(args?: SelectSubset<T, PrescriptionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrescriptionItem.
     * @param {PrescriptionItemCreateArgs} args - Arguments to create a PrescriptionItem.
     * @example
     * // Create one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.create({
     *   data: {
     *     // ... data to create a PrescriptionItem
     *   }
     * })
     * 
     */
    create<T extends PrescriptionItemCreateArgs>(args: SelectSubset<T, PrescriptionItemCreateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrescriptionItems.
     * @param {PrescriptionItemCreateManyArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionItemCreateManyArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionItems and returns the data saved in the database.
     * @param {PrescriptionItemCreateManyAndReturnArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionItems and only return the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrescriptionItem.
     * @param {PrescriptionItemDeleteArgs} args - Arguments to delete one PrescriptionItem.
     * @example
     * // Delete one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionItem
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionItemDeleteArgs>(args: SelectSubset<T, PrescriptionItemDeleteArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrescriptionItem.
     * @param {PrescriptionItemUpdateArgs} args - Arguments to update one PrescriptionItem.
     * @example
     * // Update one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionItemUpdateArgs>(args: SelectSubset<T, PrescriptionItemUpdateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrescriptionItems.
     * @param {PrescriptionItemDeleteManyArgs} args - Arguments to filter PrescriptionItems to delete.
     * @example
     * // Delete a few PrescriptionItems
     * const { count } = await prisma.prescriptionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionItemDeleteManyArgs>(args?: SelectSubset<T, PrescriptionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionItemUpdateManyArgs>(args: SelectSubset<T, PrescriptionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionItems and returns the data updated in the database.
     * @param {PrescriptionItemUpdateManyAndReturnArgs} args - Arguments to update many PrescriptionItems.
     * @example
     * // Update many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrescriptionItems and only return the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrescriptionItem.
     * @param {PrescriptionItemUpsertArgs} args - Arguments to update or create a PrescriptionItem.
     * @example
     * // Update or create a PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.upsert({
     *   create: {
     *     // ... data to create a PrescriptionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionItem we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionItemUpsertArgs>(args: SelectSubset<T, PrescriptionItemUpsertArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemCountArgs} args - Arguments to filter PrescriptionItems to count.
     * @example
     * // Count the number of PrescriptionItems
     * const count = await prisma.prescriptionItem.count({
     *   where: {
     *     // ... the filter for the PrescriptionItems we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionItemCountArgs>(
      args?: Subset<T, PrescriptionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionItemAggregateArgs>(args: Subset<T, PrescriptionItemAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionItemAggregateType<T>>

    /**
     * Group by PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionItemGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionItem model
   */
  readonly fields: PrescriptionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionItem model
   */
  interface PrescriptionItemFieldRefs {
    readonly id: FieldRef<"PrescriptionItem", 'String'>
    readonly prescriptionId: FieldRef<"PrescriptionItem", 'String'>
    readonly productId: FieldRef<"PrescriptionItem", 'String'>
    readonly drugName: FieldRef<"PrescriptionItem", 'String'>
    readonly dosage: FieldRef<"PrescriptionItem", 'String'>
    readonly frequency: FieldRef<"PrescriptionItem", 'String'>
    readonly duration: FieldRef<"PrescriptionItem", 'String'>
    readonly route: FieldRef<"PrescriptionItem", 'String'>
    readonly instructions: FieldRef<"PrescriptionItem", 'String'>
    readonly quantityPrescribed: FieldRef<"PrescriptionItem", 'Int'>
    readonly quantityDispensed: FieldRef<"PrescriptionItem", 'Int'>
    readonly unitPrice: FieldRef<"PrescriptionItem", 'Float'>
    readonly totalPrice: FieldRef<"PrescriptionItem", 'Float'>
    readonly isDispensed: FieldRef<"PrescriptionItem", 'Boolean'>
    readonly dispensedAt: FieldRef<"PrescriptionItem", 'DateTime'>
    readonly dispensedBy: FieldRef<"PrescriptionItem", 'String'>
    readonly createdAt: FieldRef<"PrescriptionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PrescriptionItem", 'DateTime'>
    readonly isDeleted: FieldRef<"PrescriptionItem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionItem findUnique
   */
  export type PrescriptionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findUniqueOrThrow
   */
  export type PrescriptionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findFirst
   */
  export type PrescriptionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findFirstOrThrow
   */
  export type PrescriptionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findMany
   */
  export type PrescriptionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItems to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem create
   */
  export type PrescriptionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionItem.
     */
    data: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
  }

  /**
   * PrescriptionItem createMany
   */
  export type PrescriptionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
  }

  /**
   * PrescriptionItem createManyAndReturn
   */
  export type PrescriptionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionItem update
   */
  export type PrescriptionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionItem.
     */
    data: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionItem to update.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem updateMany
   */
  export type PrescriptionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionItems.
     */
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionItems to update
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to update.
     */
    limit?: number
  }

  /**
   * PrescriptionItem updateManyAndReturn
   */
  export type PrescriptionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * The data used to update PrescriptionItems.
     */
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionItems to update
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionItem upsert
   */
  export type PrescriptionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionItem to update in case it exists.
     */
    where: PrescriptionItemWhereUniqueInput
    /**
     * In case the PrescriptionItem found by the `where` argument doesn't exist, create a new PrescriptionItem with this data.
     */
    create: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
    /**
     * In case the PrescriptionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
  }

  /**
   * PrescriptionItem delete
   */
  export type PrescriptionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionItem to delete.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem deleteMany
   */
  export type PrescriptionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItems to delete
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to delete.
     */
    limit?: number
  }

  /**
   * PrescriptionItem without action
   */
  export type PrescriptionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
  }


  /**
   * Model DrugDispensal
   */

  export type AggregateDrugDispensal = {
    _count: DrugDispensalCountAggregateOutputType | null
    _avg: DrugDispensalAvgAggregateOutputType | null
    _sum: DrugDispensalSumAggregateOutputType | null
    _min: DrugDispensalMinAggregateOutputType | null
    _max: DrugDispensalMaxAggregateOutputType | null
  }

  export type DrugDispensalAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type DrugDispensalSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type DrugDispensalMinAggregateOutputType = {
    id: string | null
    dispensalNo: string | null
    prescriptionId: string | null
    prescriptionNo: string | null
    studentId: string | null
    dispensedBy: string | null
    dispensedItems: string | null
    totalAmount: number | null
    notes: string | null
    createdAt: Date | null
    isDeleted: boolean | null
  }

  export type DrugDispensalMaxAggregateOutputType = {
    id: string | null
    dispensalNo: string | null
    prescriptionId: string | null
    prescriptionNo: string | null
    studentId: string | null
    dispensedBy: string | null
    dispensedItems: string | null
    totalAmount: number | null
    notes: string | null
    createdAt: Date | null
    isDeleted: boolean | null
  }

  export type DrugDispensalCountAggregateOutputType = {
    id: number
    dispensalNo: number
    prescriptionId: number
    prescriptionNo: number
    studentId: number
    dispensedBy: number
    dispensedItems: number
    totalAmount: number
    notes: number
    createdAt: number
    isDeleted: number
    _all: number
  }


  export type DrugDispensalAvgAggregateInputType = {
    totalAmount?: true
  }

  export type DrugDispensalSumAggregateInputType = {
    totalAmount?: true
  }

  export type DrugDispensalMinAggregateInputType = {
    id?: true
    dispensalNo?: true
    prescriptionId?: true
    prescriptionNo?: true
    studentId?: true
    dispensedBy?: true
    dispensedItems?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    isDeleted?: true
  }

  export type DrugDispensalMaxAggregateInputType = {
    id?: true
    dispensalNo?: true
    prescriptionId?: true
    prescriptionNo?: true
    studentId?: true
    dispensedBy?: true
    dispensedItems?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    isDeleted?: true
  }

  export type DrugDispensalCountAggregateInputType = {
    id?: true
    dispensalNo?: true
    prescriptionId?: true
    prescriptionNo?: true
    studentId?: true
    dispensedBy?: true
    dispensedItems?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    isDeleted?: true
    _all?: true
  }

  export type DrugDispensalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrugDispensal to aggregate.
     */
    where?: DrugDispensalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugDispensals to fetch.
     */
    orderBy?: DrugDispensalOrderByWithRelationInput | DrugDispensalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrugDispensalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugDispensals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugDispensals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DrugDispensals
    **/
    _count?: true | DrugDispensalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrugDispensalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrugDispensalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrugDispensalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrugDispensalMaxAggregateInputType
  }

  export type GetDrugDispensalAggregateType<T extends DrugDispensalAggregateArgs> = {
        [P in keyof T & keyof AggregateDrugDispensal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrugDispensal[P]>
      : GetScalarType<T[P], AggregateDrugDispensal[P]>
  }




  export type DrugDispensalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrugDispensalWhereInput
    orderBy?: DrugDispensalOrderByWithAggregationInput | DrugDispensalOrderByWithAggregationInput[]
    by: DrugDispensalScalarFieldEnum[] | DrugDispensalScalarFieldEnum
    having?: DrugDispensalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrugDispensalCountAggregateInputType | true
    _avg?: DrugDispensalAvgAggregateInputType
    _sum?: DrugDispensalSumAggregateInputType
    _min?: DrugDispensalMinAggregateInputType
    _max?: DrugDispensalMaxAggregateInputType
  }

  export type DrugDispensalGroupByOutputType = {
    id: string
    dispensalNo: string
    prescriptionId: string
    prescriptionNo: string
    studentId: string
    dispensedBy: string
    dispensedItems: string
    totalAmount: number
    notes: string | null
    createdAt: Date
    isDeleted: boolean
    _count: DrugDispensalCountAggregateOutputType | null
    _avg: DrugDispensalAvgAggregateOutputType | null
    _sum: DrugDispensalSumAggregateOutputType | null
    _min: DrugDispensalMinAggregateOutputType | null
    _max: DrugDispensalMaxAggregateOutputType | null
  }

  type GetDrugDispensalGroupByPayload<T extends DrugDispensalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrugDispensalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrugDispensalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrugDispensalGroupByOutputType[P]>
            : GetScalarType<T[P], DrugDispensalGroupByOutputType[P]>
        }
      >
    >


  export type DrugDispensalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispensalNo?: boolean
    prescriptionId?: boolean
    prescriptionNo?: boolean
    studentId?: boolean
    dispensedBy?: boolean
    dispensedItems?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drugDispensal"]>

  export type DrugDispensalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispensalNo?: boolean
    prescriptionId?: boolean
    prescriptionNo?: boolean
    studentId?: boolean
    dispensedBy?: boolean
    dispensedItems?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drugDispensal"]>

  export type DrugDispensalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dispensalNo?: boolean
    prescriptionId?: boolean
    prescriptionNo?: boolean
    studentId?: boolean
    dispensedBy?: boolean
    dispensedItems?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drugDispensal"]>

  export type DrugDispensalSelectScalar = {
    id?: boolean
    dispensalNo?: boolean
    prescriptionId?: boolean
    prescriptionNo?: boolean
    studentId?: boolean
    dispensedBy?: boolean
    dispensedItems?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    isDeleted?: boolean
  }

  export type DrugDispensalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dispensalNo" | "prescriptionId" | "prescriptionNo" | "studentId" | "dispensedBy" | "dispensedItems" | "totalAmount" | "notes" | "createdAt" | "isDeleted", ExtArgs["result"]["drugDispensal"]>
  export type DrugDispensalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type DrugDispensalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type DrugDispensalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $DrugDispensalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DrugDispensal"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dispensalNo: string
      prescriptionId: string
      prescriptionNo: string
      studentId: string
      dispensedBy: string
      dispensedItems: string
      totalAmount: number
      notes: string | null
      createdAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["drugDispensal"]>
    composites: {}
  }

  type DrugDispensalGetPayload<S extends boolean | null | undefined | DrugDispensalDefaultArgs> = $Result.GetResult<Prisma.$DrugDispensalPayload, S>

  type DrugDispensalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DrugDispensalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DrugDispensalCountAggregateInputType | true
    }

  export interface DrugDispensalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DrugDispensal'], meta: { name: 'DrugDispensal' } }
    /**
     * Find zero or one DrugDispensal that matches the filter.
     * @param {DrugDispensalFindUniqueArgs} args - Arguments to find a DrugDispensal
     * @example
     * // Get one DrugDispensal
     * const drugDispensal = await prisma.drugDispensal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DrugDispensalFindUniqueArgs>(args: SelectSubset<T, DrugDispensalFindUniqueArgs<ExtArgs>>): Prisma__DrugDispensalClient<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DrugDispensal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DrugDispensalFindUniqueOrThrowArgs} args - Arguments to find a DrugDispensal
     * @example
     * // Get one DrugDispensal
     * const drugDispensal = await prisma.drugDispensal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DrugDispensalFindUniqueOrThrowArgs>(args: SelectSubset<T, DrugDispensalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DrugDispensalClient<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DrugDispensal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugDispensalFindFirstArgs} args - Arguments to find a DrugDispensal
     * @example
     * // Get one DrugDispensal
     * const drugDispensal = await prisma.drugDispensal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DrugDispensalFindFirstArgs>(args?: SelectSubset<T, DrugDispensalFindFirstArgs<ExtArgs>>): Prisma__DrugDispensalClient<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DrugDispensal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugDispensalFindFirstOrThrowArgs} args - Arguments to find a DrugDispensal
     * @example
     * // Get one DrugDispensal
     * const drugDispensal = await prisma.drugDispensal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DrugDispensalFindFirstOrThrowArgs>(args?: SelectSubset<T, DrugDispensalFindFirstOrThrowArgs<ExtArgs>>): Prisma__DrugDispensalClient<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DrugDispensals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugDispensalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DrugDispensals
     * const drugDispensals = await prisma.drugDispensal.findMany()
     * 
     * // Get first 10 DrugDispensals
     * const drugDispensals = await prisma.drugDispensal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drugDispensalWithIdOnly = await prisma.drugDispensal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DrugDispensalFindManyArgs>(args?: SelectSubset<T, DrugDispensalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DrugDispensal.
     * @param {DrugDispensalCreateArgs} args - Arguments to create a DrugDispensal.
     * @example
     * // Create one DrugDispensal
     * const DrugDispensal = await prisma.drugDispensal.create({
     *   data: {
     *     // ... data to create a DrugDispensal
     *   }
     * })
     * 
     */
    create<T extends DrugDispensalCreateArgs>(args: SelectSubset<T, DrugDispensalCreateArgs<ExtArgs>>): Prisma__DrugDispensalClient<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DrugDispensals.
     * @param {DrugDispensalCreateManyArgs} args - Arguments to create many DrugDispensals.
     * @example
     * // Create many DrugDispensals
     * const drugDispensal = await prisma.drugDispensal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DrugDispensalCreateManyArgs>(args?: SelectSubset<T, DrugDispensalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DrugDispensals and returns the data saved in the database.
     * @param {DrugDispensalCreateManyAndReturnArgs} args - Arguments to create many DrugDispensals.
     * @example
     * // Create many DrugDispensals
     * const drugDispensal = await prisma.drugDispensal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DrugDispensals and only return the `id`
     * const drugDispensalWithIdOnly = await prisma.drugDispensal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DrugDispensalCreateManyAndReturnArgs>(args?: SelectSubset<T, DrugDispensalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DrugDispensal.
     * @param {DrugDispensalDeleteArgs} args - Arguments to delete one DrugDispensal.
     * @example
     * // Delete one DrugDispensal
     * const DrugDispensal = await prisma.drugDispensal.delete({
     *   where: {
     *     // ... filter to delete one DrugDispensal
     *   }
     * })
     * 
     */
    delete<T extends DrugDispensalDeleteArgs>(args: SelectSubset<T, DrugDispensalDeleteArgs<ExtArgs>>): Prisma__DrugDispensalClient<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DrugDispensal.
     * @param {DrugDispensalUpdateArgs} args - Arguments to update one DrugDispensal.
     * @example
     * // Update one DrugDispensal
     * const drugDispensal = await prisma.drugDispensal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DrugDispensalUpdateArgs>(args: SelectSubset<T, DrugDispensalUpdateArgs<ExtArgs>>): Prisma__DrugDispensalClient<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DrugDispensals.
     * @param {DrugDispensalDeleteManyArgs} args - Arguments to filter DrugDispensals to delete.
     * @example
     * // Delete a few DrugDispensals
     * const { count } = await prisma.drugDispensal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DrugDispensalDeleteManyArgs>(args?: SelectSubset<T, DrugDispensalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrugDispensals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugDispensalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DrugDispensals
     * const drugDispensal = await prisma.drugDispensal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DrugDispensalUpdateManyArgs>(args: SelectSubset<T, DrugDispensalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrugDispensals and returns the data updated in the database.
     * @param {DrugDispensalUpdateManyAndReturnArgs} args - Arguments to update many DrugDispensals.
     * @example
     * // Update many DrugDispensals
     * const drugDispensal = await prisma.drugDispensal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DrugDispensals and only return the `id`
     * const drugDispensalWithIdOnly = await prisma.drugDispensal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DrugDispensalUpdateManyAndReturnArgs>(args: SelectSubset<T, DrugDispensalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DrugDispensal.
     * @param {DrugDispensalUpsertArgs} args - Arguments to update or create a DrugDispensal.
     * @example
     * // Update or create a DrugDispensal
     * const drugDispensal = await prisma.drugDispensal.upsert({
     *   create: {
     *     // ... data to create a DrugDispensal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DrugDispensal we want to update
     *   }
     * })
     */
    upsert<T extends DrugDispensalUpsertArgs>(args: SelectSubset<T, DrugDispensalUpsertArgs<ExtArgs>>): Prisma__DrugDispensalClient<$Result.GetResult<Prisma.$DrugDispensalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DrugDispensals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugDispensalCountArgs} args - Arguments to filter DrugDispensals to count.
     * @example
     * // Count the number of DrugDispensals
     * const count = await prisma.drugDispensal.count({
     *   where: {
     *     // ... the filter for the DrugDispensals we want to count
     *   }
     * })
    **/
    count<T extends DrugDispensalCountArgs>(
      args?: Subset<T, DrugDispensalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrugDispensalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DrugDispensal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugDispensalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrugDispensalAggregateArgs>(args: Subset<T, DrugDispensalAggregateArgs>): Prisma.PrismaPromise<GetDrugDispensalAggregateType<T>>

    /**
     * Group by DrugDispensal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugDispensalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrugDispensalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrugDispensalGroupByArgs['orderBy'] }
        : { orderBy?: DrugDispensalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrugDispensalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrugDispensalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DrugDispensal model
   */
  readonly fields: DrugDispensalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DrugDispensal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DrugDispensalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DrugDispensal model
   */
  interface DrugDispensalFieldRefs {
    readonly id: FieldRef<"DrugDispensal", 'String'>
    readonly dispensalNo: FieldRef<"DrugDispensal", 'String'>
    readonly prescriptionId: FieldRef<"DrugDispensal", 'String'>
    readonly prescriptionNo: FieldRef<"DrugDispensal", 'String'>
    readonly studentId: FieldRef<"DrugDispensal", 'String'>
    readonly dispensedBy: FieldRef<"DrugDispensal", 'String'>
    readonly dispensedItems: FieldRef<"DrugDispensal", 'String'>
    readonly totalAmount: FieldRef<"DrugDispensal", 'Float'>
    readonly notes: FieldRef<"DrugDispensal", 'String'>
    readonly createdAt: FieldRef<"DrugDispensal", 'DateTime'>
    readonly isDeleted: FieldRef<"DrugDispensal", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DrugDispensal findUnique
   */
  export type DrugDispensalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * Filter, which DrugDispensal to fetch.
     */
    where: DrugDispensalWhereUniqueInput
  }

  /**
   * DrugDispensal findUniqueOrThrow
   */
  export type DrugDispensalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * Filter, which DrugDispensal to fetch.
     */
    where: DrugDispensalWhereUniqueInput
  }

  /**
   * DrugDispensal findFirst
   */
  export type DrugDispensalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * Filter, which DrugDispensal to fetch.
     */
    where?: DrugDispensalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugDispensals to fetch.
     */
    orderBy?: DrugDispensalOrderByWithRelationInput | DrugDispensalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrugDispensals.
     */
    cursor?: DrugDispensalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugDispensals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugDispensals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrugDispensals.
     */
    distinct?: DrugDispensalScalarFieldEnum | DrugDispensalScalarFieldEnum[]
  }

  /**
   * DrugDispensal findFirstOrThrow
   */
  export type DrugDispensalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * Filter, which DrugDispensal to fetch.
     */
    where?: DrugDispensalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugDispensals to fetch.
     */
    orderBy?: DrugDispensalOrderByWithRelationInput | DrugDispensalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrugDispensals.
     */
    cursor?: DrugDispensalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugDispensals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugDispensals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrugDispensals.
     */
    distinct?: DrugDispensalScalarFieldEnum | DrugDispensalScalarFieldEnum[]
  }

  /**
   * DrugDispensal findMany
   */
  export type DrugDispensalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * Filter, which DrugDispensals to fetch.
     */
    where?: DrugDispensalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugDispensals to fetch.
     */
    orderBy?: DrugDispensalOrderByWithRelationInput | DrugDispensalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DrugDispensals.
     */
    cursor?: DrugDispensalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugDispensals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugDispensals.
     */
    skip?: number
    distinct?: DrugDispensalScalarFieldEnum | DrugDispensalScalarFieldEnum[]
  }

  /**
   * DrugDispensal create
   */
  export type DrugDispensalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * The data needed to create a DrugDispensal.
     */
    data: XOR<DrugDispensalCreateInput, DrugDispensalUncheckedCreateInput>
  }

  /**
   * DrugDispensal createMany
   */
  export type DrugDispensalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DrugDispensals.
     */
    data: DrugDispensalCreateManyInput | DrugDispensalCreateManyInput[]
  }

  /**
   * DrugDispensal createManyAndReturn
   */
  export type DrugDispensalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * The data used to create many DrugDispensals.
     */
    data: DrugDispensalCreateManyInput | DrugDispensalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DrugDispensal update
   */
  export type DrugDispensalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * The data needed to update a DrugDispensal.
     */
    data: XOR<DrugDispensalUpdateInput, DrugDispensalUncheckedUpdateInput>
    /**
     * Choose, which DrugDispensal to update.
     */
    where: DrugDispensalWhereUniqueInput
  }

  /**
   * DrugDispensal updateMany
   */
  export type DrugDispensalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DrugDispensals.
     */
    data: XOR<DrugDispensalUpdateManyMutationInput, DrugDispensalUncheckedUpdateManyInput>
    /**
     * Filter which DrugDispensals to update
     */
    where?: DrugDispensalWhereInput
    /**
     * Limit how many DrugDispensals to update.
     */
    limit?: number
  }

  /**
   * DrugDispensal updateManyAndReturn
   */
  export type DrugDispensalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * The data used to update DrugDispensals.
     */
    data: XOR<DrugDispensalUpdateManyMutationInput, DrugDispensalUncheckedUpdateManyInput>
    /**
     * Filter which DrugDispensals to update
     */
    where?: DrugDispensalWhereInput
    /**
     * Limit how many DrugDispensals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DrugDispensal upsert
   */
  export type DrugDispensalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * The filter to search for the DrugDispensal to update in case it exists.
     */
    where: DrugDispensalWhereUniqueInput
    /**
     * In case the DrugDispensal found by the `where` argument doesn't exist, create a new DrugDispensal with this data.
     */
    create: XOR<DrugDispensalCreateInput, DrugDispensalUncheckedCreateInput>
    /**
     * In case the DrugDispensal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrugDispensalUpdateInput, DrugDispensalUncheckedUpdateInput>
  }

  /**
   * DrugDispensal delete
   */
  export type DrugDispensalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
    /**
     * Filter which DrugDispensal to delete.
     */
    where: DrugDispensalWhereUniqueInput
  }

  /**
   * DrugDispensal deleteMany
   */
  export type DrugDispensalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrugDispensals to delete
     */
    where?: DrugDispensalWhereInput
    /**
     * Limit how many DrugDispensals to delete.
     */
    limit?: number
  }

  /**
   * DrugDispensal without action
   */
  export type DrugDispensalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugDispensal
     */
    select?: DrugDispensalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugDispensal
     */
    omit?: DrugDispensalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugDispensalInclude<ExtArgs> | null
  }


  /**
   * Model MedicalRecord
   */

  export type AggregateMedicalRecord = {
    _count: MedicalRecordCountAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  export type MedicalRecordMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    recordType: string | null
    title: string | null
    description: string | null
    recordData: string | null
    attachments: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type MedicalRecordMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    recordType: string | null
    title: string | null
    description: string | null
    recordData: string | null
    attachments: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type MedicalRecordCountAggregateOutputType = {
    id: number
    studentId: number
    recordType: number
    title: number
    description: number
    recordData: number
    attachments: number
    createdBy: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type MedicalRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    recordType?: true
    title?: true
    description?: true
    recordData?: true
    attachments?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type MedicalRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    recordType?: true
    title?: true
    description?: true
    recordData?: true
    attachments?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type MedicalRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    recordType?: true
    title?: true
    description?: true
    recordData?: true
    attachments?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type MedicalRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecord to aggregate.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalRecords
    **/
    _count?: true | MedicalRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type GetMedicalRecordAggregateType<T extends MedicalRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalRecord[P]>
      : GetScalarType<T[P], AggregateMedicalRecord[P]>
  }




  export type MedicalRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithAggregationInput | MedicalRecordOrderByWithAggregationInput[]
    by: MedicalRecordScalarFieldEnum[] | MedicalRecordScalarFieldEnum
    having?: MedicalRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalRecordCountAggregateInputType | true
    _min?: MedicalRecordMinAggregateInputType
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type MedicalRecordGroupByOutputType = {
    id: string
    studentId: string
    recordType: string
    title: string
    description: string | null
    recordData: string | null
    attachments: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: MedicalRecordCountAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  type GetMedicalRecordGroupByPayload<T extends MedicalRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
        }
      >
    >


  export type MedicalRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    recordData?: boolean
    attachments?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    recordData?: boolean
    attachments?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    recordData?: boolean
    attachments?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    recordData?: boolean
    attachments?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type MedicalRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "recordType" | "title" | "description" | "recordData" | "attachments" | "createdBy" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["medicalRecord"]>
  export type MedicalRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type MedicalRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type MedicalRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $MedicalRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      recordType: string
      title: string
      description: string | null
      recordData: string | null
      attachments: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["medicalRecord"]>
    composites: {}
  }

  type MedicalRecordGetPayload<S extends boolean | null | undefined | MedicalRecordDefaultArgs> = $Result.GetResult<Prisma.$MedicalRecordPayload, S>

  type MedicalRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalRecordCountAggregateInputType | true
    }

  export interface MedicalRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalRecord'], meta: { name: 'MedicalRecord' } }
    /**
     * Find zero or one MedicalRecord that matches the filter.
     * @param {MedicalRecordFindUniqueArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalRecordFindUniqueArgs>(args: SelectSubset<T, MedicalRecordFindUniqueArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalRecordFindUniqueOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalRecordFindFirstArgs>(args?: SelectSubset<T, MedicalRecordFindFirstArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany()
     * 
     * // Get first 10 MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalRecordFindManyArgs>(args?: SelectSubset<T, MedicalRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalRecord.
     * @param {MedicalRecordCreateArgs} args - Arguments to create a MedicalRecord.
     * @example
     * // Create one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.create({
     *   data: {
     *     // ... data to create a MedicalRecord
     *   }
     * })
     * 
     */
    create<T extends MedicalRecordCreateArgs>(args: SelectSubset<T, MedicalRecordCreateArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalRecords.
     * @param {MedicalRecordCreateManyArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalRecordCreateManyArgs>(args?: SelectSubset<T, MedicalRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalRecords and returns the data saved in the database.
     * @param {MedicalRecordCreateManyAndReturnArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalRecords and only return the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalRecord.
     * @param {MedicalRecordDeleteArgs} args - Arguments to delete one MedicalRecord.
     * @example
     * // Delete one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.delete({
     *   where: {
     *     // ... filter to delete one MedicalRecord
     *   }
     * })
     * 
     */
    delete<T extends MedicalRecordDeleteArgs>(args: SelectSubset<T, MedicalRecordDeleteArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalRecord.
     * @param {MedicalRecordUpdateArgs} args - Arguments to update one MedicalRecord.
     * @example
     * // Update one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalRecordUpdateArgs>(args: SelectSubset<T, MedicalRecordUpdateArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalRecords.
     * @param {MedicalRecordDeleteManyArgs} args - Arguments to filter MedicalRecords to delete.
     * @example
     * // Delete a few MedicalRecords
     * const { count } = await prisma.medicalRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalRecordDeleteManyArgs>(args?: SelectSubset<T, MedicalRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalRecordUpdateManyArgs>(args: SelectSubset<T, MedicalRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords and returns the data updated in the database.
     * @param {MedicalRecordUpdateManyAndReturnArgs} args - Arguments to update many MedicalRecords.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalRecords and only return the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalRecord.
     * @param {MedicalRecordUpsertArgs} args - Arguments to update or create a MedicalRecord.
     * @example
     * // Update or create a MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.upsert({
     *   create: {
     *     // ... data to create a MedicalRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalRecord we want to update
     *   }
     * })
     */
    upsert<T extends MedicalRecordUpsertArgs>(args: SelectSubset<T, MedicalRecordUpsertArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordCountArgs} args - Arguments to filter MedicalRecords to count.
     * @example
     * // Count the number of MedicalRecords
     * const count = await prisma.medicalRecord.count({
     *   where: {
     *     // ... the filter for the MedicalRecords we want to count
     *   }
     * })
    **/
    count<T extends MedicalRecordCountArgs>(
      args?: Subset<T, MedicalRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalRecordAggregateArgs>(args: Subset<T, MedicalRecordAggregateArgs>): Prisma.PrismaPromise<GetMedicalRecordAggregateType<T>>

    /**
     * Group by MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalRecordGroupByArgs['orderBy'] }
        : { orderBy?: MedicalRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalRecord model
   */
  readonly fields: MedicalRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalRecord model
   */
  interface MedicalRecordFieldRefs {
    readonly id: FieldRef<"MedicalRecord", 'String'>
    readonly studentId: FieldRef<"MedicalRecord", 'String'>
    readonly recordType: FieldRef<"MedicalRecord", 'String'>
    readonly title: FieldRef<"MedicalRecord", 'String'>
    readonly description: FieldRef<"MedicalRecord", 'String'>
    readonly recordData: FieldRef<"MedicalRecord", 'String'>
    readonly attachments: FieldRef<"MedicalRecord", 'String'>
    readonly createdBy: FieldRef<"MedicalRecord", 'String'>
    readonly createdAt: FieldRef<"MedicalRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalRecord", 'DateTime'>
    readonly isDeleted: FieldRef<"MedicalRecord", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MedicalRecord findUnique
   */
  export type MedicalRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findUniqueOrThrow
   */
  export type MedicalRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findFirst
   */
  export type MedicalRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord findFirstOrThrow
   */
  export type MedicalRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord findMany
   */
  export type MedicalRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord create
   */
  export type MedicalRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalRecord.
     */
    data: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
  }

  /**
   * MedicalRecord createMany
   */
  export type MedicalRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordCreateManyInput | MedicalRecordCreateManyInput[]
  }

  /**
   * MedicalRecord createManyAndReturn
   */
  export type MedicalRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordCreateManyInput | MedicalRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecord update
   */
  export type MedicalRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalRecord.
     */
    data: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
    /**
     * Choose, which MedicalRecord to update.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord updateMany
   */
  export type MedicalRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
  }

  /**
   * MedicalRecord updateManyAndReturn
   */
  export type MedicalRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecord upsert
   */
  export type MedicalRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalRecord to update in case it exists.
     */
    where: MedicalRecordWhereUniqueInput
    /**
     * In case the MedicalRecord found by the `where` argument doesn't exist, create a new MedicalRecord with this data.
     */
    create: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
    /**
     * In case the MedicalRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
  }

  /**
   * MedicalRecord delete
   */
  export type MedicalRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter which MedicalRecord to delete.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord deleteMany
   */
  export type MedicalRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecords to delete
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to delete.
     */
    limit?: number
  }

  /**
   * MedicalRecord without action
   */
  export type MedicalRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    wholeSalePrice: number | null
    retailPrice: number | null
    cost: number | null
    quantity: number | null
    reorderLevel: number | null
    maxStockLevel: number | null
    taxRate: number | null
  }

  export type ProductSumAggregateOutputType = {
    wholeSalePrice: number | null
    retailPrice: number | null
    cost: number | null
    quantity: number | null
    reorderLevel: number | null
    maxStockLevel: number | null
    taxRate: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    barcode: string | null
    genericName: string | null
    brandName: string | null
    category: string | null
    manufacturer: string | null
    batchNumber: string | null
    expiryDate: Date | null
    wholeSalePrice: number | null
    retailPrice: number | null
    cost: number | null
    quantity: number | null
    reorderLevel: number | null
    maxStockLevel: number | null
    taxRate: number | null
    unit: $Enums.unit | null
    description: string | null
    dosageForm: string | null
    strength: string | null
    requiresPrescription: boolean | null
    controlledSubstance: boolean | null
    storageConditions: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    barcode: string | null
    genericName: string | null
    brandName: string | null
    category: string | null
    manufacturer: string | null
    batchNumber: string | null
    expiryDate: Date | null
    wholeSalePrice: number | null
    retailPrice: number | null
    cost: number | null
    quantity: number | null
    reorderLevel: number | null
    maxStockLevel: number | null
    taxRate: number | null
    unit: $Enums.unit | null
    description: string | null
    dosageForm: string | null
    strength: string | null
    requiresPrescription: boolean | null
    controlledSubstance: boolean | null
    storageConditions: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    barcode: number
    genericName: number
    brandName: number
    category: number
    manufacturer: number
    batchNumber: number
    expiryDate: number
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel: number
    maxStockLevel: number
    taxRate: number
    unit: number
    description: number
    dosageForm: number
    strength: number
    requiresPrescription: number
    controlledSubstance: number
    storageConditions: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    wholeSalePrice?: true
    retailPrice?: true
    cost?: true
    quantity?: true
    reorderLevel?: true
    maxStockLevel?: true
    taxRate?: true
  }

  export type ProductSumAggregateInputType = {
    wholeSalePrice?: true
    retailPrice?: true
    cost?: true
    quantity?: true
    reorderLevel?: true
    maxStockLevel?: true
    taxRate?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    genericName?: true
    brandName?: true
    category?: true
    manufacturer?: true
    batchNumber?: true
    expiryDate?: true
    wholeSalePrice?: true
    retailPrice?: true
    cost?: true
    quantity?: true
    reorderLevel?: true
    maxStockLevel?: true
    taxRate?: true
    unit?: true
    description?: true
    dosageForm?: true
    strength?: true
    requiresPrescription?: true
    controlledSubstance?: true
    storageConditions?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    genericName?: true
    brandName?: true
    category?: true
    manufacturer?: true
    batchNumber?: true
    expiryDate?: true
    wholeSalePrice?: true
    retailPrice?: true
    cost?: true
    quantity?: true
    reorderLevel?: true
    maxStockLevel?: true
    taxRate?: true
    unit?: true
    description?: true
    dosageForm?: true
    strength?: true
    requiresPrescription?: true
    controlledSubstance?: true
    storageConditions?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    genericName?: true
    brandName?: true
    category?: true
    manufacturer?: true
    batchNumber?: true
    expiryDate?: true
    wholeSalePrice?: true
    retailPrice?: true
    cost?: true
    quantity?: true
    reorderLevel?: true
    maxStockLevel?: true
    taxRate?: true
    unit?: true
    description?: true
    dosageForm?: true
    strength?: true
    requiresPrescription?: true
    controlledSubstance?: true
    storageConditions?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    barcode: string
    genericName: string | null
    brandName: string | null
    category: string | null
    manufacturer: string | null
    batchNumber: string | null
    expiryDate: Date | null
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel: number | null
    maxStockLevel: number | null
    taxRate: number
    unit: $Enums.unit
    description: string
    dosageForm: string | null
    strength: string | null
    requiresPrescription: boolean
    controlledSubstance: boolean
    storageConditions: string | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    genericName?: boolean
    brandName?: boolean
    category?: boolean
    manufacturer?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    wholeSalePrice?: boolean
    retailPrice?: boolean
    cost?: boolean
    quantity?: boolean
    reorderLevel?: boolean
    maxStockLevel?: boolean
    taxRate?: boolean
    unit?: boolean
    description?: boolean
    dosageForm?: boolean
    strength?: boolean
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    prescriptionItems?: boolean | Product$prescriptionItemsArgs<ExtArgs>
    purchaseItem?: boolean | Product$purchaseItemArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    genericName?: boolean
    brandName?: boolean
    category?: boolean
    manufacturer?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    wholeSalePrice?: boolean
    retailPrice?: boolean
    cost?: boolean
    quantity?: boolean
    reorderLevel?: boolean
    maxStockLevel?: boolean
    taxRate?: boolean
    unit?: boolean
    description?: boolean
    dosageForm?: boolean
    strength?: boolean
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    genericName?: boolean
    brandName?: boolean
    category?: boolean
    manufacturer?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    wholeSalePrice?: boolean
    retailPrice?: boolean
    cost?: boolean
    quantity?: boolean
    reorderLevel?: boolean
    maxStockLevel?: boolean
    taxRate?: boolean
    unit?: boolean
    description?: boolean
    dosageForm?: boolean
    strength?: boolean
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    barcode?: boolean
    genericName?: boolean
    brandName?: boolean
    category?: boolean
    manufacturer?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    wholeSalePrice?: boolean
    retailPrice?: boolean
    cost?: boolean
    quantity?: boolean
    reorderLevel?: boolean
    maxStockLevel?: boolean
    taxRate?: boolean
    unit?: boolean
    description?: boolean
    dosageForm?: boolean
    strength?: boolean
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "barcode" | "genericName" | "brandName" | "category" | "manufacturer" | "batchNumber" | "expiryDate" | "wholeSalePrice" | "retailPrice" | "cost" | "quantity" | "reorderLevel" | "maxStockLevel" | "taxRate" | "unit" | "description" | "dosageForm" | "strength" | "requiresPrescription" | "controlledSubstance" | "storageConditions" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptionItems?: boolean | Product$prescriptionItemsArgs<ExtArgs>
    purchaseItem?: boolean | Product$purchaseItemArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      prescriptionItems: Prisma.$PrescriptionItemPayload<ExtArgs>[]
      purchaseItem: Prisma.$PurchaseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      barcode: string
      genericName: string | null
      brandName: string | null
      category: string | null
      manufacturer: string | null
      batchNumber: string | null
      expiryDate: Date | null
      wholeSalePrice: number
      retailPrice: number
      cost: number
      quantity: number
      reorderLevel: number | null
      maxStockLevel: number | null
      taxRate: number
      unit: $Enums.unit
      description: string
      dosageForm: string | null
      strength: string | null
      requiresPrescription: boolean
      controlledSubstance: boolean
      storageConditions: string | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescriptionItems<T extends Product$prescriptionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$prescriptionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseItem<T extends Product$purchaseItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly genericName: FieldRef<"Product", 'String'>
    readonly brandName: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly manufacturer: FieldRef<"Product", 'String'>
    readonly batchNumber: FieldRef<"Product", 'String'>
    readonly expiryDate: FieldRef<"Product", 'DateTime'>
    readonly wholeSalePrice: FieldRef<"Product", 'Float'>
    readonly retailPrice: FieldRef<"Product", 'Float'>
    readonly cost: FieldRef<"Product", 'Float'>
    readonly quantity: FieldRef<"Product", 'Int'>
    readonly reorderLevel: FieldRef<"Product", 'Int'>
    readonly maxStockLevel: FieldRef<"Product", 'Int'>
    readonly taxRate: FieldRef<"Product", 'Int'>
    readonly unit: FieldRef<"Product", 'unit'>
    readonly description: FieldRef<"Product", 'String'>
    readonly dosageForm: FieldRef<"Product", 'String'>
    readonly strength: FieldRef<"Product", 'String'>
    readonly requiresPrescription: FieldRef<"Product", 'Boolean'>
    readonly controlledSubstance: FieldRef<"Product", 'Boolean'>
    readonly storageConditions: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly isDeleted: FieldRef<"Product", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.prescriptionItems
   */
  export type Product$prescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Product.purchaseItem
   */
  export type Product$purchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    taxRate: number | null
    subTotal: number | null
    amountPaid: number | null
    grandTotal: number | null
    paidAmount: number | null
    balance: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    taxRate: number | null
    subTotal: number | null
    amountPaid: number | null
    grandTotal: number | null
    paidAmount: number | null
    balance: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    taxRate: number | null
    subTotal: number | null
    notes: string | null
    amountPaid: number | null
    grandTotal: number | null
    paidAmount: number | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceNo: string | null
    supplierId: string | null
    isDeleted: boolean | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    taxRate: number | null
    subTotal: number | null
    notes: string | null
    amountPaid: number | null
    grandTotal: number | null
    paidAmount: number | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    referenceNo: string | null
    supplierId: string | null
    isDeleted: boolean | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    taxRate: number
    subTotal: number
    notes: number
    amountPaid: number
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt: number
    updatedAt: number
    referenceNo: number
    supplierId: number
    isDeleted: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    taxRate?: true
    subTotal?: true
    amountPaid?: true
    grandTotal?: true
    paidAmount?: true
    balance?: true
  }

  export type PurchaseSumAggregateInputType = {
    taxRate?: true
    subTotal?: true
    amountPaid?: true
    grandTotal?: true
    paidAmount?: true
    balance?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    taxRate?: true
    subTotal?: true
    notes?: true
    amountPaid?: true
    grandTotal?: true
    paidAmount?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    referenceNo?: true
    supplierId?: true
    isDeleted?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    taxRate?: true
    subTotal?: true
    notes?: true
    amountPaid?: true
    grandTotal?: true
    paidAmount?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    referenceNo?: true
    supplierId?: true
    isDeleted?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    taxRate?: true
    subTotal?: true
    notes?: true
    amountPaid?: true
    grandTotal?: true
    paidAmount?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    referenceNo?: true
    supplierId?: true
    isDeleted?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    taxRate: number
    subTotal: number
    notes: string | null
    amountPaid: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt: Date
    updatedAt: Date
    referenceNo: string
    supplierId: string | null
    isDeleted: boolean
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxRate?: boolean
    subTotal?: boolean
    notes?: boolean
    amountPaid?: boolean
    grandTotal?: boolean
    paidAmount?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceNo?: boolean
    supplierId?: boolean
    isDeleted?: boolean
    purchaseItem?: boolean | Purchase$purchaseItemArgs<ExtArgs>
    Supplier?: boolean | Purchase$SupplierArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxRate?: boolean
    subTotal?: boolean
    notes?: boolean
    amountPaid?: boolean
    grandTotal?: boolean
    paidAmount?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceNo?: boolean
    supplierId?: boolean
    isDeleted?: boolean
    Supplier?: boolean | Purchase$SupplierArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxRate?: boolean
    subTotal?: boolean
    notes?: boolean
    amountPaid?: boolean
    grandTotal?: boolean
    paidAmount?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceNo?: boolean
    supplierId?: boolean
    isDeleted?: boolean
    Supplier?: boolean | Purchase$SupplierArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    taxRate?: boolean
    subTotal?: boolean
    notes?: boolean
    amountPaid?: boolean
    grandTotal?: boolean
    paidAmount?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referenceNo?: boolean
    supplierId?: boolean
    isDeleted?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taxRate" | "subTotal" | "notes" | "amountPaid" | "grandTotal" | "paidAmount" | "balance" | "createdAt" | "updatedAt" | "referenceNo" | "supplierId" | "isDeleted", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItem?: boolean | Purchase$purchaseItemArgs<ExtArgs>
    Supplier?: boolean | Purchase$SupplierArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Supplier?: boolean | Purchase$SupplierArgs<ExtArgs>
  }
  export type PurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Supplier?: boolean | Purchase$SupplierArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      purchaseItem: Prisma.$PurchaseItemPayload<ExtArgs>[]
      Supplier: Prisma.$SupplierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taxRate: number
      subTotal: number
      notes: string | null
      amountPaid: number | null
      grandTotal: number
      paidAmount: number
      balance: number
      createdAt: Date
      updatedAt: Date
      referenceNo: string
      supplierId: string | null
      isDeleted: boolean
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchaseUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseItem<T extends Purchase$purchaseItemArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$purchaseItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Supplier<T extends Purchase$SupplierArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$SupplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly taxRate: FieldRef<"Purchase", 'Float'>
    readonly subTotal: FieldRef<"Purchase", 'Float'>
    readonly notes: FieldRef<"Purchase", 'String'>
    readonly amountPaid: FieldRef<"Purchase", 'Float'>
    readonly grandTotal: FieldRef<"Purchase", 'Float'>
    readonly paidAmount: FieldRef<"Purchase", 'Float'>
    readonly balance: FieldRef<"Purchase", 'Float'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
    readonly referenceNo: FieldRef<"Purchase", 'String'>
    readonly supplierId: FieldRef<"Purchase", 'String'>
    readonly isDeleted: FieldRef<"Purchase", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase updateManyAndReturn
   */
  export type PurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase.purchaseItem
   */
  export type Purchase$purchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Purchase.Supplier
   */
  export type Purchase$SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseItem
   */

  export type AggregatePurchaseItem = {
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  export type PurchaseItemAvgAggregateOutputType = {
    cost: number | null
    selectedPrice: number | null
    quantity: number | null
    discount: number | null
    total: number | null
    profit: number | null
    customRetailPrice: number | null
    customWholesalePrice: number | null
  }

  export type PurchaseItemSumAggregateOutputType = {
    cost: number | null
    selectedPrice: number | null
    quantity: number | null
    discount: number | null
    total: number | null
    profit: number | null
    customRetailPrice: number | null
    customWholesalePrice: number | null
  }

  export type PurchaseItemMinAggregateOutputType = {
    id: string | null
    productId: string | null
    cost: number | null
    productName: string | null
    selectedPrice: number | null
    priceType: string | null
    quantity: number | null
    discount: number | null
    total: number | null
    profit: number | null
    sync: boolean | null
    syncedAt: Date | null
    purchaseId: string | null
    customRetailPrice: number | null
    customWholesalePrice: number | null
    expiryDate: Date | null
    batchNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type PurchaseItemMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    cost: number | null
    productName: string | null
    selectedPrice: number | null
    priceType: string | null
    quantity: number | null
    discount: number | null
    total: number | null
    profit: number | null
    sync: boolean | null
    syncedAt: Date | null
    purchaseId: string | null
    customRetailPrice: number | null
    customWholesalePrice: number | null
    expiryDate: Date | null
    batchNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type PurchaseItemCountAggregateOutputType = {
    id: number
    productId: number
    cost: number
    productName: number
    selectedPrice: number
    priceType: number
    quantity: number
    discount: number
    total: number
    profit: number
    sync: number
    syncedAt: number
    purchaseId: number
    customRetailPrice: number
    customWholesalePrice: number
    expiryDate: number
    batchNumber: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type PurchaseItemAvgAggregateInputType = {
    cost?: true
    selectedPrice?: true
    quantity?: true
    discount?: true
    total?: true
    profit?: true
    customRetailPrice?: true
    customWholesalePrice?: true
  }

  export type PurchaseItemSumAggregateInputType = {
    cost?: true
    selectedPrice?: true
    quantity?: true
    discount?: true
    total?: true
    profit?: true
    customRetailPrice?: true
    customWholesalePrice?: true
  }

  export type PurchaseItemMinAggregateInputType = {
    id?: true
    productId?: true
    cost?: true
    productName?: true
    selectedPrice?: true
    priceType?: true
    quantity?: true
    discount?: true
    total?: true
    profit?: true
    sync?: true
    syncedAt?: true
    purchaseId?: true
    customRetailPrice?: true
    customWholesalePrice?: true
    expiryDate?: true
    batchNumber?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type PurchaseItemMaxAggregateInputType = {
    id?: true
    productId?: true
    cost?: true
    productName?: true
    selectedPrice?: true
    priceType?: true
    quantity?: true
    discount?: true
    total?: true
    profit?: true
    sync?: true
    syncedAt?: true
    purchaseId?: true
    customRetailPrice?: true
    customWholesalePrice?: true
    expiryDate?: true
    batchNumber?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type PurchaseItemCountAggregateInputType = {
    id?: true
    productId?: true
    cost?: true
    productName?: true
    selectedPrice?: true
    priceType?: true
    quantity?: true
    discount?: true
    total?: true
    profit?: true
    sync?: true
    syncedAt?: true
    purchaseId?: true
    customRetailPrice?: true
    customWholesalePrice?: true
    expiryDate?: true
    batchNumber?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type PurchaseItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItem to aggregate.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItems
    **/
    _count?: true | PurchaseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type GetPurchaseItemAggregateType<T extends PurchaseItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItem[P]>
      : GetScalarType<T[P], AggregatePurchaseItem[P]>
  }




  export type PurchaseItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithAggregationInput | PurchaseItemOrderByWithAggregationInput[]
    by: PurchaseItemScalarFieldEnum[] | PurchaseItemScalarFieldEnum
    having?: PurchaseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemCountAggregateInputType | true
    _avg?: PurchaseItemAvgAggregateInputType
    _sum?: PurchaseItemSumAggregateInputType
    _min?: PurchaseItemMinAggregateInputType
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type PurchaseItemGroupByOutputType = {
    id: string
    productId: string | null
    cost: number
    productName: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync: boolean
    syncedAt: Date | null
    purchaseId: string | null
    customRetailPrice: number | null
    customWholesalePrice: number | null
    expiryDate: Date | null
    batchNumber: string | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  type GetPurchaseItemGroupByPayload<T extends PurchaseItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    cost?: boolean
    productName?: boolean
    selectedPrice?: boolean
    priceType?: boolean
    quantity?: boolean
    discount?: boolean
    total?: boolean
    profit?: boolean
    sync?: boolean
    syncedAt?: boolean
    purchaseId?: boolean
    customRetailPrice?: boolean
    customWholesalePrice?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    product?: boolean | PurchaseItem$productArgs<ExtArgs>
    Purchase?: boolean | PurchaseItem$PurchaseArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    cost?: boolean
    productName?: boolean
    selectedPrice?: boolean
    priceType?: boolean
    quantity?: boolean
    discount?: boolean
    total?: boolean
    profit?: boolean
    sync?: boolean
    syncedAt?: boolean
    purchaseId?: boolean
    customRetailPrice?: boolean
    customWholesalePrice?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    product?: boolean | PurchaseItem$productArgs<ExtArgs>
    Purchase?: boolean | PurchaseItem$PurchaseArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    cost?: boolean
    productName?: boolean
    selectedPrice?: boolean
    priceType?: boolean
    quantity?: boolean
    discount?: boolean
    total?: boolean
    profit?: boolean
    sync?: boolean
    syncedAt?: boolean
    purchaseId?: boolean
    customRetailPrice?: boolean
    customWholesalePrice?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    product?: boolean | PurchaseItem$productArgs<ExtArgs>
    Purchase?: boolean | PurchaseItem$PurchaseArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectScalar = {
    id?: boolean
    productId?: boolean
    cost?: boolean
    productName?: boolean
    selectedPrice?: boolean
    priceType?: boolean
    quantity?: boolean
    discount?: boolean
    total?: boolean
    profit?: boolean
    sync?: boolean
    syncedAt?: boolean
    purchaseId?: boolean
    customRetailPrice?: boolean
    customWholesalePrice?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type PurchaseItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "cost" | "productName" | "selectedPrice" | "priceType" | "quantity" | "discount" | "total" | "profit" | "sync" | "syncedAt" | "purchaseId" | "customRetailPrice" | "customWholesalePrice" | "expiryDate" | "batchNumber" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["purchaseItem"]>
  export type PurchaseItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | PurchaseItem$productArgs<ExtArgs>
    Purchase?: boolean | PurchaseItem$PurchaseArgs<ExtArgs>
  }
  export type PurchaseItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | PurchaseItem$productArgs<ExtArgs>
    Purchase?: boolean | PurchaseItem$PurchaseArgs<ExtArgs>
  }
  export type PurchaseItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | PurchaseItem$productArgs<ExtArgs>
    Purchase?: boolean | PurchaseItem$PurchaseArgs<ExtArgs>
  }

  export type $PurchaseItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseItem"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
      Purchase: Prisma.$PurchasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string | null
      cost: number
      productName: string | null
      selectedPrice: number
      priceType: string
      quantity: number
      discount: number
      total: number
      profit: number
      sync: boolean
      syncedAt: Date | null
      purchaseId: string | null
      customRetailPrice: number | null
      customWholesalePrice: number | null
      expiryDate: Date | null
      batchNumber: string | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["purchaseItem"]>
    composites: {}
  }

  type PurchaseItemGetPayload<S extends boolean | null | undefined | PurchaseItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseItemPayload, S>

  type PurchaseItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseItemCountAggregateInputType | true
    }

  export interface PurchaseItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseItem'], meta: { name: 'PurchaseItem' } }
    /**
     * Find zero or one PurchaseItem that matches the filter.
     * @param {PurchaseItemFindUniqueArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseItemFindUniqueArgs>(args: SelectSubset<T, PurchaseItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseItemFindFirstArgs>(args?: SelectSubset<T, PurchaseItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseItemFindManyArgs>(args?: SelectSubset<T, PurchaseItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseItem.
     * @param {PurchaseItemCreateArgs} args - Arguments to create a PurchaseItem.
     * @example
     * // Create one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.create({
     *   data: {
     *     // ... data to create a PurchaseItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseItemCreateArgs>(args: SelectSubset<T, PurchaseItemCreateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseItems.
     * @param {PurchaseItemCreateManyArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseItemCreateManyArgs>(args?: SelectSubset<T, PurchaseItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseItems and returns the data saved in the database.
     * @param {PurchaseItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseItems and only return the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseItem.
     * @param {PurchaseItemDeleteArgs} args - Arguments to delete one PurchaseItem.
     * @example
     * // Delete one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseItemDeleteArgs>(args: SelectSubset<T, PurchaseItemDeleteArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseItem.
     * @param {PurchaseItemUpdateArgs} args - Arguments to update one PurchaseItem.
     * @example
     * // Update one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseItemUpdateArgs>(args: SelectSubset<T, PurchaseItemUpdateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseItems.
     * @param {PurchaseItemDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseItemUpdateManyArgs>(args: SelectSubset<T, PurchaseItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems and returns the data updated in the database.
     * @param {PurchaseItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseItems.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseItems and only return the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseItem.
     * @param {PurchaseItemUpsertArgs} args - Arguments to update or create a PurchaseItem.
     * @example
     * // Update or create a PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseItemUpsertArgs>(args: SelectSubset<T, PurchaseItemUpsertArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItem.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemCountArgs>(
      args?: Subset<T, PurchaseItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemAggregateArgs>(args: Subset<T, PurchaseItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemAggregateType<T>>

    /**
     * Group by PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseItem model
   */
  readonly fields: PurchaseItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends PurchaseItem$productArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Purchase<T extends PurchaseItem$PurchaseArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseItem$PurchaseArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseItem model
   */
  interface PurchaseItemFieldRefs {
    readonly id: FieldRef<"PurchaseItem", 'String'>
    readonly productId: FieldRef<"PurchaseItem", 'String'>
    readonly cost: FieldRef<"PurchaseItem", 'Float'>
    readonly productName: FieldRef<"PurchaseItem", 'String'>
    readonly selectedPrice: FieldRef<"PurchaseItem", 'Float'>
    readonly priceType: FieldRef<"PurchaseItem", 'String'>
    readonly quantity: FieldRef<"PurchaseItem", 'Int'>
    readonly discount: FieldRef<"PurchaseItem", 'Float'>
    readonly total: FieldRef<"PurchaseItem", 'Float'>
    readonly profit: FieldRef<"PurchaseItem", 'Float'>
    readonly sync: FieldRef<"PurchaseItem", 'Boolean'>
    readonly syncedAt: FieldRef<"PurchaseItem", 'DateTime'>
    readonly purchaseId: FieldRef<"PurchaseItem", 'String'>
    readonly customRetailPrice: FieldRef<"PurchaseItem", 'Float'>
    readonly customWholesalePrice: FieldRef<"PurchaseItem", 'Float'>
    readonly expiryDate: FieldRef<"PurchaseItem", 'DateTime'>
    readonly batchNumber: FieldRef<"PurchaseItem", 'String'>
    readonly createdAt: FieldRef<"PurchaseItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseItem", 'DateTime'>
    readonly isDeleted: FieldRef<"PurchaseItem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseItem findUnique
   */
  export type PurchaseItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findUniqueOrThrow
   */
  export type PurchaseItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findFirst
   */
  export type PurchaseItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findFirstOrThrow
   */
  export type PurchaseItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findMany
   */
  export type PurchaseItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem create
   */
  export type PurchaseItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseItem.
     */
    data: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
  }

  /**
   * PurchaseItem createMany
   */
  export type PurchaseItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
  }

  /**
   * PurchaseItem createManyAndReturn
   */
  export type PurchaseItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItem update
   */
  export type PurchaseItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseItem.
     */
    data: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItem to update.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem updateMany
   */
  export type PurchaseItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseItem updateManyAndReturn
   */
  export type PurchaseItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItem upsert
   */
  export type PurchaseItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseItem to update in case it exists.
     */
    where: PurchaseItemWhereUniqueInput
    /**
     * In case the PurchaseItem found by the `where` argument doesn't exist, create a new PurchaseItem with this data.
     */
    create: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
    /**
     * In case the PurchaseItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
  }

  /**
   * PurchaseItem delete
   */
  export type PurchaseItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseItem to delete.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem deleteMany
   */
  export type PurchaseItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItems to delete
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseItem.product
   */
  export type PurchaseItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * PurchaseItem.Purchase
   */
  export type PurchaseItem$PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * PurchaseItem without action
   */
  export type PurchaseItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
  }


  /**
   * Model BalanceTransaction
   */

  export type AggregateBalanceTransaction = {
    _count: BalanceTransactionCountAggregateOutputType | null
    _avg: BalanceTransactionAvgAggregateOutputType | null
    _sum: BalanceTransactionSumAggregateOutputType | null
    _min: BalanceTransactionMinAggregateOutputType | null
    _max: BalanceTransactionMaxAggregateOutputType | null
  }

  export type BalanceTransactionAvgAggregateOutputType = {
    amount: number | null
    balanceAfter: number | null
  }

  export type BalanceTransactionSumAggregateOutputType = {
    amount: number | null
    balanceAfter: number | null
  }

  export type BalanceTransactionMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    amount: number | null
    type: string | null
    description: string | null
    paymentMethod: string | null
    reference: string | null
    prescriptionId: string | null
    balanceAfter: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type BalanceTransactionMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    amount: number | null
    type: string | null
    description: string | null
    paymentMethod: string | null
    reference: string | null
    prescriptionId: string | null
    balanceAfter: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type BalanceTransactionCountAggregateOutputType = {
    id: number
    studentId: number
    amount: number
    type: number
    description: number
    paymentMethod: number
    reference: number
    prescriptionId: number
    balanceAfter: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type BalanceTransactionAvgAggregateInputType = {
    amount?: true
    balanceAfter?: true
  }

  export type BalanceTransactionSumAggregateInputType = {
    amount?: true
    balanceAfter?: true
  }

  export type BalanceTransactionMinAggregateInputType = {
    id?: true
    studentId?: true
    amount?: true
    type?: true
    description?: true
    paymentMethod?: true
    reference?: true
    prescriptionId?: true
    balanceAfter?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type BalanceTransactionMaxAggregateInputType = {
    id?: true
    studentId?: true
    amount?: true
    type?: true
    description?: true
    paymentMethod?: true
    reference?: true
    prescriptionId?: true
    balanceAfter?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type BalanceTransactionCountAggregateInputType = {
    id?: true
    studentId?: true
    amount?: true
    type?: true
    description?: true
    paymentMethod?: true
    reference?: true
    prescriptionId?: true
    balanceAfter?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type BalanceTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BalanceTransaction to aggregate.
     */
    where?: BalanceTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceTransactions to fetch.
     */
    orderBy?: BalanceTransactionOrderByWithRelationInput | BalanceTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BalanceTransactions
    **/
    _count?: true | BalanceTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceTransactionMaxAggregateInputType
  }

  export type GetBalanceTransactionAggregateType<T extends BalanceTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBalanceTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalanceTransaction[P]>
      : GetScalarType<T[P], AggregateBalanceTransaction[P]>
  }




  export type BalanceTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceTransactionWhereInput
    orderBy?: BalanceTransactionOrderByWithAggregationInput | BalanceTransactionOrderByWithAggregationInput[]
    by: BalanceTransactionScalarFieldEnum[] | BalanceTransactionScalarFieldEnum
    having?: BalanceTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceTransactionCountAggregateInputType | true
    _avg?: BalanceTransactionAvgAggregateInputType
    _sum?: BalanceTransactionSumAggregateInputType
    _min?: BalanceTransactionMinAggregateInputType
    _max?: BalanceTransactionMaxAggregateInputType
  }

  export type BalanceTransactionGroupByOutputType = {
    id: string
    studentId: string
    amount: number
    type: string
    description: string
    paymentMethod: string | null
    reference: string | null
    prescriptionId: string | null
    balanceAfter: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: BalanceTransactionCountAggregateOutputType | null
    _avg: BalanceTransactionAvgAggregateOutputType | null
    _sum: BalanceTransactionSumAggregateOutputType | null
    _min: BalanceTransactionMinAggregateOutputType | null
    _max: BalanceTransactionMaxAggregateOutputType | null
  }

  type GetBalanceTransactionGroupByPayload<T extends BalanceTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BalanceTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    paymentMethod?: boolean
    reference?: boolean
    prescriptionId?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balanceTransaction"]>

  export type BalanceTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    paymentMethod?: boolean
    reference?: boolean
    prescriptionId?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balanceTransaction"]>

  export type BalanceTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    paymentMethod?: boolean
    reference?: boolean
    prescriptionId?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balanceTransaction"]>

  export type BalanceTransactionSelectScalar = {
    id?: boolean
    studentId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    paymentMethod?: boolean
    reference?: boolean
    prescriptionId?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type BalanceTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "amount" | "type" | "description" | "paymentMethod" | "reference" | "prescriptionId" | "balanceAfter" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["balanceTransaction"]>
  export type BalanceTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type BalanceTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type BalanceTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $BalanceTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BalanceTransaction"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      amount: number
      type: string
      description: string
      paymentMethod: string | null
      reference: string | null
      prescriptionId: string | null
      balanceAfter: number
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["balanceTransaction"]>
    composites: {}
  }

  type BalanceTransactionGetPayload<S extends boolean | null | undefined | BalanceTransactionDefaultArgs> = $Result.GetResult<Prisma.$BalanceTransactionPayload, S>

  type BalanceTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalanceTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalanceTransactionCountAggregateInputType | true
    }

  export interface BalanceTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BalanceTransaction'], meta: { name: 'BalanceTransaction' } }
    /**
     * Find zero or one BalanceTransaction that matches the filter.
     * @param {BalanceTransactionFindUniqueArgs} args - Arguments to find a BalanceTransaction
     * @example
     * // Get one BalanceTransaction
     * const balanceTransaction = await prisma.balanceTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceTransactionFindUniqueArgs>(args: SelectSubset<T, BalanceTransactionFindUniqueArgs<ExtArgs>>): Prisma__BalanceTransactionClient<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BalanceTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalanceTransactionFindUniqueOrThrowArgs} args - Arguments to find a BalanceTransaction
     * @example
     * // Get one BalanceTransaction
     * const balanceTransaction = await prisma.balanceTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceTransactionClient<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BalanceTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceTransactionFindFirstArgs} args - Arguments to find a BalanceTransaction
     * @example
     * // Get one BalanceTransaction
     * const balanceTransaction = await prisma.balanceTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceTransactionFindFirstArgs>(args?: SelectSubset<T, BalanceTransactionFindFirstArgs<ExtArgs>>): Prisma__BalanceTransactionClient<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BalanceTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceTransactionFindFirstOrThrowArgs} args - Arguments to find a BalanceTransaction
     * @example
     * // Get one BalanceTransaction
     * const balanceTransaction = await prisma.balanceTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceTransactionClient<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BalanceTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BalanceTransactions
     * const balanceTransactions = await prisma.balanceTransaction.findMany()
     * 
     * // Get first 10 BalanceTransactions
     * const balanceTransactions = await prisma.balanceTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceTransactionWithIdOnly = await prisma.balanceTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceTransactionFindManyArgs>(args?: SelectSubset<T, BalanceTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BalanceTransaction.
     * @param {BalanceTransactionCreateArgs} args - Arguments to create a BalanceTransaction.
     * @example
     * // Create one BalanceTransaction
     * const BalanceTransaction = await prisma.balanceTransaction.create({
     *   data: {
     *     // ... data to create a BalanceTransaction
     *   }
     * })
     * 
     */
    create<T extends BalanceTransactionCreateArgs>(args: SelectSubset<T, BalanceTransactionCreateArgs<ExtArgs>>): Prisma__BalanceTransactionClient<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BalanceTransactions.
     * @param {BalanceTransactionCreateManyArgs} args - Arguments to create many BalanceTransactions.
     * @example
     * // Create many BalanceTransactions
     * const balanceTransaction = await prisma.balanceTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceTransactionCreateManyArgs>(args?: SelectSubset<T, BalanceTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BalanceTransactions and returns the data saved in the database.
     * @param {BalanceTransactionCreateManyAndReturnArgs} args - Arguments to create many BalanceTransactions.
     * @example
     * // Create many BalanceTransactions
     * const balanceTransaction = await prisma.balanceTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BalanceTransactions and only return the `id`
     * const balanceTransactionWithIdOnly = await prisma.balanceTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BalanceTransaction.
     * @param {BalanceTransactionDeleteArgs} args - Arguments to delete one BalanceTransaction.
     * @example
     * // Delete one BalanceTransaction
     * const BalanceTransaction = await prisma.balanceTransaction.delete({
     *   where: {
     *     // ... filter to delete one BalanceTransaction
     *   }
     * })
     * 
     */
    delete<T extends BalanceTransactionDeleteArgs>(args: SelectSubset<T, BalanceTransactionDeleteArgs<ExtArgs>>): Prisma__BalanceTransactionClient<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BalanceTransaction.
     * @param {BalanceTransactionUpdateArgs} args - Arguments to update one BalanceTransaction.
     * @example
     * // Update one BalanceTransaction
     * const balanceTransaction = await prisma.balanceTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceTransactionUpdateArgs>(args: SelectSubset<T, BalanceTransactionUpdateArgs<ExtArgs>>): Prisma__BalanceTransactionClient<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BalanceTransactions.
     * @param {BalanceTransactionDeleteManyArgs} args - Arguments to filter BalanceTransactions to delete.
     * @example
     * // Delete a few BalanceTransactions
     * const { count } = await prisma.balanceTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceTransactionDeleteManyArgs>(args?: SelectSubset<T, BalanceTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BalanceTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BalanceTransactions
     * const balanceTransaction = await prisma.balanceTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceTransactionUpdateManyArgs>(args: SelectSubset<T, BalanceTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BalanceTransactions and returns the data updated in the database.
     * @param {BalanceTransactionUpdateManyAndReturnArgs} args - Arguments to update many BalanceTransactions.
     * @example
     * // Update many BalanceTransactions
     * const balanceTransaction = await prisma.balanceTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BalanceTransactions and only return the `id`
     * const balanceTransactionWithIdOnly = await prisma.balanceTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BalanceTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, BalanceTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BalanceTransaction.
     * @param {BalanceTransactionUpsertArgs} args - Arguments to update or create a BalanceTransaction.
     * @example
     * // Update or create a BalanceTransaction
     * const balanceTransaction = await prisma.balanceTransaction.upsert({
     *   create: {
     *     // ... data to create a BalanceTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BalanceTransaction we want to update
     *   }
     * })
     */
    upsert<T extends BalanceTransactionUpsertArgs>(args: SelectSubset<T, BalanceTransactionUpsertArgs<ExtArgs>>): Prisma__BalanceTransactionClient<$Result.GetResult<Prisma.$BalanceTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BalanceTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceTransactionCountArgs} args - Arguments to filter BalanceTransactions to count.
     * @example
     * // Count the number of BalanceTransactions
     * const count = await prisma.balanceTransaction.count({
     *   where: {
     *     // ... the filter for the BalanceTransactions we want to count
     *   }
     * })
    **/
    count<T extends BalanceTransactionCountArgs>(
      args?: Subset<T, BalanceTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BalanceTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceTransactionAggregateArgs>(args: Subset<T, BalanceTransactionAggregateArgs>): Prisma.PrismaPromise<GetBalanceTransactionAggregateType<T>>

    /**
     * Group by BalanceTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BalanceTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BalanceTransaction model
   */
  readonly fields: BalanceTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BalanceTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BalanceTransaction model
   */
  interface BalanceTransactionFieldRefs {
    readonly id: FieldRef<"BalanceTransaction", 'String'>
    readonly studentId: FieldRef<"BalanceTransaction", 'String'>
    readonly amount: FieldRef<"BalanceTransaction", 'Float'>
    readonly type: FieldRef<"BalanceTransaction", 'String'>
    readonly description: FieldRef<"BalanceTransaction", 'String'>
    readonly paymentMethod: FieldRef<"BalanceTransaction", 'String'>
    readonly reference: FieldRef<"BalanceTransaction", 'String'>
    readonly prescriptionId: FieldRef<"BalanceTransaction", 'String'>
    readonly balanceAfter: FieldRef<"BalanceTransaction", 'Float'>
    readonly createdAt: FieldRef<"BalanceTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"BalanceTransaction", 'DateTime'>
    readonly isDeleted: FieldRef<"BalanceTransaction", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BalanceTransaction findUnique
   */
  export type BalanceTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BalanceTransaction to fetch.
     */
    where: BalanceTransactionWhereUniqueInput
  }

  /**
   * BalanceTransaction findUniqueOrThrow
   */
  export type BalanceTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BalanceTransaction to fetch.
     */
    where: BalanceTransactionWhereUniqueInput
  }

  /**
   * BalanceTransaction findFirst
   */
  export type BalanceTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BalanceTransaction to fetch.
     */
    where?: BalanceTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceTransactions to fetch.
     */
    orderBy?: BalanceTransactionOrderByWithRelationInput | BalanceTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BalanceTransactions.
     */
    cursor?: BalanceTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BalanceTransactions.
     */
    distinct?: BalanceTransactionScalarFieldEnum | BalanceTransactionScalarFieldEnum[]
  }

  /**
   * BalanceTransaction findFirstOrThrow
   */
  export type BalanceTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BalanceTransaction to fetch.
     */
    where?: BalanceTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceTransactions to fetch.
     */
    orderBy?: BalanceTransactionOrderByWithRelationInput | BalanceTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BalanceTransactions.
     */
    cursor?: BalanceTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BalanceTransactions.
     */
    distinct?: BalanceTransactionScalarFieldEnum | BalanceTransactionScalarFieldEnum[]
  }

  /**
   * BalanceTransaction findMany
   */
  export type BalanceTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BalanceTransactions to fetch.
     */
    where?: BalanceTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceTransactions to fetch.
     */
    orderBy?: BalanceTransactionOrderByWithRelationInput | BalanceTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BalanceTransactions.
     */
    cursor?: BalanceTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceTransactions.
     */
    skip?: number
    distinct?: BalanceTransactionScalarFieldEnum | BalanceTransactionScalarFieldEnum[]
  }

  /**
   * BalanceTransaction create
   */
  export type BalanceTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BalanceTransaction.
     */
    data: XOR<BalanceTransactionCreateInput, BalanceTransactionUncheckedCreateInput>
  }

  /**
   * BalanceTransaction createMany
   */
  export type BalanceTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BalanceTransactions.
     */
    data: BalanceTransactionCreateManyInput | BalanceTransactionCreateManyInput[]
  }

  /**
   * BalanceTransaction createManyAndReturn
   */
  export type BalanceTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many BalanceTransactions.
     */
    data: BalanceTransactionCreateManyInput | BalanceTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BalanceTransaction update
   */
  export type BalanceTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BalanceTransaction.
     */
    data: XOR<BalanceTransactionUpdateInput, BalanceTransactionUncheckedUpdateInput>
    /**
     * Choose, which BalanceTransaction to update.
     */
    where: BalanceTransactionWhereUniqueInput
  }

  /**
   * BalanceTransaction updateMany
   */
  export type BalanceTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BalanceTransactions.
     */
    data: XOR<BalanceTransactionUpdateManyMutationInput, BalanceTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BalanceTransactions to update
     */
    where?: BalanceTransactionWhereInput
    /**
     * Limit how many BalanceTransactions to update.
     */
    limit?: number
  }

  /**
   * BalanceTransaction updateManyAndReturn
   */
  export type BalanceTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * The data used to update BalanceTransactions.
     */
    data: XOR<BalanceTransactionUpdateManyMutationInput, BalanceTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BalanceTransactions to update
     */
    where?: BalanceTransactionWhereInput
    /**
     * Limit how many BalanceTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BalanceTransaction upsert
   */
  export type BalanceTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BalanceTransaction to update in case it exists.
     */
    where: BalanceTransactionWhereUniqueInput
    /**
     * In case the BalanceTransaction found by the `where` argument doesn't exist, create a new BalanceTransaction with this data.
     */
    create: XOR<BalanceTransactionCreateInput, BalanceTransactionUncheckedCreateInput>
    /**
     * In case the BalanceTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceTransactionUpdateInput, BalanceTransactionUncheckedUpdateInput>
  }

  /**
   * BalanceTransaction delete
   */
  export type BalanceTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
    /**
     * Filter which BalanceTransaction to delete.
     */
    where: BalanceTransactionWhereUniqueInput
  }

  /**
   * BalanceTransaction deleteMany
   */
  export type BalanceTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BalanceTransactions to delete
     */
    where?: BalanceTransactionWhereInput
    /**
     * Limit how many BalanceTransactions to delete.
     */
    limit?: number
  }

  /**
   * BalanceTransaction without action
   */
  export type BalanceTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceTransaction
     */
    select?: BalanceTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceTransaction
     */
    omit?: BalanceTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    companyName: string | null
    email: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    companyName: string | null
    email: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    type: number
    companyName: number
    email: number
    address: number
    phone: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    companyName?: true
    email?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    companyName?: true
    email?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    companyName?: true
    email?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    type: string
    companyName: string | null
    email: string
    address: string
    phone: string
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    companyName?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    purchase?: boolean | Supplier$purchaseArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    companyName?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    companyName?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    companyName?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "companyName" | "email" | "address" | "phone" | "createdAt" | "updatedAt" | "isDeleted", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | Supplier$purchaseArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      companyName: string | null
      email: string
      address: string
      phone: string
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends Supplier$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly type: FieldRef<"Supplier", 'String'>
    readonly companyName: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
    readonly isDeleted: FieldRef<"Supplier", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.purchase
   */
  export type Supplier$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model ReceiptSettings
   */

  export type AggregateReceiptSettings = {
    _count: ReceiptSettingsCountAggregateOutputType | null
    _avg: ReceiptSettingsAvgAggregateOutputType | null
    _sum: ReceiptSettingsSumAggregateOutputType | null
    _min: ReceiptSettingsMinAggregateOutputType | null
    _max: ReceiptSettingsMaxAggregateOutputType | null
  }

  export type ReceiptSettingsAvgAggregateOutputType = {
    printCopyCount: number | null
  }

  export type ReceiptSettingsSumAggregateOutputType = {
    printCopyCount: number | null
  }

  export type ReceiptSettingsMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    businessName: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    receiptTitle: string | null
    headerMessage: string | null
    footerMessage: string | null
    showLogo: boolean | null
    logoUrl: string | null
    showQrCode: boolean | null
    qrCodeContent: string | null
    customQrContent: string | null
    showStudentInfo: boolean | null
    showPhysicianInfo: boolean | null
    showPharmacistInfo: boolean | null
    showDrugCodes: boolean | null
    showDrugDescriptions: boolean | null
    showDosageInstructions: boolean | null
    showTimestamp: boolean | null
    use24HourFormat: boolean | null
    paperSize: string | null
    fontSize: string | null
    printDensity: string | null
    lineSpacing: string | null
    primaryColor: string | null
    accentColor: string | null
    fontFamily: string | null
    printCopyCount: number | null
    autoPrint: boolean | null
    language: string | null
    currency: string | null
    currencySymbol: string | null
    currencyPosition: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    syncedAt: Date | null
    isDeleted: boolean | null
  }

  export type ReceiptSettingsMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    businessName: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    receiptTitle: string | null
    headerMessage: string | null
    footerMessage: string | null
    showLogo: boolean | null
    logoUrl: string | null
    showQrCode: boolean | null
    qrCodeContent: string | null
    customQrContent: string | null
    showStudentInfo: boolean | null
    showPhysicianInfo: boolean | null
    showPharmacistInfo: boolean | null
    showDrugCodes: boolean | null
    showDrugDescriptions: boolean | null
    showDosageInstructions: boolean | null
    showTimestamp: boolean | null
    use24HourFormat: boolean | null
    paperSize: string | null
    fontSize: string | null
    printDensity: string | null
    lineSpacing: string | null
    primaryColor: string | null
    accentColor: string | null
    fontFamily: string | null
    printCopyCount: number | null
    autoPrint: boolean | null
    language: string | null
    currency: string | null
    currencySymbol: string | null
    currencyPosition: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sync: boolean | null
    syncedAt: Date | null
    isDeleted: boolean | null
  }

  export type ReceiptSettingsCountAggregateOutputType = {
    id: number
    companyName: number
    businessName: number
    address: number
    city: number
    state: number
    country: number
    phone: number
    email: number
    website: number
    receiptTitle: number
    headerMessage: number
    footerMessage: number
    showLogo: number
    logoUrl: number
    showQrCode: number
    qrCodeContent: number
    customQrContent: number
    showStudentInfo: number
    showPhysicianInfo: number
    showPharmacistInfo: number
    showDrugCodes: number
    showDrugDescriptions: number
    showDosageInstructions: number
    showTimestamp: number
    use24HourFormat: number
    paperSize: number
    fontSize: number
    printDensity: number
    lineSpacing: number
    primaryColor: number
    accentColor: number
    fontFamily: number
    printCopyCount: number
    autoPrint: number
    language: number
    currency: number
    currencySymbol: number
    currencyPosition: number
    createdAt: number
    updatedAt: number
    sync: number
    syncedAt: number
    isDeleted: number
    _all: number
  }


  export type ReceiptSettingsAvgAggregateInputType = {
    printCopyCount?: true
  }

  export type ReceiptSettingsSumAggregateInputType = {
    printCopyCount?: true
  }

  export type ReceiptSettingsMinAggregateInputType = {
    id?: true
    companyName?: true
    businessName?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    receiptTitle?: true
    headerMessage?: true
    footerMessage?: true
    showLogo?: true
    logoUrl?: true
    showQrCode?: true
    qrCodeContent?: true
    customQrContent?: true
    showStudentInfo?: true
    showPhysicianInfo?: true
    showPharmacistInfo?: true
    showDrugCodes?: true
    showDrugDescriptions?: true
    showDosageInstructions?: true
    showTimestamp?: true
    use24HourFormat?: true
    paperSize?: true
    fontSize?: true
    printDensity?: true
    lineSpacing?: true
    primaryColor?: true
    accentColor?: true
    fontFamily?: true
    printCopyCount?: true
    autoPrint?: true
    language?: true
    currency?: true
    currencySymbol?: true
    currencyPosition?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
  }

  export type ReceiptSettingsMaxAggregateInputType = {
    id?: true
    companyName?: true
    businessName?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    receiptTitle?: true
    headerMessage?: true
    footerMessage?: true
    showLogo?: true
    logoUrl?: true
    showQrCode?: true
    qrCodeContent?: true
    customQrContent?: true
    showStudentInfo?: true
    showPhysicianInfo?: true
    showPharmacistInfo?: true
    showDrugCodes?: true
    showDrugDescriptions?: true
    showDosageInstructions?: true
    showTimestamp?: true
    use24HourFormat?: true
    paperSize?: true
    fontSize?: true
    printDensity?: true
    lineSpacing?: true
    primaryColor?: true
    accentColor?: true
    fontFamily?: true
    printCopyCount?: true
    autoPrint?: true
    language?: true
    currency?: true
    currencySymbol?: true
    currencyPosition?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
  }

  export type ReceiptSettingsCountAggregateInputType = {
    id?: true
    companyName?: true
    businessName?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    receiptTitle?: true
    headerMessage?: true
    footerMessage?: true
    showLogo?: true
    logoUrl?: true
    showQrCode?: true
    qrCodeContent?: true
    customQrContent?: true
    showStudentInfo?: true
    showPhysicianInfo?: true
    showPharmacistInfo?: true
    showDrugCodes?: true
    showDrugDescriptions?: true
    showDosageInstructions?: true
    showTimestamp?: true
    use24HourFormat?: true
    paperSize?: true
    fontSize?: true
    printDensity?: true
    lineSpacing?: true
    primaryColor?: true
    accentColor?: true
    fontFamily?: true
    printCopyCount?: true
    autoPrint?: true
    language?: true
    currency?: true
    currencySymbol?: true
    currencyPosition?: true
    createdAt?: true
    updatedAt?: true
    sync?: true
    syncedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type ReceiptSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceiptSettings to aggregate.
     */
    where?: ReceiptSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptSettings to fetch.
     */
    orderBy?: ReceiptSettingsOrderByWithRelationInput | ReceiptSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceiptSettings
    **/
    _count?: true | ReceiptSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptSettingsMaxAggregateInputType
  }

  export type GetReceiptSettingsAggregateType<T extends ReceiptSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateReceiptSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceiptSettings[P]>
      : GetScalarType<T[P], AggregateReceiptSettings[P]>
  }




  export type ReceiptSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptSettingsWhereInput
    orderBy?: ReceiptSettingsOrderByWithAggregationInput | ReceiptSettingsOrderByWithAggregationInput[]
    by: ReceiptSettingsScalarFieldEnum[] | ReceiptSettingsScalarFieldEnum
    having?: ReceiptSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptSettingsCountAggregateInputType | true
    _avg?: ReceiptSettingsAvgAggregateInputType
    _sum?: ReceiptSettingsSumAggregateInputType
    _min?: ReceiptSettingsMinAggregateInputType
    _max?: ReceiptSettingsMaxAggregateInputType
  }

  export type ReceiptSettingsGroupByOutputType = {
    id: string
    companyName: string
    businessName: string
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website: string
    receiptTitle: string | null
    headerMessage: string | null
    footerMessage: string | null
    showLogo: boolean | null
    logoUrl: string | null
    showQrCode: boolean | null
    qrCodeContent: string | null
    customQrContent: string | null
    showStudentInfo: boolean | null
    showPhysicianInfo: boolean | null
    showPharmacistInfo: boolean | null
    showDrugCodes: boolean | null
    showDrugDescriptions: boolean | null
    showDosageInstructions: boolean | null
    showTimestamp: boolean | null
    use24HourFormat: boolean | null
    paperSize: string | null
    fontSize: string | null
    printDensity: string | null
    lineSpacing: string | null
    primaryColor: string | null
    accentColor: string | null
    fontFamily: string | null
    printCopyCount: number | null
    autoPrint: boolean | null
    language: string | null
    currency: string | null
    currencySymbol: string | null
    currencyPosition: string | null
    createdAt: Date
    updatedAt: Date
    sync: boolean
    syncedAt: Date | null
    isDeleted: boolean
    _count: ReceiptSettingsCountAggregateOutputType | null
    _avg: ReceiptSettingsAvgAggregateOutputType | null
    _sum: ReceiptSettingsSumAggregateOutputType | null
    _min: ReceiptSettingsMinAggregateOutputType | null
    _max: ReceiptSettingsMaxAggregateOutputType | null
  }

  type GetReceiptSettingsGroupByPayload<T extends ReceiptSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptSettingsGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    businessName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    receiptTitle?: boolean
    headerMessage?: boolean
    footerMessage?: boolean
    showLogo?: boolean
    logoUrl?: boolean
    showQrCode?: boolean
    qrCodeContent?: boolean
    customQrContent?: boolean
    showStudentInfo?: boolean
    showPhysicianInfo?: boolean
    showPharmacistInfo?: boolean
    showDrugCodes?: boolean
    showDrugDescriptions?: boolean
    showDosageInstructions?: boolean
    showTimestamp?: boolean
    use24HourFormat?: boolean
    paperSize?: boolean
    fontSize?: boolean
    printDensity?: boolean
    lineSpacing?: boolean
    primaryColor?: boolean
    accentColor?: boolean
    fontFamily?: boolean
    printCopyCount?: boolean
    autoPrint?: boolean
    language?: boolean
    currency?: boolean
    currencySymbol?: boolean
    currencyPosition?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["receiptSettings"]>

  export type ReceiptSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    businessName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    receiptTitle?: boolean
    headerMessage?: boolean
    footerMessage?: boolean
    showLogo?: boolean
    logoUrl?: boolean
    showQrCode?: boolean
    qrCodeContent?: boolean
    customQrContent?: boolean
    showStudentInfo?: boolean
    showPhysicianInfo?: boolean
    showPharmacistInfo?: boolean
    showDrugCodes?: boolean
    showDrugDescriptions?: boolean
    showDosageInstructions?: boolean
    showTimestamp?: boolean
    use24HourFormat?: boolean
    paperSize?: boolean
    fontSize?: boolean
    printDensity?: boolean
    lineSpacing?: boolean
    primaryColor?: boolean
    accentColor?: boolean
    fontFamily?: boolean
    printCopyCount?: boolean
    autoPrint?: boolean
    language?: boolean
    currency?: boolean
    currencySymbol?: boolean
    currencyPosition?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["receiptSettings"]>

  export type ReceiptSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    businessName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    receiptTitle?: boolean
    headerMessage?: boolean
    footerMessage?: boolean
    showLogo?: boolean
    logoUrl?: boolean
    showQrCode?: boolean
    qrCodeContent?: boolean
    customQrContent?: boolean
    showStudentInfo?: boolean
    showPhysicianInfo?: boolean
    showPharmacistInfo?: boolean
    showDrugCodes?: boolean
    showDrugDescriptions?: boolean
    showDosageInstructions?: boolean
    showTimestamp?: boolean
    use24HourFormat?: boolean
    paperSize?: boolean
    fontSize?: boolean
    printDensity?: boolean
    lineSpacing?: boolean
    primaryColor?: boolean
    accentColor?: boolean
    fontFamily?: boolean
    printCopyCount?: boolean
    autoPrint?: boolean
    language?: boolean
    currency?: boolean
    currencySymbol?: boolean
    currencyPosition?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["receiptSettings"]>

  export type ReceiptSettingsSelectScalar = {
    id?: boolean
    companyName?: boolean
    businessName?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    receiptTitle?: boolean
    headerMessage?: boolean
    footerMessage?: boolean
    showLogo?: boolean
    logoUrl?: boolean
    showQrCode?: boolean
    qrCodeContent?: boolean
    customQrContent?: boolean
    showStudentInfo?: boolean
    showPhysicianInfo?: boolean
    showPharmacistInfo?: boolean
    showDrugCodes?: boolean
    showDrugDescriptions?: boolean
    showDosageInstructions?: boolean
    showTimestamp?: boolean
    use24HourFormat?: boolean
    paperSize?: boolean
    fontSize?: boolean
    printDensity?: boolean
    lineSpacing?: boolean
    primaryColor?: boolean
    accentColor?: boolean
    fontFamily?: boolean
    printCopyCount?: boolean
    autoPrint?: boolean
    language?: boolean
    currency?: boolean
    currencySymbol?: boolean
    currencyPosition?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sync?: boolean
    syncedAt?: boolean
    isDeleted?: boolean
  }

  export type ReceiptSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "businessName" | "address" | "city" | "state" | "country" | "phone" | "email" | "website" | "receiptTitle" | "headerMessage" | "footerMessage" | "showLogo" | "logoUrl" | "showQrCode" | "qrCodeContent" | "customQrContent" | "showStudentInfo" | "showPhysicianInfo" | "showPharmacistInfo" | "showDrugCodes" | "showDrugDescriptions" | "showDosageInstructions" | "showTimestamp" | "use24HourFormat" | "paperSize" | "fontSize" | "printDensity" | "lineSpacing" | "primaryColor" | "accentColor" | "fontFamily" | "printCopyCount" | "autoPrint" | "language" | "currency" | "currencySymbol" | "currencyPosition" | "createdAt" | "updatedAt" | "sync" | "syncedAt" | "isDeleted", ExtArgs["result"]["receiptSettings"]>

  export type $ReceiptSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceiptSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string
      businessName: string
      address: string
      city: string
      state: string
      country: string
      phone: string
      email: string
      website: string
      receiptTitle: string | null
      headerMessage: string | null
      footerMessage: string | null
      showLogo: boolean | null
      logoUrl: string | null
      showQrCode: boolean | null
      qrCodeContent: string | null
      customQrContent: string | null
      showStudentInfo: boolean | null
      showPhysicianInfo: boolean | null
      showPharmacistInfo: boolean | null
      showDrugCodes: boolean | null
      showDrugDescriptions: boolean | null
      showDosageInstructions: boolean | null
      showTimestamp: boolean | null
      use24HourFormat: boolean | null
      paperSize: string | null
      fontSize: string | null
      printDensity: string | null
      lineSpacing: string | null
      primaryColor: string | null
      accentColor: string | null
      fontFamily: string | null
      printCopyCount: number | null
      autoPrint: boolean | null
      language: string | null
      currency: string | null
      currencySymbol: string | null
      currencyPosition: string | null
      createdAt: Date
      updatedAt: Date
      sync: boolean
      syncedAt: Date | null
      isDeleted: boolean
    }, ExtArgs["result"]["receiptSettings"]>
    composites: {}
  }

  type ReceiptSettingsGetPayload<S extends boolean | null | undefined | ReceiptSettingsDefaultArgs> = $Result.GetResult<Prisma.$ReceiptSettingsPayload, S>

  type ReceiptSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceiptSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptSettingsCountAggregateInputType | true
    }

  export interface ReceiptSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceiptSettings'], meta: { name: 'ReceiptSettings' } }
    /**
     * Find zero or one ReceiptSettings that matches the filter.
     * @param {ReceiptSettingsFindUniqueArgs} args - Arguments to find a ReceiptSettings
     * @example
     * // Get one ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceiptSettingsFindUniqueArgs>(args: SelectSubset<T, ReceiptSettingsFindUniqueArgs<ExtArgs>>): Prisma__ReceiptSettingsClient<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReceiptSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceiptSettingsFindUniqueOrThrowArgs} args - Arguments to find a ReceiptSettings
     * @example
     * // Get one ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceiptSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceiptSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceiptSettingsClient<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceiptSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptSettingsFindFirstArgs} args - Arguments to find a ReceiptSettings
     * @example
     * // Get one ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceiptSettingsFindFirstArgs>(args?: SelectSubset<T, ReceiptSettingsFindFirstArgs<ExtArgs>>): Prisma__ReceiptSettingsClient<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceiptSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptSettingsFindFirstOrThrowArgs} args - Arguments to find a ReceiptSettings
     * @example
     * // Get one ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceiptSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceiptSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceiptSettingsClient<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReceiptSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.findMany()
     * 
     * // Get first 10 ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptSettingsWithIdOnly = await prisma.receiptSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceiptSettingsFindManyArgs>(args?: SelectSubset<T, ReceiptSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReceiptSettings.
     * @param {ReceiptSettingsCreateArgs} args - Arguments to create a ReceiptSettings.
     * @example
     * // Create one ReceiptSettings
     * const ReceiptSettings = await prisma.receiptSettings.create({
     *   data: {
     *     // ... data to create a ReceiptSettings
     *   }
     * })
     * 
     */
    create<T extends ReceiptSettingsCreateArgs>(args: SelectSubset<T, ReceiptSettingsCreateArgs<ExtArgs>>): Prisma__ReceiptSettingsClient<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReceiptSettings.
     * @param {ReceiptSettingsCreateManyArgs} args - Arguments to create many ReceiptSettings.
     * @example
     * // Create many ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceiptSettingsCreateManyArgs>(args?: SelectSubset<T, ReceiptSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReceiptSettings and returns the data saved in the database.
     * @param {ReceiptSettingsCreateManyAndReturnArgs} args - Arguments to create many ReceiptSettings.
     * @example
     * // Create many ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReceiptSettings and only return the `id`
     * const receiptSettingsWithIdOnly = await prisma.receiptSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceiptSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceiptSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReceiptSettings.
     * @param {ReceiptSettingsDeleteArgs} args - Arguments to delete one ReceiptSettings.
     * @example
     * // Delete one ReceiptSettings
     * const ReceiptSettings = await prisma.receiptSettings.delete({
     *   where: {
     *     // ... filter to delete one ReceiptSettings
     *   }
     * })
     * 
     */
    delete<T extends ReceiptSettingsDeleteArgs>(args: SelectSubset<T, ReceiptSettingsDeleteArgs<ExtArgs>>): Prisma__ReceiptSettingsClient<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReceiptSettings.
     * @param {ReceiptSettingsUpdateArgs} args - Arguments to update one ReceiptSettings.
     * @example
     * // Update one ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceiptSettingsUpdateArgs>(args: SelectSubset<T, ReceiptSettingsUpdateArgs<ExtArgs>>): Prisma__ReceiptSettingsClient<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReceiptSettings.
     * @param {ReceiptSettingsDeleteManyArgs} args - Arguments to filter ReceiptSettings to delete.
     * @example
     * // Delete a few ReceiptSettings
     * const { count } = await prisma.receiptSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceiptSettingsDeleteManyArgs>(args?: SelectSubset<T, ReceiptSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceiptSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceiptSettingsUpdateManyArgs>(args: SelectSubset<T, ReceiptSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceiptSettings and returns the data updated in the database.
     * @param {ReceiptSettingsUpdateManyAndReturnArgs} args - Arguments to update many ReceiptSettings.
     * @example
     * // Update many ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReceiptSettings and only return the `id`
     * const receiptSettingsWithIdOnly = await prisma.receiptSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceiptSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceiptSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReceiptSettings.
     * @param {ReceiptSettingsUpsertArgs} args - Arguments to update or create a ReceiptSettings.
     * @example
     * // Update or create a ReceiptSettings
     * const receiptSettings = await prisma.receiptSettings.upsert({
     *   create: {
     *     // ... data to create a ReceiptSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceiptSettings we want to update
     *   }
     * })
     */
    upsert<T extends ReceiptSettingsUpsertArgs>(args: SelectSubset<T, ReceiptSettingsUpsertArgs<ExtArgs>>): Prisma__ReceiptSettingsClient<$Result.GetResult<Prisma.$ReceiptSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReceiptSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptSettingsCountArgs} args - Arguments to filter ReceiptSettings to count.
     * @example
     * // Count the number of ReceiptSettings
     * const count = await prisma.receiptSettings.count({
     *   where: {
     *     // ... the filter for the ReceiptSettings we want to count
     *   }
     * })
    **/
    count<T extends ReceiptSettingsCountArgs>(
      args?: Subset<T, ReceiptSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceiptSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptSettingsAggregateArgs>(args: Subset<T, ReceiptSettingsAggregateArgs>): Prisma.PrismaPromise<GetReceiptSettingsAggregateType<T>>

    /**
     * Group by ReceiptSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptSettingsGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceiptSettings model
   */
  readonly fields: ReceiptSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceiptSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceiptSettings model
   */
  interface ReceiptSettingsFieldRefs {
    readonly id: FieldRef<"ReceiptSettings", 'String'>
    readonly companyName: FieldRef<"ReceiptSettings", 'String'>
    readonly businessName: FieldRef<"ReceiptSettings", 'String'>
    readonly address: FieldRef<"ReceiptSettings", 'String'>
    readonly city: FieldRef<"ReceiptSettings", 'String'>
    readonly state: FieldRef<"ReceiptSettings", 'String'>
    readonly country: FieldRef<"ReceiptSettings", 'String'>
    readonly phone: FieldRef<"ReceiptSettings", 'String'>
    readonly email: FieldRef<"ReceiptSettings", 'String'>
    readonly website: FieldRef<"ReceiptSettings", 'String'>
    readonly receiptTitle: FieldRef<"ReceiptSettings", 'String'>
    readonly headerMessage: FieldRef<"ReceiptSettings", 'String'>
    readonly footerMessage: FieldRef<"ReceiptSettings", 'String'>
    readonly showLogo: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly logoUrl: FieldRef<"ReceiptSettings", 'String'>
    readonly showQrCode: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly qrCodeContent: FieldRef<"ReceiptSettings", 'String'>
    readonly customQrContent: FieldRef<"ReceiptSettings", 'String'>
    readonly showStudentInfo: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly showPhysicianInfo: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly showPharmacistInfo: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly showDrugCodes: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly showDrugDescriptions: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly showDosageInstructions: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly showTimestamp: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly use24HourFormat: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly paperSize: FieldRef<"ReceiptSettings", 'String'>
    readonly fontSize: FieldRef<"ReceiptSettings", 'String'>
    readonly printDensity: FieldRef<"ReceiptSettings", 'String'>
    readonly lineSpacing: FieldRef<"ReceiptSettings", 'String'>
    readonly primaryColor: FieldRef<"ReceiptSettings", 'String'>
    readonly accentColor: FieldRef<"ReceiptSettings", 'String'>
    readonly fontFamily: FieldRef<"ReceiptSettings", 'String'>
    readonly printCopyCount: FieldRef<"ReceiptSettings", 'Int'>
    readonly autoPrint: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly language: FieldRef<"ReceiptSettings", 'String'>
    readonly currency: FieldRef<"ReceiptSettings", 'String'>
    readonly currencySymbol: FieldRef<"ReceiptSettings", 'String'>
    readonly currencyPosition: FieldRef<"ReceiptSettings", 'String'>
    readonly createdAt: FieldRef<"ReceiptSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"ReceiptSettings", 'DateTime'>
    readonly sync: FieldRef<"ReceiptSettings", 'Boolean'>
    readonly syncedAt: FieldRef<"ReceiptSettings", 'DateTime'>
    readonly isDeleted: FieldRef<"ReceiptSettings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ReceiptSettings findUnique
   */
  export type ReceiptSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ReceiptSettings to fetch.
     */
    where: ReceiptSettingsWhereUniqueInput
  }

  /**
   * ReceiptSettings findUniqueOrThrow
   */
  export type ReceiptSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ReceiptSettings to fetch.
     */
    where: ReceiptSettingsWhereUniqueInput
  }

  /**
   * ReceiptSettings findFirst
   */
  export type ReceiptSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ReceiptSettings to fetch.
     */
    where?: ReceiptSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptSettings to fetch.
     */
    orderBy?: ReceiptSettingsOrderByWithRelationInput | ReceiptSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceiptSettings.
     */
    cursor?: ReceiptSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceiptSettings.
     */
    distinct?: ReceiptSettingsScalarFieldEnum | ReceiptSettingsScalarFieldEnum[]
  }

  /**
   * ReceiptSettings findFirstOrThrow
   */
  export type ReceiptSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ReceiptSettings to fetch.
     */
    where?: ReceiptSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptSettings to fetch.
     */
    orderBy?: ReceiptSettingsOrderByWithRelationInput | ReceiptSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceiptSettings.
     */
    cursor?: ReceiptSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceiptSettings.
     */
    distinct?: ReceiptSettingsScalarFieldEnum | ReceiptSettingsScalarFieldEnum[]
  }

  /**
   * ReceiptSettings findMany
   */
  export type ReceiptSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * Filter, which ReceiptSettings to fetch.
     */
    where?: ReceiptSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptSettings to fetch.
     */
    orderBy?: ReceiptSettingsOrderByWithRelationInput | ReceiptSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceiptSettings.
     */
    cursor?: ReceiptSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptSettings.
     */
    skip?: number
    distinct?: ReceiptSettingsScalarFieldEnum | ReceiptSettingsScalarFieldEnum[]
  }

  /**
   * ReceiptSettings create
   */
  export type ReceiptSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a ReceiptSettings.
     */
    data: XOR<ReceiptSettingsCreateInput, ReceiptSettingsUncheckedCreateInput>
  }

  /**
   * ReceiptSettings createMany
   */
  export type ReceiptSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceiptSettings.
     */
    data: ReceiptSettingsCreateManyInput | ReceiptSettingsCreateManyInput[]
  }

  /**
   * ReceiptSettings createManyAndReturn
   */
  export type ReceiptSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many ReceiptSettings.
     */
    data: ReceiptSettingsCreateManyInput | ReceiptSettingsCreateManyInput[]
  }

  /**
   * ReceiptSettings update
   */
  export type ReceiptSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a ReceiptSettings.
     */
    data: XOR<ReceiptSettingsUpdateInput, ReceiptSettingsUncheckedUpdateInput>
    /**
     * Choose, which ReceiptSettings to update.
     */
    where: ReceiptSettingsWhereUniqueInput
  }

  /**
   * ReceiptSettings updateMany
   */
  export type ReceiptSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceiptSettings.
     */
    data: XOR<ReceiptSettingsUpdateManyMutationInput, ReceiptSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ReceiptSettings to update
     */
    where?: ReceiptSettingsWhereInput
    /**
     * Limit how many ReceiptSettings to update.
     */
    limit?: number
  }

  /**
   * ReceiptSettings updateManyAndReturn
   */
  export type ReceiptSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * The data used to update ReceiptSettings.
     */
    data: XOR<ReceiptSettingsUpdateManyMutationInput, ReceiptSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ReceiptSettings to update
     */
    where?: ReceiptSettingsWhereInput
    /**
     * Limit how many ReceiptSettings to update.
     */
    limit?: number
  }

  /**
   * ReceiptSettings upsert
   */
  export type ReceiptSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the ReceiptSettings to update in case it exists.
     */
    where: ReceiptSettingsWhereUniqueInput
    /**
     * In case the ReceiptSettings found by the `where` argument doesn't exist, create a new ReceiptSettings with this data.
     */
    create: XOR<ReceiptSettingsCreateInput, ReceiptSettingsUncheckedCreateInput>
    /**
     * In case the ReceiptSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptSettingsUpdateInput, ReceiptSettingsUncheckedUpdateInput>
  }

  /**
   * ReceiptSettings delete
   */
  export type ReceiptSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
    /**
     * Filter which ReceiptSettings to delete.
     */
    where: ReceiptSettingsWhereUniqueInput
  }

  /**
   * ReceiptSettings deleteMany
   */
  export type ReceiptSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceiptSettings to delete
     */
    where?: ReceiptSettingsWhereInput
    /**
     * Limit how many ReceiptSettings to delete.
     */
    limit?: number
  }

  /**
   * ReceiptSettings without action
   */
  export type ReceiptSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptSettings
     */
    select?: ReceiptSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptSettings
     */
    omit?: ReceiptSettingsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SuperAdminScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    email: 'email',
    password: 'password',
    role: 'role',
    lastLogin: 'lastLogin',
    sync: 'sync',
    syncedAt: 'syncedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type SuperAdminScalarFieldEnum = (typeof SuperAdminScalarFieldEnum)[keyof typeof SuperAdminScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    userName: 'userName',
    phoneNumber: 'phoneNumber',
    password: 'password',
    role: 'role',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sync: 'sync',
    syncedAt: 'syncedAt',
    isDeleted: 'isDeleted'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    setting_id: 'setting_id',
    companyName: 'companyName',
    companyEmail: 'companyEmail',
    phoneNumber: 'phoneNumber',
    websiteURL: 'websiteURL',
    address: 'address',
    logoUrl: 'logoUrl',
    defaultCurrency: 'defaultCurrency',
    taxRate: 'taxRate',
    mode: 'mode',
    itermsPerPage: 'itermsPerPage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sync: 'sync',
    syncedAt: 'syncedAt',
    isDeleted: 'isDeleted'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    matricNumber: 'matricNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    otherNames: 'otherNames',
    email: 'email',
    phone: 'phone',
    department: 'department',
    level: 'level',
    faculty: 'faculty',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    bloodGroup: 'bloodGroup',
    genotype: 'genotype',
    allergies: 'allergies',
    chronicConditions: 'chronicConditions',
    emergencyContact: 'emergencyContact',
    emergencyPhone: 'emergencyPhone',
    emergencyRelationship: 'emergencyRelationship',
    profilePhoto: 'profilePhoto',
    address: 'address',
    stateOfOrigin: 'stateOfOrigin',
    nationality: 'nationality',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sync: 'sync',
    isDeleted: 'isDeleted'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const PhysicianScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    firstName: 'firstName',
    lastName: 'lastName',
    otherNames: 'otherNames',
    specialization: 'specialization',
    qualification: 'qualification',
    licenseNumber: 'licenseNumber',
    email: 'email',
    phone: 'phone',
    profilePhoto: 'profilePhoto',
    isActive: 'isActive',
    isAvailable: 'isAvailable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sync: 'sync',
    isDeleted: 'isDeleted'
  };

  export type PhysicianScalarFieldEnum = (typeof PhysicianScalarFieldEnum)[keyof typeof PhysicianScalarFieldEnum]


  export const QueueScalarFieldEnum: {
    id: 'id',
    queueNumber: 'queueNumber',
    studentId: 'studentId',
    priority: 'priority',
    status: 'status',
    checkInTime: 'checkInTime',
    calledTime: 'calledTime',
    completedTime: 'completedTime',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type QueueScalarFieldEnum = (typeof QueueScalarFieldEnum)[keyof typeof QueueScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    appointmentNo: 'appointmentNo',
    studentId: 'studentId',
    physicianId: 'physicianId',
    appointmentDate: 'appointmentDate',
    appointmentTime: 'appointmentTime',
    reason: 'reason',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const VitalSignsScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    consultationId: 'consultationId',
    temperature: 'temperature',
    bloodPressure: 'bloodPressure',
    pulse: 'pulse',
    respiratoryRate: 'respiratoryRate',
    weight: 'weight',
    height: 'height',
    bmi: 'bmi',
    oxygenSaturation: 'oxygenSaturation',
    recordedBy: 'recordedBy',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted'
  };

  export type VitalSignsScalarFieldEnum = (typeof VitalSignsScalarFieldEnum)[keyof typeof VitalSignsScalarFieldEnum]


  export const ConsultationScalarFieldEnum: {
    id: 'id',
    consultationNo: 'consultationNo',
    studentId: 'studentId',
    physicianId: 'physicianId',
    chiefComplaint: 'chiefComplaint',
    historyOfPresenting: 'historyOfPresenting',
    symptoms: 'symptoms',
    physicalExamination: 'physicalExamination',
    diagnosis: 'diagnosis',
    differentialDiagnosis: 'differentialDiagnosis',
    treatmentPlan: 'treatmentPlan',
    notes: 'notes',
    followUpDate: 'followUpDate',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    isDeleted: 'isDeleted'
  };

  export type ConsultationScalarFieldEnum = (typeof ConsultationScalarFieldEnum)[keyof typeof ConsultationScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    prescriptionNo: 'prescriptionNo',
    studentId: 'studentId',
    physicianId: 'physicianId',
    consultationId: 'consultationId',
    diagnosis: 'diagnosis',
    instructions: 'instructions',
    status: 'status',
    priority: 'priority',
    isPaid: 'isPaid',
    isDispensed: 'isDispensed',
    dispensedBy: 'dispensedBy',
    dispensedAt: 'dispensedAt',
    totalCost: 'totalCost',
    amountPaid: 'amountPaid',
    discount: 'discount',
    pharmacyNotified: 'pharmacyNotified',
    notifiedAt: 'notifiedAt',
    studentNotified: 'studentNotified',
    validUntil: 'validUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sync: 'sync',
    isDeleted: 'isDeleted'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const PrescriptionItemScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    productId: 'productId',
    drugName: 'drugName',
    dosage: 'dosage',
    frequency: 'frequency',
    duration: 'duration',
    route: 'route',
    instructions: 'instructions',
    quantityPrescribed: 'quantityPrescribed',
    quantityDispensed: 'quantityDispensed',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    isDispensed: 'isDispensed',
    dispensedAt: 'dispensedAt',
    dispensedBy: 'dispensedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type PrescriptionItemScalarFieldEnum = (typeof PrescriptionItemScalarFieldEnum)[keyof typeof PrescriptionItemScalarFieldEnum]


  export const DrugDispensalScalarFieldEnum: {
    id: 'id',
    dispensalNo: 'dispensalNo',
    prescriptionId: 'prescriptionId',
    prescriptionNo: 'prescriptionNo',
    studentId: 'studentId',
    dispensedBy: 'dispensedBy',
    dispensedItems: 'dispensedItems',
    totalAmount: 'totalAmount',
    notes: 'notes',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted'
  };

  export type DrugDispensalScalarFieldEnum = (typeof DrugDispensalScalarFieldEnum)[keyof typeof DrugDispensalScalarFieldEnum]


  export const MedicalRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    recordType: 'recordType',
    title: 'title',
    description: 'description',
    recordData: 'recordData',
    attachments: 'attachments',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type MedicalRecordScalarFieldEnum = (typeof MedicalRecordScalarFieldEnum)[keyof typeof MedicalRecordScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    barcode: 'barcode',
    genericName: 'genericName',
    brandName: 'brandName',
    category: 'category',
    manufacturer: 'manufacturer',
    batchNumber: 'batchNumber',
    expiryDate: 'expiryDate',
    wholeSalePrice: 'wholeSalePrice',
    retailPrice: 'retailPrice',
    cost: 'cost',
    quantity: 'quantity',
    reorderLevel: 'reorderLevel',
    maxStockLevel: 'maxStockLevel',
    taxRate: 'taxRate',
    unit: 'unit',
    description: 'description',
    dosageForm: 'dosageForm',
    strength: 'strength',
    requiresPrescription: 'requiresPrescription',
    controlledSubstance: 'controlledSubstance',
    storageConditions: 'storageConditions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    taxRate: 'taxRate',
    subTotal: 'subTotal',
    notes: 'notes',
    amountPaid: 'amountPaid',
    grandTotal: 'grandTotal',
    paidAmount: 'paidAmount',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referenceNo: 'referenceNo',
    supplierId: 'supplierId',
    isDeleted: 'isDeleted'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const PurchaseItemScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    cost: 'cost',
    productName: 'productName',
    selectedPrice: 'selectedPrice',
    priceType: 'priceType',
    quantity: 'quantity',
    discount: 'discount',
    total: 'total',
    profit: 'profit',
    sync: 'sync',
    syncedAt: 'syncedAt',
    purchaseId: 'purchaseId',
    customRetailPrice: 'customRetailPrice',
    customWholesalePrice: 'customWholesalePrice',
    expiryDate: 'expiryDate',
    batchNumber: 'batchNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type PurchaseItemScalarFieldEnum = (typeof PurchaseItemScalarFieldEnum)[keyof typeof PurchaseItemScalarFieldEnum]


  export const BalanceTransactionScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    amount: 'amount',
    type: 'type',
    description: 'description',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    prescriptionId: 'prescriptionId',
    balanceAfter: 'balanceAfter',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type BalanceTransactionScalarFieldEnum = (typeof BalanceTransactionScalarFieldEnum)[keyof typeof BalanceTransactionScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    companyName: 'companyName',
    email: 'email',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const ReceiptSettingsScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    businessName: 'businessName',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    phone: 'phone',
    email: 'email',
    website: 'website',
    receiptTitle: 'receiptTitle',
    headerMessage: 'headerMessage',
    footerMessage: 'footerMessage',
    showLogo: 'showLogo',
    logoUrl: 'logoUrl',
    showQrCode: 'showQrCode',
    qrCodeContent: 'qrCodeContent',
    customQrContent: 'customQrContent',
    showStudentInfo: 'showStudentInfo',
    showPhysicianInfo: 'showPhysicianInfo',
    showPharmacistInfo: 'showPharmacistInfo',
    showDrugCodes: 'showDrugCodes',
    showDrugDescriptions: 'showDrugDescriptions',
    showDosageInstructions: 'showDosageInstructions',
    showTimestamp: 'showTimestamp',
    use24HourFormat: 'use24HourFormat',
    paperSize: 'paperSize',
    fontSize: 'fontSize',
    printDensity: 'printDensity',
    lineSpacing: 'lineSpacing',
    primaryColor: 'primaryColor',
    accentColor: 'accentColor',
    fontFamily: 'fontFamily',
    printCopyCount: 'printCopyCount',
    autoPrint: 'autoPrint',
    language: 'language',
    currency: 'currency',
    currencySymbol: 'currencySymbol',
    currencyPosition: 'currencyPosition',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sync: 'sync',
    syncedAt: 'syncedAt',
    isDeleted: 'isDeleted'
  };

  export type ReceiptSettingsScalarFieldEnum = (typeof ReceiptSettingsScalarFieldEnum)[keyof typeof ReceiptSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'role'
   */
  export type EnumroleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'role'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'mode'
   */
  export type EnummodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'mode'>
    


  /**
   * Reference to a field of type 'priority'
   */
  export type EnumpriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'priority'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'consultationStatus'
   */
  export type EnumconsultationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'consultationStatus'>
    


  /**
   * Reference to a field of type 'prescriptionStatus'
   */
  export type EnumprescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'prescriptionStatus'>
    


  /**
   * Reference to a field of type 'unit'
   */
  export type EnumunitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'unit'>
    
  /**
   * Deep Input Types
   */


  export type superAdminWhereInput = {
    AND?: superAdminWhereInput | superAdminWhereInput[]
    OR?: superAdminWhereInput[]
    NOT?: superAdminWhereInput | superAdminWhereInput[]
    id?: StringFilter<"superAdmin"> | string
    userName?: StringFilter<"superAdmin"> | string
    email?: StringFilter<"superAdmin"> | string
    password?: StringFilter<"superAdmin"> | string
    role?: StringFilter<"superAdmin"> | string
    lastLogin?: DateTimeNullableFilter<"superAdmin"> | Date | string | null
    sync?: BoolFilter<"superAdmin"> | boolean
    syncedAt?: DateTimeNullableFilter<"superAdmin"> | Date | string | null
    createdAt?: DateTimeFilter<"superAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"superAdmin"> | Date | string
    isDeleted?: BoolFilter<"superAdmin"> | boolean
  }

  export type superAdminOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type superAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: superAdminWhereInput | superAdminWhereInput[]
    OR?: superAdminWhereInput[]
    NOT?: superAdminWhereInput | superAdminWhereInput[]
    userName?: StringFilter<"superAdmin"> | string
    password?: StringFilter<"superAdmin"> | string
    role?: StringFilter<"superAdmin"> | string
    lastLogin?: DateTimeNullableFilter<"superAdmin"> | Date | string | null
    sync?: BoolFilter<"superAdmin"> | boolean
    syncedAt?: DateTimeNullableFilter<"superAdmin"> | Date | string | null
    createdAt?: DateTimeFilter<"superAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"superAdmin"> | Date | string
    isDeleted?: BoolFilter<"superAdmin"> | boolean
  }, "id" | "email">

  export type superAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: superAdminCountOrderByAggregateInput
    _max?: superAdminMaxOrderByAggregateInput
    _min?: superAdminMinOrderByAggregateInput
  }

  export type superAdminScalarWhereWithAggregatesInput = {
    AND?: superAdminScalarWhereWithAggregatesInput | superAdminScalarWhereWithAggregatesInput[]
    OR?: superAdminScalarWhereWithAggregatesInput[]
    NOT?: superAdminScalarWhereWithAggregatesInput | superAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"superAdmin"> | string
    userName?: StringWithAggregatesFilter<"superAdmin"> | string
    email?: StringWithAggregatesFilter<"superAdmin"> | string
    password?: StringWithAggregatesFilter<"superAdmin"> | string
    role?: StringWithAggregatesFilter<"superAdmin"> | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"superAdmin"> | Date | string | null
    sync?: BoolWithAggregatesFilter<"superAdmin"> | boolean
    syncedAt?: DateTimeNullableWithAggregatesFilter<"superAdmin"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"superAdmin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"superAdmin"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"superAdmin"> | boolean
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    userName?: StringFilter<"users"> | string
    phoneNumber?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: EnumroleFilter<"users"> | $Enums.role
    lastLogin?: DateTimeNullableFilter<"users"> | Date | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    sync?: BoolFilter<"users"> | boolean
    syncedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    isDeleted?: BoolFilter<"users"> | boolean
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userName?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    email?: StringFilter<"users"> | string
    phoneNumber?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: EnumroleFilter<"users"> | $Enums.role
    lastLogin?: DateTimeNullableFilter<"users"> | Date | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    sync?: BoolFilter<"users"> | boolean
    syncedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    isDeleted?: BoolFilter<"users"> | boolean
  }, "id" | "userName">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    userName?: StringWithAggregatesFilter<"users"> | string
    phoneNumber?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    role?: EnumroleWithAggregatesFilter<"users"> | $Enums.role
    lastLogin?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    sync?: BoolWithAggregatesFilter<"users"> | boolean
    syncedAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"users"> | boolean
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    setting_id?: IntFilter<"Settings"> | number
    companyName?: StringFilter<"Settings"> | string
    companyEmail?: StringFilter<"Settings"> | string
    phoneNumber?: StringFilter<"Settings"> | string
    websiteURL?: StringFilter<"Settings"> | string
    address?: StringFilter<"Settings"> | string
    logoUrl?: StringFilter<"Settings"> | string
    defaultCurrency?: StringFilter<"Settings"> | string
    taxRate?: IntFilter<"Settings"> | number
    mode?: EnummodeFilter<"Settings"> | $Enums.mode
    itermsPerPage?: IntFilter<"Settings"> | number
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    sync?: BoolFilter<"Settings"> | boolean
    syncedAt?: DateTimeNullableFilter<"Settings"> | Date | string | null
    isDeleted?: BoolFilter<"Settings"> | boolean
  }

  export type SettingsOrderByWithRelationInput = {
    setting_id?: SortOrder
    companyName?: SortOrder
    companyEmail?: SortOrder
    phoneNumber?: SortOrder
    websiteURL?: SortOrder
    address?: SortOrder
    logoUrl?: SortOrder
    defaultCurrency?: SortOrder
    taxRate?: SortOrder
    mode?: SortOrder
    itermsPerPage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    setting_id?: number
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    companyName?: StringFilter<"Settings"> | string
    companyEmail?: StringFilter<"Settings"> | string
    phoneNumber?: StringFilter<"Settings"> | string
    websiteURL?: StringFilter<"Settings"> | string
    address?: StringFilter<"Settings"> | string
    logoUrl?: StringFilter<"Settings"> | string
    defaultCurrency?: StringFilter<"Settings"> | string
    taxRate?: IntFilter<"Settings"> | number
    mode?: EnummodeFilter<"Settings"> | $Enums.mode
    itermsPerPage?: IntFilter<"Settings"> | number
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    sync?: BoolFilter<"Settings"> | boolean
    syncedAt?: DateTimeNullableFilter<"Settings"> | Date | string | null
    isDeleted?: BoolFilter<"Settings"> | boolean
  }, "setting_id">

  export type SettingsOrderByWithAggregationInput = {
    setting_id?: SortOrder
    companyName?: SortOrder
    companyEmail?: SortOrder
    phoneNumber?: SortOrder
    websiteURL?: SortOrder
    address?: SortOrder
    logoUrl?: SortOrder
    defaultCurrency?: SortOrder
    taxRate?: SortOrder
    mode?: SortOrder
    itermsPerPage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    setting_id?: IntWithAggregatesFilter<"Settings"> | number
    companyName?: StringWithAggregatesFilter<"Settings"> | string
    companyEmail?: StringWithAggregatesFilter<"Settings"> | string
    phoneNumber?: StringWithAggregatesFilter<"Settings"> | string
    websiteURL?: StringWithAggregatesFilter<"Settings"> | string
    address?: StringWithAggregatesFilter<"Settings"> | string
    logoUrl?: StringWithAggregatesFilter<"Settings"> | string
    defaultCurrency?: StringWithAggregatesFilter<"Settings"> | string
    taxRate?: IntWithAggregatesFilter<"Settings"> | number
    mode?: EnummodeWithAggregatesFilter<"Settings"> | $Enums.mode
    itermsPerPage?: IntWithAggregatesFilter<"Settings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    sync?: BoolWithAggregatesFilter<"Settings"> | boolean
    syncedAt?: DateTimeNullableWithAggregatesFilter<"Settings"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Settings"> | boolean
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    matricNumber?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    otherNames?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    department?: StringFilter<"Student"> | string
    level?: StringFilter<"Student"> | string
    faculty?: StringFilter<"Student"> | string
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    gender?: StringFilter<"Student"> | string
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    genotype?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    chronicConditions?: StringNullableFilter<"Student"> | string | null
    emergencyContact?: StringFilter<"Student"> | string
    emergencyPhone?: StringFilter<"Student"> | string
    emergencyRelationship?: StringNullableFilter<"Student"> | string | null
    profilePhoto?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    stateOfOrigin?: StringNullableFilter<"Student"> | string | null
    nationality?: StringNullableFilter<"Student"> | string | null
    isActive?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    sync?: BoolFilter<"Student"> | boolean
    isDeleted?: BoolFilter<"Student"> | boolean
    consultations?: ConsultationListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    drugDispensals?: DrugDispensalListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    vitalSigns?: VitalSignsListRelationFilter
    appointments?: AppointmentListRelationFilter
    queue?: QueueListRelationFilter
    balanceTransaction?: BalanceTransactionListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    matricNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    department?: SortOrder
    level?: SortOrder
    faculty?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    genotype?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    chronicConditions?: SortOrderInput | SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    emergencyRelationship?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    stateOfOrigin?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
    consultations?: ConsultationOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    drugDispensals?: DrugDispensalOrderByRelationAggregateInput
    medicalRecords?: MedicalRecordOrderByRelationAggregateInput
    vitalSigns?: VitalSignsOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    queue?: QueueOrderByRelationAggregateInput
    balanceTransaction?: BalanceTransactionOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    matricNumber?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    otherNames?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    department?: StringFilter<"Student"> | string
    level?: StringFilter<"Student"> | string
    faculty?: StringFilter<"Student"> | string
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    gender?: StringFilter<"Student"> | string
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    genotype?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    chronicConditions?: StringNullableFilter<"Student"> | string | null
    emergencyContact?: StringFilter<"Student"> | string
    emergencyPhone?: StringFilter<"Student"> | string
    emergencyRelationship?: StringNullableFilter<"Student"> | string | null
    profilePhoto?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    stateOfOrigin?: StringNullableFilter<"Student"> | string | null
    nationality?: StringNullableFilter<"Student"> | string | null
    isActive?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    sync?: BoolFilter<"Student"> | boolean
    isDeleted?: BoolFilter<"Student"> | boolean
    consultations?: ConsultationListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    drugDispensals?: DrugDispensalListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    vitalSigns?: VitalSignsListRelationFilter
    appointments?: AppointmentListRelationFilter
    queue?: QueueListRelationFilter
    balanceTransaction?: BalanceTransactionListRelationFilter
  }, "id" | "matricNumber">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    matricNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    department?: SortOrder
    level?: SortOrder
    faculty?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    genotype?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    chronicConditions?: SortOrderInput | SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    emergencyRelationship?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    stateOfOrigin?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    matricNumber?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    otherNames?: StringNullableWithAggregatesFilter<"Student"> | string | null
    email?: StringNullableWithAggregatesFilter<"Student"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Student"> | string | null
    department?: StringWithAggregatesFilter<"Student"> | string
    level?: StringWithAggregatesFilter<"Student"> | string
    faculty?: StringWithAggregatesFilter<"Student"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    gender?: StringWithAggregatesFilter<"Student"> | string
    bloodGroup?: StringNullableWithAggregatesFilter<"Student"> | string | null
    genotype?: StringNullableWithAggregatesFilter<"Student"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"Student"> | string | null
    chronicConditions?: StringNullableWithAggregatesFilter<"Student"> | string | null
    emergencyContact?: StringWithAggregatesFilter<"Student"> | string
    emergencyPhone?: StringWithAggregatesFilter<"Student"> | string
    emergencyRelationship?: StringNullableWithAggregatesFilter<"Student"> | string | null
    profilePhoto?: StringNullableWithAggregatesFilter<"Student"> | string | null
    address?: StringNullableWithAggregatesFilter<"Student"> | string | null
    stateOfOrigin?: StringNullableWithAggregatesFilter<"Student"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Student"> | string | null
    isActive?: BoolWithAggregatesFilter<"Student"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    sync?: BoolWithAggregatesFilter<"Student"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Student"> | boolean
  }

  export type PhysicianWhereInput = {
    AND?: PhysicianWhereInput | PhysicianWhereInput[]
    OR?: PhysicianWhereInput[]
    NOT?: PhysicianWhereInput | PhysicianWhereInput[]
    id?: StringFilter<"Physician"> | string
    staffId?: StringFilter<"Physician"> | string
    firstName?: StringFilter<"Physician"> | string
    lastName?: StringFilter<"Physician"> | string
    otherNames?: StringNullableFilter<"Physician"> | string | null
    specialization?: StringFilter<"Physician"> | string
    qualification?: StringFilter<"Physician"> | string
    licenseNumber?: StringFilter<"Physician"> | string
    email?: StringFilter<"Physician"> | string
    phone?: StringFilter<"Physician"> | string
    profilePhoto?: StringNullableFilter<"Physician"> | string | null
    isActive?: BoolFilter<"Physician"> | boolean
    isAvailable?: BoolFilter<"Physician"> | boolean
    createdAt?: DateTimeFilter<"Physician"> | Date | string
    updatedAt?: DateTimeFilter<"Physician"> | Date | string
    sync?: BoolFilter<"Physician"> | boolean
    isDeleted?: BoolFilter<"Physician"> | boolean
    consultations?: ConsultationListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    appointments?: AppointmentListRelationFilter
  }

  export type PhysicianOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    licenseNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
    consultations?: ConsultationOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
  }

  export type PhysicianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    staffId?: string
    AND?: PhysicianWhereInput | PhysicianWhereInput[]
    OR?: PhysicianWhereInput[]
    NOT?: PhysicianWhereInput | PhysicianWhereInput[]
    firstName?: StringFilter<"Physician"> | string
    lastName?: StringFilter<"Physician"> | string
    otherNames?: StringNullableFilter<"Physician"> | string | null
    specialization?: StringFilter<"Physician"> | string
    qualification?: StringFilter<"Physician"> | string
    licenseNumber?: StringFilter<"Physician"> | string
    email?: StringFilter<"Physician"> | string
    phone?: StringFilter<"Physician"> | string
    profilePhoto?: StringNullableFilter<"Physician"> | string | null
    isActive?: BoolFilter<"Physician"> | boolean
    isAvailable?: BoolFilter<"Physician"> | boolean
    createdAt?: DateTimeFilter<"Physician"> | Date | string
    updatedAt?: DateTimeFilter<"Physician"> | Date | string
    sync?: BoolFilter<"Physician"> | boolean
    isDeleted?: BoolFilter<"Physician"> | boolean
    consultations?: ConsultationListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    appointments?: AppointmentListRelationFilter
  }, "id" | "staffId">

  export type PhysicianOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrderInput | SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    licenseNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
    _count?: PhysicianCountOrderByAggregateInput
    _max?: PhysicianMaxOrderByAggregateInput
    _min?: PhysicianMinOrderByAggregateInput
  }

  export type PhysicianScalarWhereWithAggregatesInput = {
    AND?: PhysicianScalarWhereWithAggregatesInput | PhysicianScalarWhereWithAggregatesInput[]
    OR?: PhysicianScalarWhereWithAggregatesInput[]
    NOT?: PhysicianScalarWhereWithAggregatesInput | PhysicianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Physician"> | string
    staffId?: StringWithAggregatesFilter<"Physician"> | string
    firstName?: StringWithAggregatesFilter<"Physician"> | string
    lastName?: StringWithAggregatesFilter<"Physician"> | string
    otherNames?: StringNullableWithAggregatesFilter<"Physician"> | string | null
    specialization?: StringWithAggregatesFilter<"Physician"> | string
    qualification?: StringWithAggregatesFilter<"Physician"> | string
    licenseNumber?: StringWithAggregatesFilter<"Physician"> | string
    email?: StringWithAggregatesFilter<"Physician"> | string
    phone?: StringWithAggregatesFilter<"Physician"> | string
    profilePhoto?: StringNullableWithAggregatesFilter<"Physician"> | string | null
    isActive?: BoolWithAggregatesFilter<"Physician"> | boolean
    isAvailable?: BoolWithAggregatesFilter<"Physician"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Physician"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Physician"> | Date | string
    sync?: BoolWithAggregatesFilter<"Physician"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Physician"> | boolean
  }

  export type QueueWhereInput = {
    AND?: QueueWhereInput | QueueWhereInput[]
    OR?: QueueWhereInput[]
    NOT?: QueueWhereInput | QueueWhereInput[]
    id?: StringFilter<"Queue"> | string
    queueNumber?: IntFilter<"Queue"> | number
    studentId?: StringFilter<"Queue"> | string
    priority?: EnumpriorityFilter<"Queue"> | $Enums.priority
    status?: StringFilter<"Queue"> | string
    checkInTime?: DateTimeFilter<"Queue"> | Date | string
    calledTime?: DateTimeNullableFilter<"Queue"> | Date | string | null
    completedTime?: DateTimeNullableFilter<"Queue"> | Date | string | null
    notes?: StringNullableFilter<"Queue"> | string | null
    createdAt?: DateTimeFilter<"Queue"> | Date | string
    updatedAt?: DateTimeFilter<"Queue"> | Date | string
    isDeleted?: BoolFilter<"Queue"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type QueueOrderByWithRelationInput = {
    id?: SortOrder
    queueNumber?: SortOrder
    studentId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    calledTime?: SortOrderInput | SortOrder
    completedTime?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type QueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueueWhereInput | QueueWhereInput[]
    OR?: QueueWhereInput[]
    NOT?: QueueWhereInput | QueueWhereInput[]
    queueNumber?: IntFilter<"Queue"> | number
    studentId?: StringFilter<"Queue"> | string
    priority?: EnumpriorityFilter<"Queue"> | $Enums.priority
    status?: StringFilter<"Queue"> | string
    checkInTime?: DateTimeFilter<"Queue"> | Date | string
    calledTime?: DateTimeNullableFilter<"Queue"> | Date | string | null
    completedTime?: DateTimeNullableFilter<"Queue"> | Date | string | null
    notes?: StringNullableFilter<"Queue"> | string | null
    createdAt?: DateTimeFilter<"Queue"> | Date | string
    updatedAt?: DateTimeFilter<"Queue"> | Date | string
    isDeleted?: BoolFilter<"Queue"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type QueueOrderByWithAggregationInput = {
    id?: SortOrder
    queueNumber?: SortOrder
    studentId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    calledTime?: SortOrderInput | SortOrder
    completedTime?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: QueueCountOrderByAggregateInput
    _avg?: QueueAvgOrderByAggregateInput
    _max?: QueueMaxOrderByAggregateInput
    _min?: QueueMinOrderByAggregateInput
    _sum?: QueueSumOrderByAggregateInput
  }

  export type QueueScalarWhereWithAggregatesInput = {
    AND?: QueueScalarWhereWithAggregatesInput | QueueScalarWhereWithAggregatesInput[]
    OR?: QueueScalarWhereWithAggregatesInput[]
    NOT?: QueueScalarWhereWithAggregatesInput | QueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Queue"> | string
    queueNumber?: IntWithAggregatesFilter<"Queue"> | number
    studentId?: StringWithAggregatesFilter<"Queue"> | string
    priority?: EnumpriorityWithAggregatesFilter<"Queue"> | $Enums.priority
    status?: StringWithAggregatesFilter<"Queue"> | string
    checkInTime?: DateTimeWithAggregatesFilter<"Queue"> | Date | string
    calledTime?: DateTimeNullableWithAggregatesFilter<"Queue"> | Date | string | null
    completedTime?: DateTimeNullableWithAggregatesFilter<"Queue"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Queue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Queue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Queue"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Queue"> | boolean
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    appointmentNo?: StringFilter<"Appointment"> | string
    studentId?: StringFilter<"Appointment"> | string
    physicianId?: StringNullableFilter<"Appointment"> | string | null
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    appointmentTime?: StringFilter<"Appointment"> | string
    reason?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    isDeleted?: BoolFilter<"Appointment"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    physician?: XOR<PhysicianNullableScalarRelationFilter, PhysicianWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    appointmentNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrderInput | SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    student?: StudentOrderByWithRelationInput
    physician?: PhysicianOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentNo?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    studentId?: StringFilter<"Appointment"> | string
    physicianId?: StringNullableFilter<"Appointment"> | string | null
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    appointmentTime?: StringFilter<"Appointment"> | string
    reason?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    isDeleted?: BoolFilter<"Appointment"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    physician?: XOR<PhysicianNullableScalarRelationFilter, PhysicianWhereInput> | null
  }, "id" | "appointmentNo">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrderInput | SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    appointmentNo?: StringWithAggregatesFilter<"Appointment"> | string
    studentId?: StringWithAggregatesFilter<"Appointment"> | string
    physicianId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    appointmentDate?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    appointmentTime?: StringWithAggregatesFilter<"Appointment"> | string
    reason?: StringWithAggregatesFilter<"Appointment"> | string
    status?: StringWithAggregatesFilter<"Appointment"> | string
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Appointment"> | boolean
  }

  export type VitalSignsWhereInput = {
    AND?: VitalSignsWhereInput | VitalSignsWhereInput[]
    OR?: VitalSignsWhereInput[]
    NOT?: VitalSignsWhereInput | VitalSignsWhereInput[]
    id?: StringFilter<"VitalSigns"> | string
    studentId?: StringFilter<"VitalSigns"> | string
    consultationId?: StringNullableFilter<"VitalSigns"> | string | null
    temperature?: FloatNullableFilter<"VitalSigns"> | number | null
    bloodPressure?: StringNullableFilter<"VitalSigns"> | string | null
    pulse?: IntNullableFilter<"VitalSigns"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    weight?: FloatNullableFilter<"VitalSigns"> | number | null
    height?: FloatNullableFilter<"VitalSigns"> | number | null
    bmi?: FloatNullableFilter<"VitalSigns"> | number | null
    oxygenSaturation?: IntNullableFilter<"VitalSigns"> | number | null
    recordedBy?: StringFilter<"VitalSigns"> | string
    createdAt?: DateTimeFilter<"VitalSigns"> | Date | string
    isDeleted?: BoolFilter<"VitalSigns"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
  }

  export type VitalSignsOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    bloodPressure?: SortOrderInput | SortOrder
    pulse?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    bmi?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    student?: StudentOrderByWithRelationInput
    consultation?: ConsultationOrderByWithRelationInput
  }

  export type VitalSignsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VitalSignsWhereInput | VitalSignsWhereInput[]
    OR?: VitalSignsWhereInput[]
    NOT?: VitalSignsWhereInput | VitalSignsWhereInput[]
    studentId?: StringFilter<"VitalSigns"> | string
    consultationId?: StringNullableFilter<"VitalSigns"> | string | null
    temperature?: FloatNullableFilter<"VitalSigns"> | number | null
    bloodPressure?: StringNullableFilter<"VitalSigns"> | string | null
    pulse?: IntNullableFilter<"VitalSigns"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    weight?: FloatNullableFilter<"VitalSigns"> | number | null
    height?: FloatNullableFilter<"VitalSigns"> | number | null
    bmi?: FloatNullableFilter<"VitalSigns"> | number | null
    oxygenSaturation?: IntNullableFilter<"VitalSigns"> | number | null
    recordedBy?: StringFilter<"VitalSigns"> | string
    createdAt?: DateTimeFilter<"VitalSigns"> | Date | string
    isDeleted?: BoolFilter<"VitalSigns"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    consultation?: XOR<ConsultationNullableScalarRelationFilter, ConsultationWhereInput> | null
  }, "id">

  export type VitalSignsOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    bloodPressure?: SortOrderInput | SortOrder
    pulse?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    bmi?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    _count?: VitalSignsCountOrderByAggregateInput
    _avg?: VitalSignsAvgOrderByAggregateInput
    _max?: VitalSignsMaxOrderByAggregateInput
    _min?: VitalSignsMinOrderByAggregateInput
    _sum?: VitalSignsSumOrderByAggregateInput
  }

  export type VitalSignsScalarWhereWithAggregatesInput = {
    AND?: VitalSignsScalarWhereWithAggregatesInput | VitalSignsScalarWhereWithAggregatesInput[]
    OR?: VitalSignsScalarWhereWithAggregatesInput[]
    NOT?: VitalSignsScalarWhereWithAggregatesInput | VitalSignsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VitalSigns"> | string
    studentId?: StringWithAggregatesFilter<"VitalSigns"> | string
    consultationId?: StringNullableWithAggregatesFilter<"VitalSigns"> | string | null
    temperature?: FloatNullableWithAggregatesFilter<"VitalSigns"> | number | null
    bloodPressure?: StringNullableWithAggregatesFilter<"VitalSigns"> | string | null
    pulse?: IntNullableWithAggregatesFilter<"VitalSigns"> | number | null
    respiratoryRate?: IntNullableWithAggregatesFilter<"VitalSigns"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"VitalSigns"> | number | null
    height?: FloatNullableWithAggregatesFilter<"VitalSigns"> | number | null
    bmi?: FloatNullableWithAggregatesFilter<"VitalSigns"> | number | null
    oxygenSaturation?: IntNullableWithAggregatesFilter<"VitalSigns"> | number | null
    recordedBy?: StringWithAggregatesFilter<"VitalSigns"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VitalSigns"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"VitalSigns"> | boolean
  }

  export type ConsultationWhereInput = {
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    id?: StringFilter<"Consultation"> | string
    consultationNo?: StringFilter<"Consultation"> | string
    studentId?: StringFilter<"Consultation"> | string
    physicianId?: StringFilter<"Consultation"> | string
    chiefComplaint?: StringFilter<"Consultation"> | string
    historyOfPresenting?: StringNullableFilter<"Consultation"> | string | null
    symptoms?: StringFilter<"Consultation"> | string
    physicalExamination?: StringNullableFilter<"Consultation"> | string | null
    diagnosis?: StringFilter<"Consultation"> | string
    differentialDiagnosis?: StringNullableFilter<"Consultation"> | string | null
    treatmentPlan?: StringNullableFilter<"Consultation"> | string | null
    notes?: StringNullableFilter<"Consultation"> | string | null
    followUpDate?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    status?: EnumconsultationStatusFilter<"Consultation"> | $Enums.consultationStatus
    priority?: EnumpriorityFilter<"Consultation"> | $Enums.priority
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    completedAt?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    isDeleted?: BoolFilter<"Consultation"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    physician?: XOR<PhysicianScalarRelationFilter, PhysicianWhereInput>
    vitalSigns?: VitalSignsListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
  }

  export type ConsultationOrderByWithRelationInput = {
    id?: SortOrder
    consultationNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    chiefComplaint?: SortOrder
    historyOfPresenting?: SortOrderInput | SortOrder
    symptoms?: SortOrder
    physicalExamination?: SortOrderInput | SortOrder
    diagnosis?: SortOrder
    differentialDiagnosis?: SortOrderInput | SortOrder
    treatmentPlan?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    followUpDate?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    student?: StudentOrderByWithRelationInput
    physician?: PhysicianOrderByWithRelationInput
    vitalSigns?: VitalSignsOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
  }

  export type ConsultationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    consultationNo?: string
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    studentId?: StringFilter<"Consultation"> | string
    physicianId?: StringFilter<"Consultation"> | string
    chiefComplaint?: StringFilter<"Consultation"> | string
    historyOfPresenting?: StringNullableFilter<"Consultation"> | string | null
    symptoms?: StringFilter<"Consultation"> | string
    physicalExamination?: StringNullableFilter<"Consultation"> | string | null
    diagnosis?: StringFilter<"Consultation"> | string
    differentialDiagnosis?: StringNullableFilter<"Consultation"> | string | null
    treatmentPlan?: StringNullableFilter<"Consultation"> | string | null
    notes?: StringNullableFilter<"Consultation"> | string | null
    followUpDate?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    status?: EnumconsultationStatusFilter<"Consultation"> | $Enums.consultationStatus
    priority?: EnumpriorityFilter<"Consultation"> | $Enums.priority
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    completedAt?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    isDeleted?: BoolFilter<"Consultation"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    physician?: XOR<PhysicianScalarRelationFilter, PhysicianWhereInput>
    vitalSigns?: VitalSignsListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
  }, "id" | "consultationNo">

  export type ConsultationOrderByWithAggregationInput = {
    id?: SortOrder
    consultationNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    chiefComplaint?: SortOrder
    historyOfPresenting?: SortOrderInput | SortOrder
    symptoms?: SortOrder
    physicalExamination?: SortOrderInput | SortOrder
    diagnosis?: SortOrder
    differentialDiagnosis?: SortOrderInput | SortOrder
    treatmentPlan?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    followUpDate?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: ConsultationCountOrderByAggregateInput
    _max?: ConsultationMaxOrderByAggregateInput
    _min?: ConsultationMinOrderByAggregateInput
  }

  export type ConsultationScalarWhereWithAggregatesInput = {
    AND?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    OR?: ConsultationScalarWhereWithAggregatesInput[]
    NOT?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Consultation"> | string
    consultationNo?: StringWithAggregatesFilter<"Consultation"> | string
    studentId?: StringWithAggregatesFilter<"Consultation"> | string
    physicianId?: StringWithAggregatesFilter<"Consultation"> | string
    chiefComplaint?: StringWithAggregatesFilter<"Consultation"> | string
    historyOfPresenting?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    symptoms?: StringWithAggregatesFilter<"Consultation"> | string
    physicalExamination?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    diagnosis?: StringWithAggregatesFilter<"Consultation"> | string
    differentialDiagnosis?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    treatmentPlan?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    followUpDate?: DateTimeNullableWithAggregatesFilter<"Consultation"> | Date | string | null
    status?: EnumconsultationStatusWithAggregatesFilter<"Consultation"> | $Enums.consultationStatus
    priority?: EnumpriorityWithAggregatesFilter<"Consultation"> | $Enums.priority
    createdAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Consultation"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Consultation"> | boolean
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: StringFilter<"Prescription"> | string
    prescriptionNo?: StringFilter<"Prescription"> | string
    studentId?: StringFilter<"Prescription"> | string
    physicianId?: StringFilter<"Prescription"> | string
    consultationId?: StringFilter<"Prescription"> | string
    diagnosis?: StringFilter<"Prescription"> | string
    instructions?: StringNullableFilter<"Prescription"> | string | null
    status?: EnumprescriptionStatusFilter<"Prescription"> | $Enums.prescriptionStatus
    priority?: EnumpriorityFilter<"Prescription"> | $Enums.priority
    isPaid?: BoolFilter<"Prescription"> | boolean
    isDispensed?: BoolFilter<"Prescription"> | boolean
    dispensedBy?: StringNullableFilter<"Prescription"> | string | null
    dispensedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    totalCost?: FloatFilter<"Prescription"> | number
    amountPaid?: FloatFilter<"Prescription"> | number
    discount?: FloatFilter<"Prescription"> | number
    pharmacyNotified?: BoolFilter<"Prescription"> | boolean
    notifiedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    studentNotified?: BoolFilter<"Prescription"> | boolean
    validUntil?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    sync?: BoolFilter<"Prescription"> | boolean
    isDeleted?: BoolFilter<"Prescription"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    physician?: XOR<PhysicianScalarRelationFilter, PhysicianWhereInput>
    consultation?: XOR<ConsultationScalarRelationFilter, ConsultationWhereInput>
    prescriptionItems?: PrescriptionItemListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    consultationId?: SortOrder
    diagnosis?: SortOrder
    instructions?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    isPaid?: SortOrder
    isDispensed?: SortOrder
    dispensedBy?: SortOrderInput | SortOrder
    dispensedAt?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    amountPaid?: SortOrder
    discount?: SortOrder
    pharmacyNotified?: SortOrder
    notifiedAt?: SortOrderInput | SortOrder
    studentNotified?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
    student?: StudentOrderByWithRelationInput
    physician?: PhysicianOrderByWithRelationInput
    consultation?: ConsultationOrderByWithRelationInput
    prescriptionItems?: PrescriptionItemOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    prescriptionNo?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    studentId?: StringFilter<"Prescription"> | string
    physicianId?: StringFilter<"Prescription"> | string
    consultationId?: StringFilter<"Prescription"> | string
    diagnosis?: StringFilter<"Prescription"> | string
    instructions?: StringNullableFilter<"Prescription"> | string | null
    status?: EnumprescriptionStatusFilter<"Prescription"> | $Enums.prescriptionStatus
    priority?: EnumpriorityFilter<"Prescription"> | $Enums.priority
    isPaid?: BoolFilter<"Prescription"> | boolean
    isDispensed?: BoolFilter<"Prescription"> | boolean
    dispensedBy?: StringNullableFilter<"Prescription"> | string | null
    dispensedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    totalCost?: FloatFilter<"Prescription"> | number
    amountPaid?: FloatFilter<"Prescription"> | number
    discount?: FloatFilter<"Prescription"> | number
    pharmacyNotified?: BoolFilter<"Prescription"> | boolean
    notifiedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    studentNotified?: BoolFilter<"Prescription"> | boolean
    validUntil?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    sync?: BoolFilter<"Prescription"> | boolean
    isDeleted?: BoolFilter<"Prescription"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    physician?: XOR<PhysicianScalarRelationFilter, PhysicianWhereInput>
    consultation?: XOR<ConsultationScalarRelationFilter, ConsultationWhereInput>
    prescriptionItems?: PrescriptionItemListRelationFilter
  }, "id" | "prescriptionNo">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    consultationId?: SortOrder
    diagnosis?: SortOrder
    instructions?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    isPaid?: SortOrder
    isDispensed?: SortOrder
    dispensedBy?: SortOrderInput | SortOrder
    dispensedAt?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    amountPaid?: SortOrder
    discount?: SortOrder
    pharmacyNotified?: SortOrder
    notifiedAt?: SortOrderInput | SortOrder
    studentNotified?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prescription"> | string
    prescriptionNo?: StringWithAggregatesFilter<"Prescription"> | string
    studentId?: StringWithAggregatesFilter<"Prescription"> | string
    physicianId?: StringWithAggregatesFilter<"Prescription"> | string
    consultationId?: StringWithAggregatesFilter<"Prescription"> | string
    diagnosis?: StringWithAggregatesFilter<"Prescription"> | string
    instructions?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    status?: EnumprescriptionStatusWithAggregatesFilter<"Prescription"> | $Enums.prescriptionStatus
    priority?: EnumpriorityWithAggregatesFilter<"Prescription"> | $Enums.priority
    isPaid?: BoolWithAggregatesFilter<"Prescription"> | boolean
    isDispensed?: BoolWithAggregatesFilter<"Prescription"> | boolean
    dispensedBy?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    dispensedAt?: DateTimeNullableWithAggregatesFilter<"Prescription"> | Date | string | null
    totalCost?: FloatWithAggregatesFilter<"Prescription"> | number
    amountPaid?: FloatWithAggregatesFilter<"Prescription"> | number
    discount?: FloatWithAggregatesFilter<"Prescription"> | number
    pharmacyNotified?: BoolWithAggregatesFilter<"Prescription"> | boolean
    notifiedAt?: DateTimeNullableWithAggregatesFilter<"Prescription"> | Date | string | null
    studentNotified?: BoolWithAggregatesFilter<"Prescription"> | boolean
    validUntil?: DateTimeNullableWithAggregatesFilter<"Prescription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    sync?: BoolWithAggregatesFilter<"Prescription"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Prescription"> | boolean
  }

  export type PrescriptionItemWhereInput = {
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    id?: StringFilter<"PrescriptionItem"> | string
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    productId?: StringFilter<"PrescriptionItem"> | string
    drugName?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    route?: StringNullableFilter<"PrescriptionItem"> | string | null
    instructions?: StringFilter<"PrescriptionItem"> | string
    quantityPrescribed?: IntFilter<"PrescriptionItem"> | number
    quantityDispensed?: IntFilter<"PrescriptionItem"> | number
    unitPrice?: FloatFilter<"PrescriptionItem"> | number
    totalPrice?: FloatFilter<"PrescriptionItem"> | number
    isDispensed?: BoolFilter<"PrescriptionItem"> | boolean
    dispensedAt?: DateTimeNullableFilter<"PrescriptionItem"> | Date | string | null
    dispensedBy?: StringNullableFilter<"PrescriptionItem"> | string | null
    createdAt?: DateTimeFilter<"PrescriptionItem"> | Date | string
    updatedAt?: DateTimeFilter<"PrescriptionItem"> | Date | string
    isDeleted?: BoolFilter<"PrescriptionItem"> | boolean
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PrescriptionItemOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    productId?: SortOrder
    drugName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    route?: SortOrderInput | SortOrder
    instructions?: SortOrder
    quantityPrescribed?: SortOrder
    quantityDispensed?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isDispensed?: SortOrder
    dispensedAt?: SortOrderInput | SortOrder
    dispensedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PrescriptionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    productId?: StringFilter<"PrescriptionItem"> | string
    drugName?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    route?: StringNullableFilter<"PrescriptionItem"> | string | null
    instructions?: StringFilter<"PrescriptionItem"> | string
    quantityPrescribed?: IntFilter<"PrescriptionItem"> | number
    quantityDispensed?: IntFilter<"PrescriptionItem"> | number
    unitPrice?: FloatFilter<"PrescriptionItem"> | number
    totalPrice?: FloatFilter<"PrescriptionItem"> | number
    isDispensed?: BoolFilter<"PrescriptionItem"> | boolean
    dispensedAt?: DateTimeNullableFilter<"PrescriptionItem"> | Date | string | null
    dispensedBy?: StringNullableFilter<"PrescriptionItem"> | string | null
    createdAt?: DateTimeFilter<"PrescriptionItem"> | Date | string
    updatedAt?: DateTimeFilter<"PrescriptionItem"> | Date | string
    isDeleted?: BoolFilter<"PrescriptionItem"> | boolean
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type PrescriptionItemOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    productId?: SortOrder
    drugName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    route?: SortOrderInput | SortOrder
    instructions?: SortOrder
    quantityPrescribed?: SortOrder
    quantityDispensed?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isDispensed?: SortOrder
    dispensedAt?: SortOrderInput | SortOrder
    dispensedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: PrescriptionItemCountOrderByAggregateInput
    _avg?: PrescriptionItemAvgOrderByAggregateInput
    _max?: PrescriptionItemMaxOrderByAggregateInput
    _min?: PrescriptionItemMinOrderByAggregateInput
    _sum?: PrescriptionItemSumOrderByAggregateInput
  }

  export type PrescriptionItemScalarWhereWithAggregatesInput = {
    AND?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    OR?: PrescriptionItemScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    prescriptionId?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    productId?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    drugName?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    dosage?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    frequency?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    duration?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    route?: StringNullableWithAggregatesFilter<"PrescriptionItem"> | string | null
    instructions?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    quantityPrescribed?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    quantityDispensed?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"PrescriptionItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"PrescriptionItem"> | number
    isDispensed?: BoolWithAggregatesFilter<"PrescriptionItem"> | boolean
    dispensedAt?: DateTimeNullableWithAggregatesFilter<"PrescriptionItem"> | Date | string | null
    dispensedBy?: StringNullableWithAggregatesFilter<"PrescriptionItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PrescriptionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrescriptionItem"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"PrescriptionItem"> | boolean
  }

  export type DrugDispensalWhereInput = {
    AND?: DrugDispensalWhereInput | DrugDispensalWhereInput[]
    OR?: DrugDispensalWhereInput[]
    NOT?: DrugDispensalWhereInput | DrugDispensalWhereInput[]
    id?: StringFilter<"DrugDispensal"> | string
    dispensalNo?: StringFilter<"DrugDispensal"> | string
    prescriptionId?: StringFilter<"DrugDispensal"> | string
    prescriptionNo?: StringFilter<"DrugDispensal"> | string
    studentId?: StringFilter<"DrugDispensal"> | string
    dispensedBy?: StringFilter<"DrugDispensal"> | string
    dispensedItems?: StringFilter<"DrugDispensal"> | string
    totalAmount?: FloatFilter<"DrugDispensal"> | number
    notes?: StringNullableFilter<"DrugDispensal"> | string | null
    createdAt?: DateTimeFilter<"DrugDispensal"> | Date | string
    isDeleted?: BoolFilter<"DrugDispensal"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type DrugDispensalOrderByWithRelationInput = {
    id?: SortOrder
    dispensalNo?: SortOrder
    prescriptionId?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    dispensedBy?: SortOrder
    dispensedItems?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type DrugDispensalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dispensalNo?: string
    AND?: DrugDispensalWhereInput | DrugDispensalWhereInput[]
    OR?: DrugDispensalWhereInput[]
    NOT?: DrugDispensalWhereInput | DrugDispensalWhereInput[]
    prescriptionId?: StringFilter<"DrugDispensal"> | string
    prescriptionNo?: StringFilter<"DrugDispensal"> | string
    studentId?: StringFilter<"DrugDispensal"> | string
    dispensedBy?: StringFilter<"DrugDispensal"> | string
    dispensedItems?: StringFilter<"DrugDispensal"> | string
    totalAmount?: FloatFilter<"DrugDispensal"> | number
    notes?: StringNullableFilter<"DrugDispensal"> | string | null
    createdAt?: DateTimeFilter<"DrugDispensal"> | Date | string
    isDeleted?: BoolFilter<"DrugDispensal"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "dispensalNo">

  export type DrugDispensalOrderByWithAggregationInput = {
    id?: SortOrder
    dispensalNo?: SortOrder
    prescriptionId?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    dispensedBy?: SortOrder
    dispensedItems?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    _count?: DrugDispensalCountOrderByAggregateInput
    _avg?: DrugDispensalAvgOrderByAggregateInput
    _max?: DrugDispensalMaxOrderByAggregateInput
    _min?: DrugDispensalMinOrderByAggregateInput
    _sum?: DrugDispensalSumOrderByAggregateInput
  }

  export type DrugDispensalScalarWhereWithAggregatesInput = {
    AND?: DrugDispensalScalarWhereWithAggregatesInput | DrugDispensalScalarWhereWithAggregatesInput[]
    OR?: DrugDispensalScalarWhereWithAggregatesInput[]
    NOT?: DrugDispensalScalarWhereWithAggregatesInput | DrugDispensalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DrugDispensal"> | string
    dispensalNo?: StringWithAggregatesFilter<"DrugDispensal"> | string
    prescriptionId?: StringWithAggregatesFilter<"DrugDispensal"> | string
    prescriptionNo?: StringWithAggregatesFilter<"DrugDispensal"> | string
    studentId?: StringWithAggregatesFilter<"DrugDispensal"> | string
    dispensedBy?: StringWithAggregatesFilter<"DrugDispensal"> | string
    dispensedItems?: StringWithAggregatesFilter<"DrugDispensal"> | string
    totalAmount?: FloatWithAggregatesFilter<"DrugDispensal"> | number
    notes?: StringNullableWithAggregatesFilter<"DrugDispensal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DrugDispensal"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"DrugDispensal"> | boolean
  }

  export type MedicalRecordWhereInput = {
    AND?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    OR?: MedicalRecordWhereInput[]
    NOT?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    id?: StringFilter<"MedicalRecord"> | string
    studentId?: StringFilter<"MedicalRecord"> | string
    recordType?: StringFilter<"MedicalRecord"> | string
    title?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    recordData?: StringNullableFilter<"MedicalRecord"> | string | null
    attachments?: StringNullableFilter<"MedicalRecord"> | string | null
    createdBy?: StringFilter<"MedicalRecord"> | string
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    isDeleted?: BoolFilter<"MedicalRecord"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type MedicalRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    recordData?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type MedicalRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    OR?: MedicalRecordWhereInput[]
    NOT?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    studentId?: StringFilter<"MedicalRecord"> | string
    recordType?: StringFilter<"MedicalRecord"> | string
    title?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    recordData?: StringNullableFilter<"MedicalRecord"> | string | null
    attachments?: StringNullableFilter<"MedicalRecord"> | string | null
    createdBy?: StringFilter<"MedicalRecord"> | string
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    isDeleted?: BoolFilter<"MedicalRecord"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type MedicalRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    recordData?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: MedicalRecordCountOrderByAggregateInput
    _max?: MedicalRecordMaxOrderByAggregateInput
    _min?: MedicalRecordMinOrderByAggregateInput
  }

  export type MedicalRecordScalarWhereWithAggregatesInput = {
    AND?: MedicalRecordScalarWhereWithAggregatesInput | MedicalRecordScalarWhereWithAggregatesInput[]
    OR?: MedicalRecordScalarWhereWithAggregatesInput[]
    NOT?: MedicalRecordScalarWhereWithAggregatesInput | MedicalRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalRecord"> | string
    studentId?: StringWithAggregatesFilter<"MedicalRecord"> | string
    recordType?: StringWithAggregatesFilter<"MedicalRecord"> | string
    title?: StringWithAggregatesFilter<"MedicalRecord"> | string
    description?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    recordData?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    attachments?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    createdBy?: StringWithAggregatesFilter<"MedicalRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicalRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalRecord"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"MedicalRecord"> | boolean
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    barcode?: StringFilter<"Product"> | string
    genericName?: StringNullableFilter<"Product"> | string | null
    brandName?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    manufacturer?: StringNullableFilter<"Product"> | string | null
    batchNumber?: StringNullableFilter<"Product"> | string | null
    expiryDate?: DateTimeNullableFilter<"Product"> | Date | string | null
    wholeSalePrice?: FloatFilter<"Product"> | number
    retailPrice?: FloatFilter<"Product"> | number
    cost?: FloatFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    reorderLevel?: IntNullableFilter<"Product"> | number | null
    maxStockLevel?: IntNullableFilter<"Product"> | number | null
    taxRate?: IntFilter<"Product"> | number
    unit?: EnumunitFilter<"Product"> | $Enums.unit
    description?: StringFilter<"Product"> | string
    dosageForm?: StringNullableFilter<"Product"> | string | null
    strength?: StringNullableFilter<"Product"> | string | null
    requiresPrescription?: BoolFilter<"Product"> | boolean
    controlledSubstance?: BoolFilter<"Product"> | boolean
    storageConditions?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    isDeleted?: BoolFilter<"Product"> | boolean
    prescriptionItems?: PrescriptionItemListRelationFilter
    purchaseItem?: PurchaseItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    genericName?: SortOrderInput | SortOrder
    brandName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    wholeSalePrice?: SortOrder
    retailPrice?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    reorderLevel?: SortOrderInput | SortOrder
    maxStockLevel?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    dosageForm?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    requiresPrescription?: SortOrder
    controlledSubstance?: SortOrder
    storageConditions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    prescriptionItems?: PrescriptionItemOrderByRelationAggregateInput
    purchaseItem?: PurchaseItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    barcode?: StringFilter<"Product"> | string
    genericName?: StringNullableFilter<"Product"> | string | null
    brandName?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    manufacturer?: StringNullableFilter<"Product"> | string | null
    batchNumber?: StringNullableFilter<"Product"> | string | null
    expiryDate?: DateTimeNullableFilter<"Product"> | Date | string | null
    wholeSalePrice?: FloatFilter<"Product"> | number
    retailPrice?: FloatFilter<"Product"> | number
    cost?: FloatFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    reorderLevel?: IntNullableFilter<"Product"> | number | null
    maxStockLevel?: IntNullableFilter<"Product"> | number | null
    taxRate?: IntFilter<"Product"> | number
    unit?: EnumunitFilter<"Product"> | $Enums.unit
    description?: StringFilter<"Product"> | string
    dosageForm?: StringNullableFilter<"Product"> | string | null
    strength?: StringNullableFilter<"Product"> | string | null
    requiresPrescription?: BoolFilter<"Product"> | boolean
    controlledSubstance?: BoolFilter<"Product"> | boolean
    storageConditions?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    isDeleted?: BoolFilter<"Product"> | boolean
    prescriptionItems?: PrescriptionItemListRelationFilter
    purchaseItem?: PurchaseItemListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    genericName?: SortOrderInput | SortOrder
    brandName?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    wholeSalePrice?: SortOrder
    retailPrice?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    reorderLevel?: SortOrderInput | SortOrder
    maxStockLevel?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    dosageForm?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    requiresPrescription?: SortOrder
    controlledSubstance?: SortOrder
    storageConditions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    barcode?: StringWithAggregatesFilter<"Product"> | string
    genericName?: StringNullableWithAggregatesFilter<"Product"> | string | null
    brandName?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"Product"> | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"Product"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    wholeSalePrice?: FloatWithAggregatesFilter<"Product"> | number
    retailPrice?: FloatWithAggregatesFilter<"Product"> | number
    cost?: FloatWithAggregatesFilter<"Product"> | number
    quantity?: IntWithAggregatesFilter<"Product"> | number
    reorderLevel?: IntNullableWithAggregatesFilter<"Product"> | number | null
    maxStockLevel?: IntNullableWithAggregatesFilter<"Product"> | number | null
    taxRate?: IntWithAggregatesFilter<"Product"> | number
    unit?: EnumunitWithAggregatesFilter<"Product"> | $Enums.unit
    description?: StringWithAggregatesFilter<"Product"> | string
    dosageForm?: StringNullableWithAggregatesFilter<"Product"> | string | null
    strength?: StringNullableWithAggregatesFilter<"Product"> | string | null
    requiresPrescription?: BoolWithAggregatesFilter<"Product"> | boolean
    controlledSubstance?: BoolWithAggregatesFilter<"Product"> | boolean
    storageConditions?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Product"> | boolean
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    taxRate?: FloatFilter<"Purchase"> | number
    subTotal?: FloatFilter<"Purchase"> | number
    notes?: StringNullableFilter<"Purchase"> | string | null
    amountPaid?: FloatNullableFilter<"Purchase"> | number | null
    grandTotal?: FloatFilter<"Purchase"> | number
    paidAmount?: FloatFilter<"Purchase"> | number
    balance?: FloatFilter<"Purchase"> | number
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    referenceNo?: StringFilter<"Purchase"> | string
    supplierId?: StringNullableFilter<"Purchase"> | string | null
    isDeleted?: BoolFilter<"Purchase"> | boolean
    purchaseItem?: PurchaseItemListRelationFilter
    Supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    taxRate?: SortOrder
    subTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    grandTotal?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceNo?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    purchaseItem?: PurchaseItemOrderByRelationAggregateInput
    Supplier?: SupplierOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNo?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    taxRate?: FloatFilter<"Purchase"> | number
    subTotal?: FloatFilter<"Purchase"> | number
    notes?: StringNullableFilter<"Purchase"> | string | null
    amountPaid?: FloatNullableFilter<"Purchase"> | number | null
    grandTotal?: FloatFilter<"Purchase"> | number
    paidAmount?: FloatFilter<"Purchase"> | number
    balance?: FloatFilter<"Purchase"> | number
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    supplierId?: StringNullableFilter<"Purchase"> | string | null
    isDeleted?: BoolFilter<"Purchase"> | boolean
    purchaseItem?: PurchaseItemListRelationFilter
    Supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
  }, "id" | "referenceNo">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    taxRate?: SortOrder
    subTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    grandTotal?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceNo?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    taxRate?: FloatWithAggregatesFilter<"Purchase"> | number
    subTotal?: FloatWithAggregatesFilter<"Purchase"> | number
    notes?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    amountPaid?: FloatNullableWithAggregatesFilter<"Purchase"> | number | null
    grandTotal?: FloatWithAggregatesFilter<"Purchase"> | number
    paidAmount?: FloatWithAggregatesFilter<"Purchase"> | number
    balance?: FloatWithAggregatesFilter<"Purchase"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    referenceNo?: StringWithAggregatesFilter<"Purchase"> | string
    supplierId?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Purchase"> | boolean
  }

  export type PurchaseItemWhereInput = {
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    id?: StringFilter<"PurchaseItem"> | string
    productId?: StringNullableFilter<"PurchaseItem"> | string | null
    cost?: FloatFilter<"PurchaseItem"> | number
    productName?: StringNullableFilter<"PurchaseItem"> | string | null
    selectedPrice?: FloatFilter<"PurchaseItem"> | number
    priceType?: StringFilter<"PurchaseItem"> | string
    quantity?: IntFilter<"PurchaseItem"> | number
    discount?: FloatFilter<"PurchaseItem"> | number
    total?: FloatFilter<"PurchaseItem"> | number
    profit?: FloatFilter<"PurchaseItem"> | number
    sync?: BoolFilter<"PurchaseItem"> | boolean
    syncedAt?: DateTimeNullableFilter<"PurchaseItem"> | Date | string | null
    purchaseId?: StringNullableFilter<"PurchaseItem"> | string | null
    customRetailPrice?: FloatNullableFilter<"PurchaseItem"> | number | null
    customWholesalePrice?: FloatNullableFilter<"PurchaseItem"> | number | null
    expiryDate?: DateTimeNullableFilter<"PurchaseItem"> | Date | string | null
    batchNumber?: StringNullableFilter<"PurchaseItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    isDeleted?: BoolFilter<"PurchaseItem"> | boolean
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    Purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
  }

  export type PurchaseItemOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrderInput | SortOrder
    cost?: SortOrder
    productName?: SortOrderInput | SortOrder
    selectedPrice?: SortOrder
    priceType?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    profit?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    customRetailPrice?: SortOrderInput | SortOrder
    customWholesalePrice?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    product?: ProductOrderByWithRelationInput
    Purchase?: PurchaseOrderByWithRelationInput
  }

  export type PurchaseItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    productId?: StringNullableFilter<"PurchaseItem"> | string | null
    cost?: FloatFilter<"PurchaseItem"> | number
    productName?: StringNullableFilter<"PurchaseItem"> | string | null
    selectedPrice?: FloatFilter<"PurchaseItem"> | number
    priceType?: StringFilter<"PurchaseItem"> | string
    quantity?: IntFilter<"PurchaseItem"> | number
    discount?: FloatFilter<"PurchaseItem"> | number
    total?: FloatFilter<"PurchaseItem"> | number
    profit?: FloatFilter<"PurchaseItem"> | number
    sync?: BoolFilter<"PurchaseItem"> | boolean
    syncedAt?: DateTimeNullableFilter<"PurchaseItem"> | Date | string | null
    purchaseId?: StringNullableFilter<"PurchaseItem"> | string | null
    customRetailPrice?: FloatNullableFilter<"PurchaseItem"> | number | null
    customWholesalePrice?: FloatNullableFilter<"PurchaseItem"> | number | null
    expiryDate?: DateTimeNullableFilter<"PurchaseItem"> | Date | string | null
    batchNumber?: StringNullableFilter<"PurchaseItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    isDeleted?: BoolFilter<"PurchaseItem"> | boolean
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    Purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
  }, "id">

  export type PurchaseItemOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrderInput | SortOrder
    cost?: SortOrder
    productName?: SortOrderInput | SortOrder
    selectedPrice?: SortOrder
    priceType?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    profit?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    customRetailPrice?: SortOrderInput | SortOrder
    customWholesalePrice?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: PurchaseItemCountOrderByAggregateInput
    _avg?: PurchaseItemAvgOrderByAggregateInput
    _max?: PurchaseItemMaxOrderByAggregateInput
    _min?: PurchaseItemMinOrderByAggregateInput
    _sum?: PurchaseItemSumOrderByAggregateInput
  }

  export type PurchaseItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseItem"> | string
    productId?: StringNullableWithAggregatesFilter<"PurchaseItem"> | string | null
    cost?: FloatWithAggregatesFilter<"PurchaseItem"> | number
    productName?: StringNullableWithAggregatesFilter<"PurchaseItem"> | string | null
    selectedPrice?: FloatWithAggregatesFilter<"PurchaseItem"> | number
    priceType?: StringWithAggregatesFilter<"PurchaseItem"> | string
    quantity?: IntWithAggregatesFilter<"PurchaseItem"> | number
    discount?: FloatWithAggregatesFilter<"PurchaseItem"> | number
    total?: FloatWithAggregatesFilter<"PurchaseItem"> | number
    profit?: FloatWithAggregatesFilter<"PurchaseItem"> | number
    sync?: BoolWithAggregatesFilter<"PurchaseItem"> | boolean
    syncedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseItem"> | Date | string | null
    purchaseId?: StringNullableWithAggregatesFilter<"PurchaseItem"> | string | null
    customRetailPrice?: FloatNullableWithAggregatesFilter<"PurchaseItem"> | number | null
    customWholesalePrice?: FloatNullableWithAggregatesFilter<"PurchaseItem"> | number | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"PurchaseItem"> | Date | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"PurchaseItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseItem"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"PurchaseItem"> | boolean
  }

  export type BalanceTransactionWhereInput = {
    AND?: BalanceTransactionWhereInput | BalanceTransactionWhereInput[]
    OR?: BalanceTransactionWhereInput[]
    NOT?: BalanceTransactionWhereInput | BalanceTransactionWhereInput[]
    id?: StringFilter<"BalanceTransaction"> | string
    studentId?: StringFilter<"BalanceTransaction"> | string
    amount?: FloatFilter<"BalanceTransaction"> | number
    type?: StringFilter<"BalanceTransaction"> | string
    description?: StringFilter<"BalanceTransaction"> | string
    paymentMethod?: StringNullableFilter<"BalanceTransaction"> | string | null
    reference?: StringNullableFilter<"BalanceTransaction"> | string | null
    prescriptionId?: StringNullableFilter<"BalanceTransaction"> | string | null
    balanceAfter?: FloatFilter<"BalanceTransaction"> | number
    createdAt?: DateTimeFilter<"BalanceTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BalanceTransaction"> | Date | string
    isDeleted?: BoolFilter<"BalanceTransaction"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type BalanceTransactionOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type BalanceTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BalanceTransactionWhereInput | BalanceTransactionWhereInput[]
    OR?: BalanceTransactionWhereInput[]
    NOT?: BalanceTransactionWhereInput | BalanceTransactionWhereInput[]
    studentId?: StringFilter<"BalanceTransaction"> | string
    amount?: FloatFilter<"BalanceTransaction"> | number
    type?: StringFilter<"BalanceTransaction"> | string
    description?: StringFilter<"BalanceTransaction"> | string
    paymentMethod?: StringNullableFilter<"BalanceTransaction"> | string | null
    reference?: StringNullableFilter<"BalanceTransaction"> | string | null
    prescriptionId?: StringNullableFilter<"BalanceTransaction"> | string | null
    balanceAfter?: FloatFilter<"BalanceTransaction"> | number
    createdAt?: DateTimeFilter<"BalanceTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BalanceTransaction"> | Date | string
    isDeleted?: BoolFilter<"BalanceTransaction"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type BalanceTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: BalanceTransactionCountOrderByAggregateInput
    _avg?: BalanceTransactionAvgOrderByAggregateInput
    _max?: BalanceTransactionMaxOrderByAggregateInput
    _min?: BalanceTransactionMinOrderByAggregateInput
    _sum?: BalanceTransactionSumOrderByAggregateInput
  }

  export type BalanceTransactionScalarWhereWithAggregatesInput = {
    AND?: BalanceTransactionScalarWhereWithAggregatesInput | BalanceTransactionScalarWhereWithAggregatesInput[]
    OR?: BalanceTransactionScalarWhereWithAggregatesInput[]
    NOT?: BalanceTransactionScalarWhereWithAggregatesInput | BalanceTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BalanceTransaction"> | string
    studentId?: StringWithAggregatesFilter<"BalanceTransaction"> | string
    amount?: FloatWithAggregatesFilter<"BalanceTransaction"> | number
    type?: StringWithAggregatesFilter<"BalanceTransaction"> | string
    description?: StringWithAggregatesFilter<"BalanceTransaction"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"BalanceTransaction"> | string | null
    reference?: StringNullableWithAggregatesFilter<"BalanceTransaction"> | string | null
    prescriptionId?: StringNullableWithAggregatesFilter<"BalanceTransaction"> | string | null
    balanceAfter?: FloatWithAggregatesFilter<"BalanceTransaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BalanceTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BalanceTransaction"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"BalanceTransaction"> | boolean
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    type?: StringFilter<"Supplier"> | string
    companyName?: StringNullableFilter<"Supplier"> | string | null
    email?: StringFilter<"Supplier"> | string
    address?: StringFilter<"Supplier"> | string
    phone?: StringFilter<"Supplier"> | string
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    isDeleted?: BoolFilter<"Supplier"> | boolean
    purchase?: PurchaseListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    companyName?: SortOrderInput | SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    purchase?: PurchaseOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    type?: StringFilter<"Supplier"> | string
    companyName?: StringNullableFilter<"Supplier"> | string | null
    email?: StringFilter<"Supplier"> | string
    address?: StringFilter<"Supplier"> | string
    phone?: StringFilter<"Supplier"> | string
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    isDeleted?: BoolFilter<"Supplier"> | boolean
    purchase?: PurchaseListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    companyName?: SortOrderInput | SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    type?: StringWithAggregatesFilter<"Supplier"> | string
    companyName?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringWithAggregatesFilter<"Supplier"> | string
    address?: StringWithAggregatesFilter<"Supplier"> | string
    phone?: StringWithAggregatesFilter<"Supplier"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Supplier"> | boolean
  }

  export type ReceiptSettingsWhereInput = {
    AND?: ReceiptSettingsWhereInput | ReceiptSettingsWhereInput[]
    OR?: ReceiptSettingsWhereInput[]
    NOT?: ReceiptSettingsWhereInput | ReceiptSettingsWhereInput[]
    id?: StringFilter<"ReceiptSettings"> | string
    companyName?: StringFilter<"ReceiptSettings"> | string
    businessName?: StringFilter<"ReceiptSettings"> | string
    address?: StringFilter<"ReceiptSettings"> | string
    city?: StringFilter<"ReceiptSettings"> | string
    state?: StringFilter<"ReceiptSettings"> | string
    country?: StringFilter<"ReceiptSettings"> | string
    phone?: StringFilter<"ReceiptSettings"> | string
    email?: StringFilter<"ReceiptSettings"> | string
    website?: StringFilter<"ReceiptSettings"> | string
    receiptTitle?: StringNullableFilter<"ReceiptSettings"> | string | null
    headerMessage?: StringNullableFilter<"ReceiptSettings"> | string | null
    footerMessage?: StringNullableFilter<"ReceiptSettings"> | string | null
    showLogo?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    logoUrl?: StringNullableFilter<"ReceiptSettings"> | string | null
    showQrCode?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    qrCodeContent?: StringNullableFilter<"ReceiptSettings"> | string | null
    customQrContent?: StringNullableFilter<"ReceiptSettings"> | string | null
    showStudentInfo?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showPhysicianInfo?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showPharmacistInfo?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showDrugCodes?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showDrugDescriptions?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showDosageInstructions?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showTimestamp?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    use24HourFormat?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    paperSize?: StringNullableFilter<"ReceiptSettings"> | string | null
    fontSize?: StringNullableFilter<"ReceiptSettings"> | string | null
    printDensity?: StringNullableFilter<"ReceiptSettings"> | string | null
    lineSpacing?: StringNullableFilter<"ReceiptSettings"> | string | null
    primaryColor?: StringNullableFilter<"ReceiptSettings"> | string | null
    accentColor?: StringNullableFilter<"ReceiptSettings"> | string | null
    fontFamily?: StringNullableFilter<"ReceiptSettings"> | string | null
    printCopyCount?: IntNullableFilter<"ReceiptSettings"> | number | null
    autoPrint?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    language?: StringNullableFilter<"ReceiptSettings"> | string | null
    currency?: StringNullableFilter<"ReceiptSettings"> | string | null
    currencySymbol?: StringNullableFilter<"ReceiptSettings"> | string | null
    currencyPosition?: StringNullableFilter<"ReceiptSettings"> | string | null
    createdAt?: DateTimeFilter<"ReceiptSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ReceiptSettings"> | Date | string
    sync?: BoolFilter<"ReceiptSettings"> | boolean
    syncedAt?: DateTimeNullableFilter<"ReceiptSettings"> | Date | string | null
    isDeleted?: BoolFilter<"ReceiptSettings"> | boolean
  }

  export type ReceiptSettingsOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    businessName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    receiptTitle?: SortOrderInput | SortOrder
    headerMessage?: SortOrderInput | SortOrder
    footerMessage?: SortOrderInput | SortOrder
    showLogo?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    showQrCode?: SortOrderInput | SortOrder
    qrCodeContent?: SortOrderInput | SortOrder
    customQrContent?: SortOrderInput | SortOrder
    showStudentInfo?: SortOrderInput | SortOrder
    showPhysicianInfo?: SortOrderInput | SortOrder
    showPharmacistInfo?: SortOrderInput | SortOrder
    showDrugCodes?: SortOrderInput | SortOrder
    showDrugDescriptions?: SortOrderInput | SortOrder
    showDosageInstructions?: SortOrderInput | SortOrder
    showTimestamp?: SortOrderInput | SortOrder
    use24HourFormat?: SortOrderInput | SortOrder
    paperSize?: SortOrderInput | SortOrder
    fontSize?: SortOrderInput | SortOrder
    printDensity?: SortOrderInput | SortOrder
    lineSpacing?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    accentColor?: SortOrderInput | SortOrder
    fontFamily?: SortOrderInput | SortOrder
    printCopyCount?: SortOrderInput | SortOrder
    autoPrint?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    currencySymbol?: SortOrderInput | SortOrder
    currencyPosition?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
  }

  export type ReceiptSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReceiptSettingsWhereInput | ReceiptSettingsWhereInput[]
    OR?: ReceiptSettingsWhereInput[]
    NOT?: ReceiptSettingsWhereInput | ReceiptSettingsWhereInput[]
    companyName?: StringFilter<"ReceiptSettings"> | string
    businessName?: StringFilter<"ReceiptSettings"> | string
    address?: StringFilter<"ReceiptSettings"> | string
    city?: StringFilter<"ReceiptSettings"> | string
    state?: StringFilter<"ReceiptSettings"> | string
    country?: StringFilter<"ReceiptSettings"> | string
    phone?: StringFilter<"ReceiptSettings"> | string
    email?: StringFilter<"ReceiptSettings"> | string
    website?: StringFilter<"ReceiptSettings"> | string
    receiptTitle?: StringNullableFilter<"ReceiptSettings"> | string | null
    headerMessage?: StringNullableFilter<"ReceiptSettings"> | string | null
    footerMessage?: StringNullableFilter<"ReceiptSettings"> | string | null
    showLogo?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    logoUrl?: StringNullableFilter<"ReceiptSettings"> | string | null
    showQrCode?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    qrCodeContent?: StringNullableFilter<"ReceiptSettings"> | string | null
    customQrContent?: StringNullableFilter<"ReceiptSettings"> | string | null
    showStudentInfo?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showPhysicianInfo?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showPharmacistInfo?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showDrugCodes?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showDrugDescriptions?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showDosageInstructions?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    showTimestamp?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    use24HourFormat?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    paperSize?: StringNullableFilter<"ReceiptSettings"> | string | null
    fontSize?: StringNullableFilter<"ReceiptSettings"> | string | null
    printDensity?: StringNullableFilter<"ReceiptSettings"> | string | null
    lineSpacing?: StringNullableFilter<"ReceiptSettings"> | string | null
    primaryColor?: StringNullableFilter<"ReceiptSettings"> | string | null
    accentColor?: StringNullableFilter<"ReceiptSettings"> | string | null
    fontFamily?: StringNullableFilter<"ReceiptSettings"> | string | null
    printCopyCount?: IntNullableFilter<"ReceiptSettings"> | number | null
    autoPrint?: BoolNullableFilter<"ReceiptSettings"> | boolean | null
    language?: StringNullableFilter<"ReceiptSettings"> | string | null
    currency?: StringNullableFilter<"ReceiptSettings"> | string | null
    currencySymbol?: StringNullableFilter<"ReceiptSettings"> | string | null
    currencyPosition?: StringNullableFilter<"ReceiptSettings"> | string | null
    createdAt?: DateTimeFilter<"ReceiptSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ReceiptSettings"> | Date | string
    sync?: BoolFilter<"ReceiptSettings"> | boolean
    syncedAt?: DateTimeNullableFilter<"ReceiptSettings"> | Date | string | null
    isDeleted?: BoolFilter<"ReceiptSettings"> | boolean
  }, "id">

  export type ReceiptSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    businessName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    receiptTitle?: SortOrderInput | SortOrder
    headerMessage?: SortOrderInput | SortOrder
    footerMessage?: SortOrderInput | SortOrder
    showLogo?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    showQrCode?: SortOrderInput | SortOrder
    qrCodeContent?: SortOrderInput | SortOrder
    customQrContent?: SortOrderInput | SortOrder
    showStudentInfo?: SortOrderInput | SortOrder
    showPhysicianInfo?: SortOrderInput | SortOrder
    showPharmacistInfo?: SortOrderInput | SortOrder
    showDrugCodes?: SortOrderInput | SortOrder
    showDrugDescriptions?: SortOrderInput | SortOrder
    showDosageInstructions?: SortOrderInput | SortOrder
    showTimestamp?: SortOrderInput | SortOrder
    use24HourFormat?: SortOrderInput | SortOrder
    paperSize?: SortOrderInput | SortOrder
    fontSize?: SortOrderInput | SortOrder
    printDensity?: SortOrderInput | SortOrder
    lineSpacing?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    accentColor?: SortOrderInput | SortOrder
    fontFamily?: SortOrderInput | SortOrder
    printCopyCount?: SortOrderInput | SortOrder
    autoPrint?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    currencySymbol?: SortOrderInput | SortOrder
    currencyPosition?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: ReceiptSettingsCountOrderByAggregateInput
    _avg?: ReceiptSettingsAvgOrderByAggregateInput
    _max?: ReceiptSettingsMaxOrderByAggregateInput
    _min?: ReceiptSettingsMinOrderByAggregateInput
    _sum?: ReceiptSettingsSumOrderByAggregateInput
  }

  export type ReceiptSettingsScalarWhereWithAggregatesInput = {
    AND?: ReceiptSettingsScalarWhereWithAggregatesInput | ReceiptSettingsScalarWhereWithAggregatesInput[]
    OR?: ReceiptSettingsScalarWhereWithAggregatesInput[]
    NOT?: ReceiptSettingsScalarWhereWithAggregatesInput | ReceiptSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    companyName?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    businessName?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    address?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    city?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    state?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    country?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    phone?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    email?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    website?: StringWithAggregatesFilter<"ReceiptSettings"> | string
    receiptTitle?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    headerMessage?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    footerMessage?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    showLogo?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    logoUrl?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    showQrCode?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    qrCodeContent?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    customQrContent?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    showStudentInfo?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    showPhysicianInfo?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    showPharmacistInfo?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    showDrugCodes?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    showDrugDescriptions?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    showDosageInstructions?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    showTimestamp?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    use24HourFormat?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    paperSize?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    fontSize?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    printDensity?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    lineSpacing?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    accentColor?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    fontFamily?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    printCopyCount?: IntNullableWithAggregatesFilter<"ReceiptSettings"> | number | null
    autoPrint?: BoolNullableWithAggregatesFilter<"ReceiptSettings"> | boolean | null
    language?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    currency?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    currencySymbol?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    currencyPosition?: StringNullableWithAggregatesFilter<"ReceiptSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReceiptSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReceiptSettings"> | Date | string
    sync?: BoolWithAggregatesFilter<"ReceiptSettings"> | boolean
    syncedAt?: DateTimeNullableWithAggregatesFilter<"ReceiptSettings"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"ReceiptSettings"> | boolean
  }

  export type superAdminCreateInput = {
    id?: string
    userName: string
    email: string
    password: string
    role: string
    lastLogin?: Date | string | null
    sync?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type superAdminUncheckedCreateInput = {
    id?: string
    userName: string
    email: string
    password: string
    role: string
    lastLogin?: Date | string | null
    sync?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type superAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type superAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type superAdminCreateManyInput = {
    id?: string
    userName: string
    email: string
    password: string
    role: string
    lastLogin?: Date | string | null
    sync?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type superAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type superAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersCreateInput = {
    id?: string
    email: string
    userName: string
    phoneNumber: string
    password: string
    role: $Enums.role
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type usersUncheckedCreateInput = {
    id?: string
    email: string
    userName: string
    phoneNumber: string
    password: string
    role: $Enums.role
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersCreateManyInput = {
    id?: string
    email: string
    userName: string
    phoneNumber: string
    password: string
    role: $Enums.role
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumroleFieldUpdateOperationsInput | $Enums.role
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingsCreateInput = {
    setting_id: number
    companyName: string
    companyEmail: string
    phoneNumber: string
    websiteURL: string
    address: string
    logoUrl: string
    defaultCurrency: string
    taxRate: number
    mode: $Enums.mode
    itermsPerPage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type SettingsUncheckedCreateInput = {
    setting_id: number
    companyName: string
    companyEmail: string
    phoneNumber: string
    websiteURL: string
    address: string
    logoUrl: string
    defaultCurrency: string
    taxRate: number
    mode: $Enums.mode
    itermsPerPage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type SettingsUpdateInput = {
    setting_id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    websiteURL?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    logoUrl?: StringFieldUpdateOperationsInput | string
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    taxRate?: IntFieldUpdateOperationsInput | number
    mode?: EnummodeFieldUpdateOperationsInput | $Enums.mode
    itermsPerPage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingsUncheckedUpdateInput = {
    setting_id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    websiteURL?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    logoUrl?: StringFieldUpdateOperationsInput | string
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    taxRate?: IntFieldUpdateOperationsInput | number
    mode?: EnummodeFieldUpdateOperationsInput | $Enums.mode
    itermsPerPage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingsCreateManyInput = {
    setting_id: number
    companyName: string
    companyEmail: string
    phoneNumber: string
    websiteURL: string
    address: string
    logoUrl: string
    defaultCurrency: string
    taxRate: number
    mode: $Enums.mode
    itermsPerPage: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type SettingsUpdateManyMutationInput = {
    setting_id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    websiteURL?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    logoUrl?: StringFieldUpdateOperationsInput | string
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    taxRate?: IntFieldUpdateOperationsInput | number
    mode?: EnummodeFieldUpdateOperationsInput | $Enums.mode
    itermsPerPage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingsUncheckedUpdateManyInput = {
    setting_id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    websiteURL?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    logoUrl?: StringFieldUpdateOperationsInput | string
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    taxRate?: IntFieldUpdateOperationsInput | number
    mode?: EnummodeFieldUpdateOperationsInput | $Enums.mode
    itermsPerPage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentCreateInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutStudentInput
    appointments?: AppointmentCreateNestedManyWithoutStudentInput
    queue?: QueueCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalUncheckedCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutStudentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutStudentInput
    queue?: QueueUncheckedCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUpdateManyWithoutStudentNestedInput
    queue?: QueueUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutStudentNestedInput
    queue?: QueueUncheckedUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PhysicianCreateInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutPhysicianInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPhysicianInput
    appointments?: AppointmentCreateNestedManyWithoutPhysicianInput
  }

  export type PhysicianUncheckedCreateInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPhysicianInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPhysicianInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPhysicianInput
  }

  export type PhysicianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutPhysicianNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPhysicianNestedInput
    appointments?: AppointmentUpdateManyWithoutPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutPhysicianNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPhysicianNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPhysicianNestedInput
  }

  export type PhysicianCreateManyInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
  }

  export type PhysicianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PhysicianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QueueCreateInput = {
    id?: string
    queueNumber: number
    priority?: $Enums.priority
    status?: string
    checkInTime?: Date | string
    calledTime?: Date | string | null
    completedTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutQueueInput
  }

  export type QueueUncheckedCreateInput = {
    id?: string
    queueNumber: number
    studentId: string
    priority?: $Enums.priority
    status?: string
    checkInTime?: Date | string
    calledTime?: Date | string | null
    completedTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type QueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    status?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    calledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutQueueNestedInput
  }

  export type QueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    status?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    calledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QueueCreateManyInput = {
    id?: string
    queueNumber: number
    studentId: string
    priority?: $Enums.priority
    status?: string
    checkInTime?: Date | string
    calledTime?: Date | string | null
    completedTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type QueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    status?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    calledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    studentId?: StringFieldUpdateOperationsInput | string
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    status?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    calledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentCreateInput = {
    id?: string
    appointmentNo: string
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutAppointmentsInput
    physician?: PhysicianCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    appointmentNo: string
    studentId: string
    physicianId?: string | null
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutAppointmentsNestedInput
    physician?: PhysicianUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentCreateManyInput = {
    id?: string
    appointmentNo: string
    studentId: string
    physicianId?: string | null
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VitalSignsCreateInput = {
    id?: string
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutVitalSignsInput
    consultation?: ConsultationCreateNestedOneWithoutVitalSignsInput
  }

  export type VitalSignsUncheckedCreateInput = {
    id?: string
    studentId: string
    consultationId?: string | null
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type VitalSignsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutVitalSignsNestedInput
    consultation?: ConsultationUpdateOneWithoutVitalSignsNestedInput
  }

  export type VitalSignsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VitalSignsCreateManyInput = {
    id?: string
    studentId: string
    consultationId?: string | null
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type VitalSignsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VitalSignsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationCreateInput = {
    id?: string
    consultationNo: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutConsultationsInput
    physician: PhysicianCreateNestedOneWithoutConsultationsInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutConsultationInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateInput = {
    id?: string
    consultationNo: string
    studentId: string
    physicianId: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutConsultationInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutConsultationsNestedInput
    physician?: PhysicianUpdateOneRequiredWithoutConsultationsNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutConsultationNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutConsultationNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationCreateManyInput = {
    id?: string
    consultationNo: string
    studentId: string
    physicianId: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type ConsultationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionCreateInput = {
    id?: string
    prescriptionNo: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutPrescriptionsInput
    physician: PhysicianCreateNestedOneWithoutPrescriptionsInput
    consultation: ConsultationCreateNestedOneWithoutPrescriptionsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: string
    prescriptionNo: string
    studentId: string
    physicianId: string
    consultationId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutPrescriptionsNestedInput
    physician?: PhysicianUpdateOneRequiredWithoutPrescriptionsNestedInput
    consultation?: ConsultationUpdateOneRequiredWithoutPrescriptionsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: string
    prescriptionNo: string
    studentId: string
    physicianId: string
    consultationId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
  }

  export type PrescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemCreateInput = {
    id?: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    prescription: PrescriptionCreateNestedOneWithoutPrescriptionItemsInput
    product: ProductCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateInput = {
    id?: string
    prescriptionId: string
    productId: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PrescriptionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescription?: PrescriptionUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemCreateManyInput = {
    id?: string
    prescriptionId: string
    productId: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PrescriptionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DrugDispensalCreateInput = {
    id?: string
    dispensalNo: string
    prescriptionId: string
    prescriptionNo: string
    dispensedBy: string
    dispensedItems: string
    totalAmount: number
    notes?: string | null
    createdAt?: Date | string
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutDrugDispensalsInput
  }

  export type DrugDispensalUncheckedCreateInput = {
    id?: string
    dispensalNo: string
    prescriptionId: string
    prescriptionNo: string
    studentId: string
    dispensedBy: string
    dispensedItems: string
    totalAmount: number
    notes?: string | null
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type DrugDispensalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispensalNo?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    dispensedBy?: StringFieldUpdateOperationsInput | string
    dispensedItems?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutDrugDispensalsNestedInput
  }

  export type DrugDispensalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispensalNo?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    dispensedBy?: StringFieldUpdateOperationsInput | string
    dispensedItems?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DrugDispensalCreateManyInput = {
    id?: string
    dispensalNo: string
    prescriptionId: string
    prescriptionNo: string
    studentId: string
    dispensedBy: string
    dispensedItems: string
    totalAmount: number
    notes?: string | null
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type DrugDispensalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispensalNo?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    dispensedBy?: StringFieldUpdateOperationsInput | string
    dispensedItems?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DrugDispensalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispensalNo?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    dispensedBy?: StringFieldUpdateOperationsInput | string
    dispensedItems?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalRecordCreateInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    recordData?: string | null
    attachments?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateInput = {
    id?: string
    studentId: string
    recordType: string
    title: string
    description?: string | null
    recordData?: string | null
    attachments?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type MedicalRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordData?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordData?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalRecordCreateManyInput = {
    id?: string
    studentId: string
    recordType: string
    title: string
    description?: string | null
    recordData?: string | null
    attachments?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type MedicalRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordData?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordData?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    barcode: string
    genericName?: string | null
    brandName?: string | null
    category?: string | null
    manufacturer?: string | null
    batchNumber?: string | null
    expiryDate?: Date | string | null
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel?: number | null
    maxStockLevel?: number | null
    taxRate: number
    unit: $Enums.unit
    description: string
    dosageForm?: string | null
    strength?: string | null
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutProductInput
    purchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    barcode: string
    genericName?: string | null
    brandName?: string | null
    category?: string | null
    manufacturer?: string | null
    batchNumber?: string | null
    expiryDate?: Date | string | null
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel?: number | null
    maxStockLevel?: number | null
    taxRate: number
    unit: $Enums.unit
    description: string
    dosageForm?: string | null
    strength?: string | null
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeSalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: IntFieldUpdateOperationsInput | number
    unit?: EnumunitFieldUpdateOperationsInput | $Enums.unit
    description?: StringFieldUpdateOperationsInput | string
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    controlledSubstance?: BoolFieldUpdateOperationsInput | boolean
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptionItems?: PrescriptionItemUpdateManyWithoutProductNestedInput
    purchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeSalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: IntFieldUpdateOperationsInput | number
    unit?: EnumunitFieldUpdateOperationsInput | $Enums.unit
    description?: StringFieldUpdateOperationsInput | string
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    controlledSubstance?: BoolFieldUpdateOperationsInput | boolean
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    barcode: string
    genericName?: string | null
    brandName?: string | null
    category?: string | null
    manufacturer?: string | null
    batchNumber?: string | null
    expiryDate?: Date | string | null
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel?: number | null
    maxStockLevel?: number | null
    taxRate: number
    unit: $Enums.unit
    description: string
    dosageForm?: string | null
    strength?: string | null
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeSalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: IntFieldUpdateOperationsInput | number
    unit?: EnumunitFieldUpdateOperationsInput | $Enums.unit
    description?: StringFieldUpdateOperationsInput | string
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    controlledSubstance?: BoolFieldUpdateOperationsInput | boolean
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeSalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: IntFieldUpdateOperationsInput | number
    unit?: EnumunitFieldUpdateOperationsInput | $Enums.unit
    description?: StringFieldUpdateOperationsInput | string
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    controlledSubstance?: BoolFieldUpdateOperationsInput | boolean
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseCreateInput = {
    id?: string
    taxRate: number
    subTotal: number
    notes?: string | null
    amountPaid?: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceNo: string
    isDeleted?: boolean
    purchaseItem?: PurchaseItemCreateNestedManyWithoutPurchaseInput
    Supplier?: SupplierCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    taxRate: number
    subTotal: number
    notes?: string | null
    amountPaid?: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceNo: string
    supplierId?: string | null
    isDeleted?: boolean
    purchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    purchaseItem?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
    Supplier?: SupplierUpdateOneWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    purchaseItem?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    taxRate: number
    subTotal: number
    notes?: string | null
    amountPaid?: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceNo: string
    supplierId?: string | null
    isDeleted?: boolean
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseItemCreateInput = {
    id?: string
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    product?: ProductCreateNestedOneWithoutPurchaseItemInput
    Purchase?: PurchaseCreateNestedOneWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateInput = {
    id?: string
    productId?: string | null
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    purchaseId?: string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PurchaseItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneWithoutPurchaseItemNestedInput
    Purchase?: PurchaseUpdateOneWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseItemCreateManyInput = {
    id?: string
    productId?: string | null
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    purchaseId?: string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PurchaseItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BalanceTransactionCreateInput = {
    id?: string
    amount: number
    type: string
    description: string
    paymentMethod?: string | null
    reference?: string | null
    prescriptionId?: string | null
    balanceAfter: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutBalanceTransactionInput
  }

  export type BalanceTransactionUncheckedCreateInput = {
    id?: string
    studentId: string
    amount: number
    type: string
    description: string
    paymentMethod?: string | null
    reference?: string | null
    prescriptionId?: string | null
    balanceAfter: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type BalanceTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutBalanceTransactionNestedInput
  }

  export type BalanceTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BalanceTransactionCreateManyInput = {
    id?: string
    studentId: string
    amount: number
    type: string
    description: string
    paymentMethod?: string | null
    reference?: string | null
    prescriptionId?: string | null
    balanceAfter: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type BalanceTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BalanceTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    type: string
    companyName?: string | null
    email: string
    address: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    purchase?: PurchaseCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    companyName?: string | null
    email: string
    address: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    purchase?: PurchaseUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    purchase?: PurchaseUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    purchase?: PurchaseUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    type: string
    companyName?: string | null
    email: string
    address: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReceiptSettingsCreateInput = {
    id?: string
    companyName: string
    businessName: string
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website: string
    receiptTitle?: string | null
    headerMessage?: string | null
    footerMessage?: string | null
    showLogo?: boolean | null
    logoUrl?: string | null
    showQrCode?: boolean | null
    qrCodeContent?: string | null
    customQrContent?: string | null
    showStudentInfo?: boolean | null
    showPhysicianInfo?: boolean | null
    showPharmacistInfo?: boolean | null
    showDrugCodes?: boolean | null
    showDrugDescriptions?: boolean | null
    showDosageInstructions?: boolean | null
    showTimestamp?: boolean | null
    use24HourFormat?: boolean | null
    paperSize?: string | null
    fontSize?: string | null
    printDensity?: string | null
    lineSpacing?: string | null
    primaryColor?: string | null
    accentColor?: string | null
    fontFamily?: string | null
    printCopyCount?: number | null
    autoPrint?: boolean | null
    language?: string | null
    currency?: string | null
    currencySymbol?: string | null
    currencyPosition?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type ReceiptSettingsUncheckedCreateInput = {
    id?: string
    companyName: string
    businessName: string
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website: string
    receiptTitle?: string | null
    headerMessage?: string | null
    footerMessage?: string | null
    showLogo?: boolean | null
    logoUrl?: string | null
    showQrCode?: boolean | null
    qrCodeContent?: string | null
    customQrContent?: string | null
    showStudentInfo?: boolean | null
    showPhysicianInfo?: boolean | null
    showPharmacistInfo?: boolean | null
    showDrugCodes?: boolean | null
    showDrugDescriptions?: boolean | null
    showDosageInstructions?: boolean | null
    showTimestamp?: boolean | null
    use24HourFormat?: boolean | null
    paperSize?: string | null
    fontSize?: string | null
    printDensity?: string | null
    lineSpacing?: string | null
    primaryColor?: string | null
    accentColor?: string | null
    fontFamily?: string | null
    printCopyCount?: number | null
    autoPrint?: boolean | null
    language?: string | null
    currency?: string | null
    currencySymbol?: string | null
    currencyPosition?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type ReceiptSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    receiptTitle?: NullableStringFieldUpdateOperationsInput | string | null
    headerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    footerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    showQrCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    qrCodeContent?: NullableStringFieldUpdateOperationsInput | string | null
    customQrContent?: NullableStringFieldUpdateOperationsInput | string | null
    showStudentInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showPhysicianInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showPharmacistInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDrugCodes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDrugDescriptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDosageInstructions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showTimestamp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    use24HourFormat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    printDensity?: NullableStringFieldUpdateOperationsInput | string | null
    lineSpacing?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printCopyCount?: NullableIntFieldUpdateOperationsInput | number | null
    autoPrint?: NullableBoolFieldUpdateOperationsInput | boolean | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currencyPosition?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReceiptSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    receiptTitle?: NullableStringFieldUpdateOperationsInput | string | null
    headerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    footerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    showQrCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    qrCodeContent?: NullableStringFieldUpdateOperationsInput | string | null
    customQrContent?: NullableStringFieldUpdateOperationsInput | string | null
    showStudentInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showPhysicianInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showPharmacistInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDrugCodes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDrugDescriptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDosageInstructions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showTimestamp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    use24HourFormat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    printDensity?: NullableStringFieldUpdateOperationsInput | string | null
    lineSpacing?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printCopyCount?: NullableIntFieldUpdateOperationsInput | number | null
    autoPrint?: NullableBoolFieldUpdateOperationsInput | boolean | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currencyPosition?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReceiptSettingsCreateManyInput = {
    id?: string
    companyName: string
    businessName: string
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website: string
    receiptTitle?: string | null
    headerMessage?: string | null
    footerMessage?: string | null
    showLogo?: boolean | null
    logoUrl?: string | null
    showQrCode?: boolean | null
    qrCodeContent?: string | null
    customQrContent?: string | null
    showStudentInfo?: boolean | null
    showPhysicianInfo?: boolean | null
    showPharmacistInfo?: boolean | null
    showDrugCodes?: boolean | null
    showDrugDescriptions?: boolean | null
    showDosageInstructions?: boolean | null
    showTimestamp?: boolean | null
    use24HourFormat?: boolean | null
    paperSize?: string | null
    fontSize?: string | null
    printDensity?: string | null
    lineSpacing?: string | null
    primaryColor?: string | null
    accentColor?: string | null
    fontFamily?: string | null
    printCopyCount?: number | null
    autoPrint?: boolean | null
    language?: string | null
    currency?: string | null
    currencySymbol?: string | null
    currencyPosition?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    syncedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type ReceiptSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    receiptTitle?: NullableStringFieldUpdateOperationsInput | string | null
    headerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    footerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    showQrCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    qrCodeContent?: NullableStringFieldUpdateOperationsInput | string | null
    customQrContent?: NullableStringFieldUpdateOperationsInput | string | null
    showStudentInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showPhysicianInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showPharmacistInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDrugCodes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDrugDescriptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDosageInstructions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showTimestamp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    use24HourFormat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    printDensity?: NullableStringFieldUpdateOperationsInput | string | null
    lineSpacing?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printCopyCount?: NullableIntFieldUpdateOperationsInput | number | null
    autoPrint?: NullableBoolFieldUpdateOperationsInput | boolean | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currencyPosition?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReceiptSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    receiptTitle?: NullableStringFieldUpdateOperationsInput | string | null
    headerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    footerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    showQrCode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    qrCodeContent?: NullableStringFieldUpdateOperationsInput | string | null
    customQrContent?: NullableStringFieldUpdateOperationsInput | string | null
    showStudentInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showPhysicianInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showPharmacistInfo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDrugCodes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDrugDescriptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showDosageInstructions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    showTimestamp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    use24HourFormat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    printDensity?: NullableStringFieldUpdateOperationsInput | string | null
    lineSpacing?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    accentColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printCopyCount?: NullableIntFieldUpdateOperationsInput | number | null
    autoPrint?: NullableBoolFieldUpdateOperationsInput | boolean | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencySymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currencyPosition?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type superAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type superAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type superAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumroleFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[]
    notIn?: $Enums.role[]
    not?: NestedEnumroleFilter<$PrismaModel> | $Enums.role
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    userName?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[]
    notIn?: $Enums.role[]
    not?: NestedEnumroleWithAggregatesFilter<$PrismaModel> | $Enums.role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleFilter<$PrismaModel>
    _max?: NestedEnumroleFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnummodeFilter<$PrismaModel = never> = {
    equals?: $Enums.mode | EnummodeFieldRefInput<$PrismaModel>
    in?: $Enums.mode[]
    notIn?: $Enums.mode[]
    not?: NestedEnummodeFilter<$PrismaModel> | $Enums.mode
  }

  export type SettingsCountOrderByAggregateInput = {
    setting_id?: SortOrder
    companyName?: SortOrder
    companyEmail?: SortOrder
    phoneNumber?: SortOrder
    websiteURL?: SortOrder
    address?: SortOrder
    logoUrl?: SortOrder
    defaultCurrency?: SortOrder
    taxRate?: SortOrder
    mode?: SortOrder
    itermsPerPage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    setting_id?: SortOrder
    taxRate?: SortOrder
    itermsPerPage?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    setting_id?: SortOrder
    companyName?: SortOrder
    companyEmail?: SortOrder
    phoneNumber?: SortOrder
    websiteURL?: SortOrder
    address?: SortOrder
    logoUrl?: SortOrder
    defaultCurrency?: SortOrder
    taxRate?: SortOrder
    mode?: SortOrder
    itermsPerPage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    setting_id?: SortOrder
    companyName?: SortOrder
    companyEmail?: SortOrder
    phoneNumber?: SortOrder
    websiteURL?: SortOrder
    address?: SortOrder
    logoUrl?: SortOrder
    defaultCurrency?: SortOrder
    taxRate?: SortOrder
    mode?: SortOrder
    itermsPerPage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    setting_id?: SortOrder
    taxRate?: SortOrder
    itermsPerPage?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnummodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.mode | EnummodeFieldRefInput<$PrismaModel>
    in?: $Enums.mode[]
    notIn?: $Enums.mode[]
    not?: NestedEnummodeWithAggregatesFilter<$PrismaModel> | $Enums.mode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummodeFilter<$PrismaModel>
    _max?: NestedEnummodeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ConsultationListRelationFilter = {
    every?: ConsultationWhereInput
    some?: ConsultationWhereInput
    none?: ConsultationWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type DrugDispensalListRelationFilter = {
    every?: DrugDispensalWhereInput
    some?: DrugDispensalWhereInput
    none?: DrugDispensalWhereInput
  }

  export type MedicalRecordListRelationFilter = {
    every?: MedicalRecordWhereInput
    some?: MedicalRecordWhereInput
    none?: MedicalRecordWhereInput
  }

  export type VitalSignsListRelationFilter = {
    every?: VitalSignsWhereInput
    some?: VitalSignsWhereInput
    none?: VitalSignsWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type QueueListRelationFilter = {
    every?: QueueWhereInput
    some?: QueueWhereInput
    none?: QueueWhereInput
  }

  export type BalanceTransactionListRelationFilter = {
    every?: BalanceTransactionWhereInput
    some?: BalanceTransactionWhereInput
    none?: BalanceTransactionWhereInput
  }

  export type ConsultationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DrugDispensalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitalSignsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BalanceTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    matricNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    department?: SortOrder
    level?: SortOrder
    faculty?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    genotype?: SortOrder
    allergies?: SortOrder
    chronicConditions?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    emergencyRelationship?: SortOrder
    profilePhoto?: SortOrder
    address?: SortOrder
    stateOfOrigin?: SortOrder
    nationality?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    matricNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    department?: SortOrder
    level?: SortOrder
    faculty?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    genotype?: SortOrder
    allergies?: SortOrder
    chronicConditions?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    emergencyRelationship?: SortOrder
    profilePhoto?: SortOrder
    address?: SortOrder
    stateOfOrigin?: SortOrder
    nationality?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    matricNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    department?: SortOrder
    level?: SortOrder
    faculty?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    genotype?: SortOrder
    allergies?: SortOrder
    chronicConditions?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    emergencyRelationship?: SortOrder
    profilePhoto?: SortOrder
    address?: SortOrder
    stateOfOrigin?: SortOrder
    nationality?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PhysicianCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    licenseNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profilePhoto?: SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type PhysicianMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    licenseNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profilePhoto?: SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type PhysicianMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    otherNames?: SortOrder
    specialization?: SortOrder
    qualification?: SortOrder
    licenseNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profilePhoto?: SortOrder
    isActive?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumpriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.priority | EnumpriorityFieldRefInput<$PrismaModel>
    in?: $Enums.priority[]
    notIn?: $Enums.priority[]
    not?: NestedEnumpriorityFilter<$PrismaModel> | $Enums.priority
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type QueueCountOrderByAggregateInput = {
    id?: SortOrder
    queueNumber?: SortOrder
    studentId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    calledTime?: SortOrder
    completedTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type QueueAvgOrderByAggregateInput = {
    queueNumber?: SortOrder
  }

  export type QueueMaxOrderByAggregateInput = {
    id?: SortOrder
    queueNumber?: SortOrder
    studentId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    calledTime?: SortOrder
    completedTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type QueueMinOrderByAggregateInput = {
    id?: SortOrder
    queueNumber?: SortOrder
    studentId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    calledTime?: SortOrder
    completedTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type QueueSumOrderByAggregateInput = {
    queueNumber?: SortOrder
  }

  export type EnumpriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.priority | EnumpriorityFieldRefInput<$PrismaModel>
    in?: $Enums.priority[]
    notIn?: $Enums.priority[]
    not?: NestedEnumpriorityWithAggregatesFilter<$PrismaModel> | $Enums.priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpriorityFilter<$PrismaModel>
    _max?: NestedEnumpriorityFilter<$PrismaModel>
  }

  export type PhysicianNullableScalarRelationFilter = {
    is?: PhysicianWhereInput | null
    isNot?: PhysicianWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    appointmentDate?: SortOrder
    appointmentTime?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ConsultationNullableScalarRelationFilter = {
    is?: ConsultationWhereInput | null
    isNot?: ConsultationWhereInput | null
  }

  export type VitalSignsCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultationId?: SortOrder
    temperature?: SortOrder
    bloodPressure?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    bmi?: SortOrder
    oxygenSaturation?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type VitalSignsAvgOrderByAggregateInput = {
    temperature?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    bmi?: SortOrder
    oxygenSaturation?: SortOrder
  }

  export type VitalSignsMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultationId?: SortOrder
    temperature?: SortOrder
    bloodPressure?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    bmi?: SortOrder
    oxygenSaturation?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type VitalSignsMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultationId?: SortOrder
    temperature?: SortOrder
    bloodPressure?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    bmi?: SortOrder
    oxygenSaturation?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type VitalSignsSumOrderByAggregateInput = {
    temperature?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    bmi?: SortOrder
    oxygenSaturation?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumconsultationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.consultationStatus | EnumconsultationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.consultationStatus[]
    notIn?: $Enums.consultationStatus[]
    not?: NestedEnumconsultationStatusFilter<$PrismaModel> | $Enums.consultationStatus
  }

  export type PhysicianScalarRelationFilter = {
    is?: PhysicianWhereInput
    isNot?: PhysicianWhereInput
  }

  export type ConsultationCountOrderByAggregateInput = {
    id?: SortOrder
    consultationNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    chiefComplaint?: SortOrder
    historyOfPresenting?: SortOrder
    symptoms?: SortOrder
    physicalExamination?: SortOrder
    diagnosis?: SortOrder
    differentialDiagnosis?: SortOrder
    treatmentPlan?: SortOrder
    notes?: SortOrder
    followUpDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ConsultationMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    chiefComplaint?: SortOrder
    historyOfPresenting?: SortOrder
    symptoms?: SortOrder
    physicalExamination?: SortOrder
    diagnosis?: SortOrder
    differentialDiagnosis?: SortOrder
    treatmentPlan?: SortOrder
    notes?: SortOrder
    followUpDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ConsultationMinOrderByAggregateInput = {
    id?: SortOrder
    consultationNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    chiefComplaint?: SortOrder
    historyOfPresenting?: SortOrder
    symptoms?: SortOrder
    physicalExamination?: SortOrder
    diagnosis?: SortOrder
    differentialDiagnosis?: SortOrder
    treatmentPlan?: SortOrder
    notes?: SortOrder
    followUpDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumconsultationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.consultationStatus | EnumconsultationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.consultationStatus[]
    notIn?: $Enums.consultationStatus[]
    not?: NestedEnumconsultationStatusWithAggregatesFilter<$PrismaModel> | $Enums.consultationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumconsultationStatusFilter<$PrismaModel>
    _max?: NestedEnumconsultationStatusFilter<$PrismaModel>
  }

  export type EnumprescriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.prescriptionStatus | EnumprescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.prescriptionStatus[]
    notIn?: $Enums.prescriptionStatus[]
    not?: NestedEnumprescriptionStatusFilter<$PrismaModel> | $Enums.prescriptionStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ConsultationScalarRelationFilter = {
    is?: ConsultationWhereInput
    isNot?: ConsultationWhereInput
  }

  export type PrescriptionItemListRelationFilter = {
    every?: PrescriptionItemWhereInput
    some?: PrescriptionItemWhereInput
    none?: PrescriptionItemWhereInput
  }

  export type PrescriptionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    consultationId?: SortOrder
    diagnosis?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isPaid?: SortOrder
    isDispensed?: SortOrder
    dispensedBy?: SortOrder
    dispensedAt?: SortOrder
    totalCost?: SortOrder
    amountPaid?: SortOrder
    discount?: SortOrder
    pharmacyNotified?: SortOrder
    notifiedAt?: SortOrder
    studentNotified?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    totalCost?: SortOrder
    amountPaid?: SortOrder
    discount?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    consultationId?: SortOrder
    diagnosis?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isPaid?: SortOrder
    isDispensed?: SortOrder
    dispensedBy?: SortOrder
    dispensedAt?: SortOrder
    totalCost?: SortOrder
    amountPaid?: SortOrder
    discount?: SortOrder
    pharmacyNotified?: SortOrder
    notifiedAt?: SortOrder
    studentNotified?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    physicianId?: SortOrder
    consultationId?: SortOrder
    diagnosis?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    isPaid?: SortOrder
    isDispensed?: SortOrder
    dispensedBy?: SortOrder
    dispensedAt?: SortOrder
    totalCost?: SortOrder
    amountPaid?: SortOrder
    discount?: SortOrder
    pharmacyNotified?: SortOrder
    notifiedAt?: SortOrder
    studentNotified?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    isDeleted?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    totalCost?: SortOrder
    amountPaid?: SortOrder
    discount?: SortOrder
  }

  export type EnumprescriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.prescriptionStatus | EnumprescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.prescriptionStatus[]
    notIn?: $Enums.prescriptionStatus[]
    not?: NestedEnumprescriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.prescriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprescriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumprescriptionStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PrescriptionScalarRelationFilter = {
    is?: PrescriptionWhereInput
    isNot?: PrescriptionWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type PrescriptionItemCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    productId?: SortOrder
    drugName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    route?: SortOrder
    instructions?: SortOrder
    quantityPrescribed?: SortOrder
    quantityDispensed?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isDispensed?: SortOrder
    dispensedAt?: SortOrder
    dispensedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type PrescriptionItemAvgOrderByAggregateInput = {
    quantityPrescribed?: SortOrder
    quantityDispensed?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type PrescriptionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    productId?: SortOrder
    drugName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    route?: SortOrder
    instructions?: SortOrder
    quantityPrescribed?: SortOrder
    quantityDispensed?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isDispensed?: SortOrder
    dispensedAt?: SortOrder
    dispensedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type PrescriptionItemMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    productId?: SortOrder
    drugName?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    route?: SortOrder
    instructions?: SortOrder
    quantityPrescribed?: SortOrder
    quantityDispensed?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    isDispensed?: SortOrder
    dispensedAt?: SortOrder
    dispensedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type PrescriptionItemSumOrderByAggregateInput = {
    quantityPrescribed?: SortOrder
    quantityDispensed?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type DrugDispensalCountOrderByAggregateInput = {
    id?: SortOrder
    dispensalNo?: SortOrder
    prescriptionId?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    dispensedBy?: SortOrder
    dispensedItems?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type DrugDispensalAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type DrugDispensalMaxOrderByAggregateInput = {
    id?: SortOrder
    dispensalNo?: SortOrder
    prescriptionId?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    dispensedBy?: SortOrder
    dispensedItems?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type DrugDispensalMinOrderByAggregateInput = {
    id?: SortOrder
    dispensalNo?: SortOrder
    prescriptionId?: SortOrder
    prescriptionNo?: SortOrder
    studentId?: SortOrder
    dispensedBy?: SortOrder
    dispensedItems?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type DrugDispensalSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type MedicalRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    recordData?: SortOrder
    attachments?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type MedicalRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    recordData?: SortOrder
    attachments?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type MedicalRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    recordData?: SortOrder
    attachments?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type EnumunitFilter<$PrismaModel = never> = {
    equals?: $Enums.unit | EnumunitFieldRefInput<$PrismaModel>
    in?: $Enums.unit[]
    notIn?: $Enums.unit[]
    not?: NestedEnumunitFilter<$PrismaModel> | $Enums.unit
  }

  export type PurchaseItemListRelationFilter = {
    every?: PurchaseItemWhereInput
    some?: PurchaseItemWhereInput
    none?: PurchaseItemWhereInput
  }

  export type PurchaseItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    genericName?: SortOrder
    brandName?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    wholeSalePrice?: SortOrder
    retailPrice?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    reorderLevel?: SortOrder
    maxStockLevel?: SortOrder
    taxRate?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    requiresPrescription?: SortOrder
    controlledSubstance?: SortOrder
    storageConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    wholeSalePrice?: SortOrder
    retailPrice?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    reorderLevel?: SortOrder
    maxStockLevel?: SortOrder
    taxRate?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    genericName?: SortOrder
    brandName?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    wholeSalePrice?: SortOrder
    retailPrice?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    reorderLevel?: SortOrder
    maxStockLevel?: SortOrder
    taxRate?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    requiresPrescription?: SortOrder
    controlledSubstance?: SortOrder
    storageConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    genericName?: SortOrder
    brandName?: SortOrder
    category?: SortOrder
    manufacturer?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    wholeSalePrice?: SortOrder
    retailPrice?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    reorderLevel?: SortOrder
    maxStockLevel?: SortOrder
    taxRate?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    requiresPrescription?: SortOrder
    controlledSubstance?: SortOrder
    storageConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    wholeSalePrice?: SortOrder
    retailPrice?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    reorderLevel?: SortOrder
    maxStockLevel?: SortOrder
    taxRate?: SortOrder
  }

  export type EnumunitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.unit | EnumunitFieldRefInput<$PrismaModel>
    in?: $Enums.unit[]
    notIn?: $Enums.unit[]
    not?: NestedEnumunitWithAggregatesFilter<$PrismaModel> | $Enums.unit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumunitFilter<$PrismaModel>
    _max?: NestedEnumunitFilter<$PrismaModel>
  }

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    taxRate?: SortOrder
    subTotal?: SortOrder
    notes?: SortOrder
    amountPaid?: SortOrder
    grandTotal?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceNo?: SortOrder
    supplierId?: SortOrder
    isDeleted?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    taxRate?: SortOrder
    subTotal?: SortOrder
    amountPaid?: SortOrder
    grandTotal?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    taxRate?: SortOrder
    subTotal?: SortOrder
    notes?: SortOrder
    amountPaid?: SortOrder
    grandTotal?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceNo?: SortOrder
    supplierId?: SortOrder
    isDeleted?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    taxRate?: SortOrder
    subTotal?: SortOrder
    notes?: SortOrder
    amountPaid?: SortOrder
    grandTotal?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referenceNo?: SortOrder
    supplierId?: SortOrder
    isDeleted?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    taxRate?: SortOrder
    subTotal?: SortOrder
    amountPaid?: SortOrder
    grandTotal?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type PurchaseNullableScalarRelationFilter = {
    is?: PurchaseWhereInput | null
    isNot?: PurchaseWhereInput | null
  }

  export type PurchaseItemCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    cost?: SortOrder
    productName?: SortOrder
    selectedPrice?: SortOrder
    priceType?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    profit?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    purchaseId?: SortOrder
    customRetailPrice?: SortOrder
    customWholesalePrice?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type PurchaseItemAvgOrderByAggregateInput = {
    cost?: SortOrder
    selectedPrice?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    profit?: SortOrder
    customRetailPrice?: SortOrder
    customWholesalePrice?: SortOrder
  }

  export type PurchaseItemMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    cost?: SortOrder
    productName?: SortOrder
    selectedPrice?: SortOrder
    priceType?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    profit?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    purchaseId?: SortOrder
    customRetailPrice?: SortOrder
    customWholesalePrice?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type PurchaseItemMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    cost?: SortOrder
    productName?: SortOrder
    selectedPrice?: SortOrder
    priceType?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    profit?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    purchaseId?: SortOrder
    customRetailPrice?: SortOrder
    customWholesalePrice?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type PurchaseItemSumOrderByAggregateInput = {
    cost?: SortOrder
    selectedPrice?: SortOrder
    quantity?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    profit?: SortOrder
    customRetailPrice?: SortOrder
    customWholesalePrice?: SortOrder
  }

  export type BalanceTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    prescriptionId?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type BalanceTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    balanceAfter?: SortOrder
  }

  export type BalanceTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    prescriptionId?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type BalanceTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    prescriptionId?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type BalanceTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    balanceAfter?: SortOrder
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ReceiptSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    businessName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    receiptTitle?: SortOrder
    headerMessage?: SortOrder
    footerMessage?: SortOrder
    showLogo?: SortOrder
    logoUrl?: SortOrder
    showQrCode?: SortOrder
    qrCodeContent?: SortOrder
    customQrContent?: SortOrder
    showStudentInfo?: SortOrder
    showPhysicianInfo?: SortOrder
    showPharmacistInfo?: SortOrder
    showDrugCodes?: SortOrder
    showDrugDescriptions?: SortOrder
    showDosageInstructions?: SortOrder
    showTimestamp?: SortOrder
    use24HourFormat?: SortOrder
    paperSize?: SortOrder
    fontSize?: SortOrder
    printDensity?: SortOrder
    lineSpacing?: SortOrder
    primaryColor?: SortOrder
    accentColor?: SortOrder
    fontFamily?: SortOrder
    printCopyCount?: SortOrder
    autoPrint?: SortOrder
    language?: SortOrder
    currency?: SortOrder
    currencySymbol?: SortOrder
    currencyPosition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReceiptSettingsAvgOrderByAggregateInput = {
    printCopyCount?: SortOrder
  }

  export type ReceiptSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    businessName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    receiptTitle?: SortOrder
    headerMessage?: SortOrder
    footerMessage?: SortOrder
    showLogo?: SortOrder
    logoUrl?: SortOrder
    showQrCode?: SortOrder
    qrCodeContent?: SortOrder
    customQrContent?: SortOrder
    showStudentInfo?: SortOrder
    showPhysicianInfo?: SortOrder
    showPharmacistInfo?: SortOrder
    showDrugCodes?: SortOrder
    showDrugDescriptions?: SortOrder
    showDosageInstructions?: SortOrder
    showTimestamp?: SortOrder
    use24HourFormat?: SortOrder
    paperSize?: SortOrder
    fontSize?: SortOrder
    printDensity?: SortOrder
    lineSpacing?: SortOrder
    primaryColor?: SortOrder
    accentColor?: SortOrder
    fontFamily?: SortOrder
    printCopyCount?: SortOrder
    autoPrint?: SortOrder
    language?: SortOrder
    currency?: SortOrder
    currencySymbol?: SortOrder
    currencyPosition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReceiptSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    businessName?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    receiptTitle?: SortOrder
    headerMessage?: SortOrder
    footerMessage?: SortOrder
    showLogo?: SortOrder
    logoUrl?: SortOrder
    showQrCode?: SortOrder
    qrCodeContent?: SortOrder
    customQrContent?: SortOrder
    showStudentInfo?: SortOrder
    showPhysicianInfo?: SortOrder
    showPharmacistInfo?: SortOrder
    showDrugCodes?: SortOrder
    showDrugDescriptions?: SortOrder
    showDosageInstructions?: SortOrder
    showTimestamp?: SortOrder
    use24HourFormat?: SortOrder
    paperSize?: SortOrder
    fontSize?: SortOrder
    printDensity?: SortOrder
    lineSpacing?: SortOrder
    primaryColor?: SortOrder
    accentColor?: SortOrder
    fontFamily?: SortOrder
    printCopyCount?: SortOrder
    autoPrint?: SortOrder
    language?: SortOrder
    currency?: SortOrder
    currencySymbol?: SortOrder
    currencyPosition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sync?: SortOrder
    syncedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type ReceiptSettingsSumOrderByAggregateInput = {
    printCopyCount?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumroleFieldUpdateOperationsInput = {
    set?: $Enums.role
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnummodeFieldUpdateOperationsInput = {
    set?: $Enums.mode
  }

  export type ConsultationCreateNestedManyWithoutStudentInput = {
    create?: XOR<ConsultationCreateWithoutStudentInput, ConsultationUncheckedCreateWithoutStudentInput> | ConsultationCreateWithoutStudentInput[] | ConsultationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutStudentInput | ConsultationCreateOrConnectWithoutStudentInput[]
    createMany?: ConsultationCreateManyStudentInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutStudentInput = {
    create?: XOR<PrescriptionCreateWithoutStudentInput, PrescriptionUncheckedCreateWithoutStudentInput> | PrescriptionCreateWithoutStudentInput[] | PrescriptionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutStudentInput | PrescriptionCreateOrConnectWithoutStudentInput[]
    createMany?: PrescriptionCreateManyStudentInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type DrugDispensalCreateNestedManyWithoutStudentInput = {
    create?: XOR<DrugDispensalCreateWithoutStudentInput, DrugDispensalUncheckedCreateWithoutStudentInput> | DrugDispensalCreateWithoutStudentInput[] | DrugDispensalUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DrugDispensalCreateOrConnectWithoutStudentInput | DrugDispensalCreateOrConnectWithoutStudentInput[]
    createMany?: DrugDispensalCreateManyStudentInputEnvelope
    connect?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
  }

  export type MedicalRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<MedicalRecordCreateWithoutStudentInput, MedicalRecordUncheckedCreateWithoutStudentInput> | MedicalRecordCreateWithoutStudentInput[] | MedicalRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutStudentInput | MedicalRecordCreateOrConnectWithoutStudentInput[]
    createMany?: MedicalRecordCreateManyStudentInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type VitalSignsCreateNestedManyWithoutStudentInput = {
    create?: XOR<VitalSignsCreateWithoutStudentInput, VitalSignsUncheckedCreateWithoutStudentInput> | VitalSignsCreateWithoutStudentInput[] | VitalSignsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutStudentInput | VitalSignsCreateOrConnectWithoutStudentInput[]
    createMany?: VitalSignsCreateManyStudentInputEnvelope
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<AppointmentCreateWithoutStudentInput, AppointmentUncheckedCreateWithoutStudentInput> | AppointmentCreateWithoutStudentInput[] | AppointmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutStudentInput | AppointmentCreateOrConnectWithoutStudentInput[]
    createMany?: AppointmentCreateManyStudentInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type QueueCreateNestedManyWithoutStudentInput = {
    create?: XOR<QueueCreateWithoutStudentInput, QueueUncheckedCreateWithoutStudentInput> | QueueCreateWithoutStudentInput[] | QueueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutStudentInput | QueueCreateOrConnectWithoutStudentInput[]
    createMany?: QueueCreateManyStudentInputEnvelope
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type BalanceTransactionCreateNestedManyWithoutStudentInput = {
    create?: XOR<BalanceTransactionCreateWithoutStudentInput, BalanceTransactionUncheckedCreateWithoutStudentInput> | BalanceTransactionCreateWithoutStudentInput[] | BalanceTransactionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BalanceTransactionCreateOrConnectWithoutStudentInput | BalanceTransactionCreateOrConnectWithoutStudentInput[]
    createMany?: BalanceTransactionCreateManyStudentInputEnvelope
    connect?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
  }

  export type ConsultationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ConsultationCreateWithoutStudentInput, ConsultationUncheckedCreateWithoutStudentInput> | ConsultationCreateWithoutStudentInput[] | ConsultationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutStudentInput | ConsultationCreateOrConnectWithoutStudentInput[]
    createMany?: ConsultationCreateManyStudentInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PrescriptionCreateWithoutStudentInput, PrescriptionUncheckedCreateWithoutStudentInput> | PrescriptionCreateWithoutStudentInput[] | PrescriptionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutStudentInput | PrescriptionCreateOrConnectWithoutStudentInput[]
    createMany?: PrescriptionCreateManyStudentInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type DrugDispensalUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<DrugDispensalCreateWithoutStudentInput, DrugDispensalUncheckedCreateWithoutStudentInput> | DrugDispensalCreateWithoutStudentInput[] | DrugDispensalUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DrugDispensalCreateOrConnectWithoutStudentInput | DrugDispensalCreateOrConnectWithoutStudentInput[]
    createMany?: DrugDispensalCreateManyStudentInputEnvelope
    connect?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<MedicalRecordCreateWithoutStudentInput, MedicalRecordUncheckedCreateWithoutStudentInput> | MedicalRecordCreateWithoutStudentInput[] | MedicalRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutStudentInput | MedicalRecordCreateOrConnectWithoutStudentInput[]
    createMany?: MedicalRecordCreateManyStudentInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type VitalSignsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<VitalSignsCreateWithoutStudentInput, VitalSignsUncheckedCreateWithoutStudentInput> | VitalSignsCreateWithoutStudentInput[] | VitalSignsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutStudentInput | VitalSignsCreateOrConnectWithoutStudentInput[]
    createMany?: VitalSignsCreateManyStudentInputEnvelope
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AppointmentCreateWithoutStudentInput, AppointmentUncheckedCreateWithoutStudentInput> | AppointmentCreateWithoutStudentInput[] | AppointmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutStudentInput | AppointmentCreateOrConnectWithoutStudentInput[]
    createMany?: AppointmentCreateManyStudentInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type QueueUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<QueueCreateWithoutStudentInput, QueueUncheckedCreateWithoutStudentInput> | QueueCreateWithoutStudentInput[] | QueueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutStudentInput | QueueCreateOrConnectWithoutStudentInput[]
    createMany?: QueueCreateManyStudentInputEnvelope
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<BalanceTransactionCreateWithoutStudentInput, BalanceTransactionUncheckedCreateWithoutStudentInput> | BalanceTransactionCreateWithoutStudentInput[] | BalanceTransactionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BalanceTransactionCreateOrConnectWithoutStudentInput | BalanceTransactionCreateOrConnectWithoutStudentInput[]
    createMany?: BalanceTransactionCreateManyStudentInputEnvelope
    connect?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ConsultationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ConsultationCreateWithoutStudentInput, ConsultationUncheckedCreateWithoutStudentInput> | ConsultationCreateWithoutStudentInput[] | ConsultationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutStudentInput | ConsultationCreateOrConnectWithoutStudentInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutStudentInput | ConsultationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ConsultationCreateManyStudentInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutStudentInput | ConsultationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutStudentInput | ConsultationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PrescriptionCreateWithoutStudentInput, PrescriptionUncheckedCreateWithoutStudentInput> | PrescriptionCreateWithoutStudentInput[] | PrescriptionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutStudentInput | PrescriptionCreateOrConnectWithoutStudentInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutStudentInput | PrescriptionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PrescriptionCreateManyStudentInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutStudentInput | PrescriptionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutStudentInput | PrescriptionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type DrugDispensalUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DrugDispensalCreateWithoutStudentInput, DrugDispensalUncheckedCreateWithoutStudentInput> | DrugDispensalCreateWithoutStudentInput[] | DrugDispensalUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DrugDispensalCreateOrConnectWithoutStudentInput | DrugDispensalCreateOrConnectWithoutStudentInput[]
    upsert?: DrugDispensalUpsertWithWhereUniqueWithoutStudentInput | DrugDispensalUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DrugDispensalCreateManyStudentInputEnvelope
    set?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
    disconnect?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
    delete?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
    connect?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
    update?: DrugDispensalUpdateWithWhereUniqueWithoutStudentInput | DrugDispensalUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DrugDispensalUpdateManyWithWhereWithoutStudentInput | DrugDispensalUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DrugDispensalScalarWhereInput | DrugDispensalScalarWhereInput[]
  }

  export type MedicalRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutStudentInput, MedicalRecordUncheckedCreateWithoutStudentInput> | MedicalRecordCreateWithoutStudentInput[] | MedicalRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutStudentInput | MedicalRecordCreateOrConnectWithoutStudentInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutStudentInput | MedicalRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MedicalRecordCreateManyStudentInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutStudentInput | MedicalRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutStudentInput | MedicalRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type VitalSignsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<VitalSignsCreateWithoutStudentInput, VitalSignsUncheckedCreateWithoutStudentInput> | VitalSignsCreateWithoutStudentInput[] | VitalSignsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutStudentInput | VitalSignsCreateOrConnectWithoutStudentInput[]
    upsert?: VitalSignsUpsertWithWhereUniqueWithoutStudentInput | VitalSignsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: VitalSignsCreateManyStudentInputEnvelope
    set?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    disconnect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    delete?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    update?: VitalSignsUpdateWithWhereUniqueWithoutStudentInput | VitalSignsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: VitalSignsUpdateManyWithWhereWithoutStudentInput | VitalSignsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AppointmentCreateWithoutStudentInput, AppointmentUncheckedCreateWithoutStudentInput> | AppointmentCreateWithoutStudentInput[] | AppointmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutStudentInput | AppointmentCreateOrConnectWithoutStudentInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutStudentInput | AppointmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AppointmentCreateManyStudentInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutStudentInput | AppointmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutStudentInput | AppointmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type QueueUpdateManyWithoutStudentNestedInput = {
    create?: XOR<QueueCreateWithoutStudentInput, QueueUncheckedCreateWithoutStudentInput> | QueueCreateWithoutStudentInput[] | QueueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutStudentInput | QueueCreateOrConnectWithoutStudentInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutStudentInput | QueueUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: QueueCreateManyStudentInputEnvelope
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutStudentInput | QueueUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutStudentInput | QueueUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type BalanceTransactionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BalanceTransactionCreateWithoutStudentInput, BalanceTransactionUncheckedCreateWithoutStudentInput> | BalanceTransactionCreateWithoutStudentInput[] | BalanceTransactionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BalanceTransactionCreateOrConnectWithoutStudentInput | BalanceTransactionCreateOrConnectWithoutStudentInput[]
    upsert?: BalanceTransactionUpsertWithWhereUniqueWithoutStudentInput | BalanceTransactionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BalanceTransactionCreateManyStudentInputEnvelope
    set?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
    disconnect?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
    delete?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
    connect?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
    update?: BalanceTransactionUpdateWithWhereUniqueWithoutStudentInput | BalanceTransactionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BalanceTransactionUpdateManyWithWhereWithoutStudentInput | BalanceTransactionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BalanceTransactionScalarWhereInput | BalanceTransactionScalarWhereInput[]
  }

  export type ConsultationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ConsultationCreateWithoutStudentInput, ConsultationUncheckedCreateWithoutStudentInput> | ConsultationCreateWithoutStudentInput[] | ConsultationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutStudentInput | ConsultationCreateOrConnectWithoutStudentInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutStudentInput | ConsultationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ConsultationCreateManyStudentInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutStudentInput | ConsultationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutStudentInput | ConsultationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PrescriptionCreateWithoutStudentInput, PrescriptionUncheckedCreateWithoutStudentInput> | PrescriptionCreateWithoutStudentInput[] | PrescriptionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutStudentInput | PrescriptionCreateOrConnectWithoutStudentInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutStudentInput | PrescriptionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PrescriptionCreateManyStudentInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutStudentInput | PrescriptionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutStudentInput | PrescriptionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<DrugDispensalCreateWithoutStudentInput, DrugDispensalUncheckedCreateWithoutStudentInput> | DrugDispensalCreateWithoutStudentInput[] | DrugDispensalUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: DrugDispensalCreateOrConnectWithoutStudentInput | DrugDispensalCreateOrConnectWithoutStudentInput[]
    upsert?: DrugDispensalUpsertWithWhereUniqueWithoutStudentInput | DrugDispensalUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: DrugDispensalCreateManyStudentInputEnvelope
    set?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
    disconnect?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
    delete?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
    connect?: DrugDispensalWhereUniqueInput | DrugDispensalWhereUniqueInput[]
    update?: DrugDispensalUpdateWithWhereUniqueWithoutStudentInput | DrugDispensalUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: DrugDispensalUpdateManyWithWhereWithoutStudentInput | DrugDispensalUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: DrugDispensalScalarWhereInput | DrugDispensalScalarWhereInput[]
  }

  export type MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutStudentInput, MedicalRecordUncheckedCreateWithoutStudentInput> | MedicalRecordCreateWithoutStudentInput[] | MedicalRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutStudentInput | MedicalRecordCreateOrConnectWithoutStudentInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutStudentInput | MedicalRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MedicalRecordCreateManyStudentInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutStudentInput | MedicalRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutStudentInput | MedicalRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type VitalSignsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<VitalSignsCreateWithoutStudentInput, VitalSignsUncheckedCreateWithoutStudentInput> | VitalSignsCreateWithoutStudentInput[] | VitalSignsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutStudentInput | VitalSignsCreateOrConnectWithoutStudentInput[]
    upsert?: VitalSignsUpsertWithWhereUniqueWithoutStudentInput | VitalSignsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: VitalSignsCreateManyStudentInputEnvelope
    set?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    disconnect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    delete?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    update?: VitalSignsUpdateWithWhereUniqueWithoutStudentInput | VitalSignsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: VitalSignsUpdateManyWithWhereWithoutStudentInput | VitalSignsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AppointmentCreateWithoutStudentInput, AppointmentUncheckedCreateWithoutStudentInput> | AppointmentCreateWithoutStudentInput[] | AppointmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutStudentInput | AppointmentCreateOrConnectWithoutStudentInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutStudentInput | AppointmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AppointmentCreateManyStudentInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutStudentInput | AppointmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutStudentInput | AppointmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type QueueUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<QueueCreateWithoutStudentInput, QueueUncheckedCreateWithoutStudentInput> | QueueCreateWithoutStudentInput[] | QueueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutStudentInput | QueueCreateOrConnectWithoutStudentInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutStudentInput | QueueUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: QueueCreateManyStudentInputEnvelope
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutStudentInput | QueueUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutStudentInput | QueueUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BalanceTransactionCreateWithoutStudentInput, BalanceTransactionUncheckedCreateWithoutStudentInput> | BalanceTransactionCreateWithoutStudentInput[] | BalanceTransactionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BalanceTransactionCreateOrConnectWithoutStudentInput | BalanceTransactionCreateOrConnectWithoutStudentInput[]
    upsert?: BalanceTransactionUpsertWithWhereUniqueWithoutStudentInput | BalanceTransactionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BalanceTransactionCreateManyStudentInputEnvelope
    set?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
    disconnect?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
    delete?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
    connect?: BalanceTransactionWhereUniqueInput | BalanceTransactionWhereUniqueInput[]
    update?: BalanceTransactionUpdateWithWhereUniqueWithoutStudentInput | BalanceTransactionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BalanceTransactionUpdateManyWithWhereWithoutStudentInput | BalanceTransactionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BalanceTransactionScalarWhereInput | BalanceTransactionScalarWhereInput[]
  }

  export type ConsultationCreateNestedManyWithoutPhysicianInput = {
    create?: XOR<ConsultationCreateWithoutPhysicianInput, ConsultationUncheckedCreateWithoutPhysicianInput> | ConsultationCreateWithoutPhysicianInput[] | ConsultationUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPhysicianInput | ConsultationCreateOrConnectWithoutPhysicianInput[]
    createMany?: ConsultationCreateManyPhysicianInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPhysicianInput = {
    create?: XOR<PrescriptionCreateWithoutPhysicianInput, PrescriptionUncheckedCreateWithoutPhysicianInput> | PrescriptionCreateWithoutPhysicianInput[] | PrescriptionUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPhysicianInput | PrescriptionCreateOrConnectWithoutPhysicianInput[]
    createMany?: PrescriptionCreateManyPhysicianInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutPhysicianInput = {
    create?: XOR<AppointmentCreateWithoutPhysicianInput, AppointmentUncheckedCreateWithoutPhysicianInput> | AppointmentCreateWithoutPhysicianInput[] | AppointmentUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPhysicianInput | AppointmentCreateOrConnectWithoutPhysicianInput[]
    createMany?: AppointmentCreateManyPhysicianInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ConsultationUncheckedCreateNestedManyWithoutPhysicianInput = {
    create?: XOR<ConsultationCreateWithoutPhysicianInput, ConsultationUncheckedCreateWithoutPhysicianInput> | ConsultationCreateWithoutPhysicianInput[] | ConsultationUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPhysicianInput | ConsultationCreateOrConnectWithoutPhysicianInput[]
    createMany?: ConsultationCreateManyPhysicianInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPhysicianInput = {
    create?: XOR<PrescriptionCreateWithoutPhysicianInput, PrescriptionUncheckedCreateWithoutPhysicianInput> | PrescriptionCreateWithoutPhysicianInput[] | PrescriptionUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPhysicianInput | PrescriptionCreateOrConnectWithoutPhysicianInput[]
    createMany?: PrescriptionCreateManyPhysicianInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPhysicianInput = {
    create?: XOR<AppointmentCreateWithoutPhysicianInput, AppointmentUncheckedCreateWithoutPhysicianInput> | AppointmentCreateWithoutPhysicianInput[] | AppointmentUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPhysicianInput | AppointmentCreateOrConnectWithoutPhysicianInput[]
    createMany?: AppointmentCreateManyPhysicianInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ConsultationUpdateManyWithoutPhysicianNestedInput = {
    create?: XOR<ConsultationCreateWithoutPhysicianInput, ConsultationUncheckedCreateWithoutPhysicianInput> | ConsultationCreateWithoutPhysicianInput[] | ConsultationUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPhysicianInput | ConsultationCreateOrConnectWithoutPhysicianInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPhysicianInput | ConsultationUpsertWithWhereUniqueWithoutPhysicianInput[]
    createMany?: ConsultationCreateManyPhysicianInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPhysicianInput | ConsultationUpdateWithWhereUniqueWithoutPhysicianInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPhysicianInput | ConsultationUpdateManyWithWhereWithoutPhysicianInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPhysicianNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPhysicianInput, PrescriptionUncheckedCreateWithoutPhysicianInput> | PrescriptionCreateWithoutPhysicianInput[] | PrescriptionUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPhysicianInput | PrescriptionCreateOrConnectWithoutPhysicianInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPhysicianInput | PrescriptionUpsertWithWhereUniqueWithoutPhysicianInput[]
    createMany?: PrescriptionCreateManyPhysicianInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPhysicianInput | PrescriptionUpdateWithWhereUniqueWithoutPhysicianInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPhysicianInput | PrescriptionUpdateManyWithWhereWithoutPhysicianInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutPhysicianNestedInput = {
    create?: XOR<AppointmentCreateWithoutPhysicianInput, AppointmentUncheckedCreateWithoutPhysicianInput> | AppointmentCreateWithoutPhysicianInput[] | AppointmentUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPhysicianInput | AppointmentCreateOrConnectWithoutPhysicianInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPhysicianInput | AppointmentUpsertWithWhereUniqueWithoutPhysicianInput[]
    createMany?: AppointmentCreateManyPhysicianInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPhysicianInput | AppointmentUpdateWithWhereUniqueWithoutPhysicianInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPhysicianInput | AppointmentUpdateManyWithWhereWithoutPhysicianInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ConsultationUncheckedUpdateManyWithoutPhysicianNestedInput = {
    create?: XOR<ConsultationCreateWithoutPhysicianInput, ConsultationUncheckedCreateWithoutPhysicianInput> | ConsultationCreateWithoutPhysicianInput[] | ConsultationUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPhysicianInput | ConsultationCreateOrConnectWithoutPhysicianInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPhysicianInput | ConsultationUpsertWithWhereUniqueWithoutPhysicianInput[]
    createMany?: ConsultationCreateManyPhysicianInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPhysicianInput | ConsultationUpdateWithWhereUniqueWithoutPhysicianInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPhysicianInput | ConsultationUpdateManyWithWhereWithoutPhysicianInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPhysicianNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPhysicianInput, PrescriptionUncheckedCreateWithoutPhysicianInput> | PrescriptionCreateWithoutPhysicianInput[] | PrescriptionUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPhysicianInput | PrescriptionCreateOrConnectWithoutPhysicianInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPhysicianInput | PrescriptionUpsertWithWhereUniqueWithoutPhysicianInput[]
    createMany?: PrescriptionCreateManyPhysicianInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPhysicianInput | PrescriptionUpdateWithWhereUniqueWithoutPhysicianInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPhysicianInput | PrescriptionUpdateManyWithWhereWithoutPhysicianInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPhysicianNestedInput = {
    create?: XOR<AppointmentCreateWithoutPhysicianInput, AppointmentUncheckedCreateWithoutPhysicianInput> | AppointmentCreateWithoutPhysicianInput[] | AppointmentUncheckedCreateWithoutPhysicianInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPhysicianInput | AppointmentCreateOrConnectWithoutPhysicianInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPhysicianInput | AppointmentUpsertWithWhereUniqueWithoutPhysicianInput[]
    createMany?: AppointmentCreateManyPhysicianInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPhysicianInput | AppointmentUpdateWithWhereUniqueWithoutPhysicianInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPhysicianInput | AppointmentUpdateManyWithWhereWithoutPhysicianInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutQueueInput = {
    create?: XOR<StudentCreateWithoutQueueInput, StudentUncheckedCreateWithoutQueueInput>
    connectOrCreate?: StudentCreateOrConnectWithoutQueueInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumpriorityFieldUpdateOperationsInput = {
    set?: $Enums.priority
  }

  export type StudentUpdateOneRequiredWithoutQueueNestedInput = {
    create?: XOR<StudentCreateWithoutQueueInput, StudentUncheckedCreateWithoutQueueInput>
    connectOrCreate?: StudentCreateOrConnectWithoutQueueInput
    upsert?: StudentUpsertWithoutQueueInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutQueueInput, StudentUpdateWithoutQueueInput>, StudentUncheckedUpdateWithoutQueueInput>
  }

  export type StudentCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<StudentCreateWithoutAppointmentsInput, StudentUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAppointmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type PhysicianCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PhysicianCreateWithoutAppointmentsInput, PhysicianUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutAppointmentsInput
    connect?: PhysicianWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<StudentCreateWithoutAppointmentsInput, StudentUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAppointmentsInput
    upsert?: StudentUpsertWithoutAppointmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAppointmentsInput, StudentUpdateWithoutAppointmentsInput>, StudentUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PhysicianUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<PhysicianCreateWithoutAppointmentsInput, PhysicianUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutAppointmentsInput
    upsert?: PhysicianUpsertWithoutAppointmentsInput
    disconnect?: PhysicianWhereInput | boolean
    delete?: PhysicianWhereInput | boolean
    connect?: PhysicianWhereUniqueInput
    update?: XOR<XOR<PhysicianUpdateToOneWithWhereWithoutAppointmentsInput, PhysicianUpdateWithoutAppointmentsInput>, PhysicianUncheckedUpdateWithoutAppointmentsInput>
  }

  export type StudentCreateNestedOneWithoutVitalSignsInput = {
    create?: XOR<StudentCreateWithoutVitalSignsInput, StudentUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutVitalSignsInput
    connect?: StudentWhereUniqueInput
  }

  export type ConsultationCreateNestedOneWithoutVitalSignsInput = {
    create?: XOR<ConsultationCreateWithoutVitalSignsInput, ConsultationUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutVitalSignsInput
    connect?: ConsultationWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutVitalSignsNestedInput = {
    create?: XOR<StudentCreateWithoutVitalSignsInput, StudentUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutVitalSignsInput
    upsert?: StudentUpsertWithoutVitalSignsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutVitalSignsInput, StudentUpdateWithoutVitalSignsInput>, StudentUncheckedUpdateWithoutVitalSignsInput>
  }

  export type ConsultationUpdateOneWithoutVitalSignsNestedInput = {
    create?: XOR<ConsultationCreateWithoutVitalSignsInput, ConsultationUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutVitalSignsInput
    upsert?: ConsultationUpsertWithoutVitalSignsInput
    disconnect?: ConsultationWhereInput | boolean
    delete?: ConsultationWhereInput | boolean
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutVitalSignsInput, ConsultationUpdateWithoutVitalSignsInput>, ConsultationUncheckedUpdateWithoutVitalSignsInput>
  }

  export type StudentCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<StudentCreateWithoutConsultationsInput, StudentUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutConsultationsInput
    connect?: StudentWhereUniqueInput
  }

  export type PhysicianCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<PhysicianCreateWithoutConsultationsInput, PhysicianUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutConsultationsInput
    connect?: PhysicianWhereUniqueInput
  }

  export type VitalSignsCreateNestedManyWithoutConsultationInput = {
    create?: XOR<VitalSignsCreateWithoutConsultationInput, VitalSignsUncheckedCreateWithoutConsultationInput> | VitalSignsCreateWithoutConsultationInput[] | VitalSignsUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutConsultationInput | VitalSignsCreateOrConnectWithoutConsultationInput[]
    createMany?: VitalSignsCreateManyConsultationInputEnvelope
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutConsultationInput = {
    create?: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput> | PrescriptionCreateWithoutConsultationInput[] | PrescriptionUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutConsultationInput | PrescriptionCreateOrConnectWithoutConsultationInput[]
    createMany?: PrescriptionCreateManyConsultationInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type VitalSignsUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<VitalSignsCreateWithoutConsultationInput, VitalSignsUncheckedCreateWithoutConsultationInput> | VitalSignsCreateWithoutConsultationInput[] | VitalSignsUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutConsultationInput | VitalSignsCreateOrConnectWithoutConsultationInput[]
    createMany?: VitalSignsCreateManyConsultationInputEnvelope
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput> | PrescriptionCreateWithoutConsultationInput[] | PrescriptionUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutConsultationInput | PrescriptionCreateOrConnectWithoutConsultationInput[]
    createMany?: PrescriptionCreateManyConsultationInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type EnumconsultationStatusFieldUpdateOperationsInput = {
    set?: $Enums.consultationStatus
  }

  export type StudentUpdateOneRequiredWithoutConsultationsNestedInput = {
    create?: XOR<StudentCreateWithoutConsultationsInput, StudentUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutConsultationsInput
    upsert?: StudentUpsertWithoutConsultationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutConsultationsInput, StudentUpdateWithoutConsultationsInput>, StudentUncheckedUpdateWithoutConsultationsInput>
  }

  export type PhysicianUpdateOneRequiredWithoutConsultationsNestedInput = {
    create?: XOR<PhysicianCreateWithoutConsultationsInput, PhysicianUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutConsultationsInput
    upsert?: PhysicianUpsertWithoutConsultationsInput
    connect?: PhysicianWhereUniqueInput
    update?: XOR<XOR<PhysicianUpdateToOneWithWhereWithoutConsultationsInput, PhysicianUpdateWithoutConsultationsInput>, PhysicianUncheckedUpdateWithoutConsultationsInput>
  }

  export type VitalSignsUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<VitalSignsCreateWithoutConsultationInput, VitalSignsUncheckedCreateWithoutConsultationInput> | VitalSignsCreateWithoutConsultationInput[] | VitalSignsUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutConsultationInput | VitalSignsCreateOrConnectWithoutConsultationInput[]
    upsert?: VitalSignsUpsertWithWhereUniqueWithoutConsultationInput | VitalSignsUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: VitalSignsCreateManyConsultationInputEnvelope
    set?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    disconnect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    delete?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    update?: VitalSignsUpdateWithWhereUniqueWithoutConsultationInput | VitalSignsUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: VitalSignsUpdateManyWithWhereWithoutConsultationInput | VitalSignsUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput> | PrescriptionCreateWithoutConsultationInput[] | PrescriptionUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutConsultationInput | PrescriptionCreateOrConnectWithoutConsultationInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutConsultationInput | PrescriptionUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: PrescriptionCreateManyConsultationInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutConsultationInput | PrescriptionUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutConsultationInput | PrescriptionUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type VitalSignsUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<VitalSignsCreateWithoutConsultationInput, VitalSignsUncheckedCreateWithoutConsultationInput> | VitalSignsCreateWithoutConsultationInput[] | VitalSignsUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutConsultationInput | VitalSignsCreateOrConnectWithoutConsultationInput[]
    upsert?: VitalSignsUpsertWithWhereUniqueWithoutConsultationInput | VitalSignsUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: VitalSignsCreateManyConsultationInputEnvelope
    set?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    disconnect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    delete?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    update?: VitalSignsUpdateWithWhereUniqueWithoutConsultationInput | VitalSignsUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: VitalSignsUpdateManyWithWhereWithoutConsultationInput | VitalSignsUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput> | PrescriptionCreateWithoutConsultationInput[] | PrescriptionUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutConsultationInput | PrescriptionCreateOrConnectWithoutConsultationInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutConsultationInput | PrescriptionUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: PrescriptionCreateManyConsultationInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutConsultationInput | PrescriptionUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutConsultationInput | PrescriptionUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<StudentCreateWithoutPrescriptionsInput, StudentUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPrescriptionsInput
    connect?: StudentWhereUniqueInput
  }

  export type PhysicianCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<PhysicianCreateWithoutPrescriptionsInput, PhysicianUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutPrescriptionsInput
    connect?: PhysicianWhereUniqueInput
  }

  export type ConsultationCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<ConsultationCreateWithoutPrescriptionsInput, ConsultationUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutPrescriptionsInput
    connect?: ConsultationWhereUniqueInput
  }

  export type PrescriptionItemCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type EnumprescriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.prescriptionStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<StudentCreateWithoutPrescriptionsInput, StudentUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPrescriptionsInput
    upsert?: StudentUpsertWithoutPrescriptionsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPrescriptionsInput, StudentUpdateWithoutPrescriptionsInput>, StudentUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PhysicianUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<PhysicianCreateWithoutPrescriptionsInput, PhysicianUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PhysicianCreateOrConnectWithoutPrescriptionsInput
    upsert?: PhysicianUpsertWithoutPrescriptionsInput
    connect?: PhysicianWhereUniqueInput
    update?: XOR<XOR<PhysicianUpdateToOneWithWhereWithoutPrescriptionsInput, PhysicianUpdateWithoutPrescriptionsInput>, PhysicianUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type ConsultationUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<ConsultationCreateWithoutPrescriptionsInput, ConsultationUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutPrescriptionsInput
    upsert?: ConsultationUpsertWithoutPrescriptionsInput
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutPrescriptionsInput, ConsultationUpdateWithoutPrescriptionsInput>, ConsultationUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PrescriptionItemUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PrescriptionCreateNestedOneWithoutPrescriptionItemsInput = {
    create?: XOR<PrescriptionCreateWithoutPrescriptionItemsInput, PrescriptionUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPrescriptionItemsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPrescriptionItemsInput = {
    create?: XOR<ProductCreateWithoutPrescriptionItemsInput, ProductUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPrescriptionItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PrescriptionUpdateOneRequiredWithoutPrescriptionItemsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPrescriptionItemsInput, PrescriptionUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPrescriptionItemsInput
    upsert?: PrescriptionUpsertWithoutPrescriptionItemsInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutPrescriptionItemsInput, PrescriptionUpdateWithoutPrescriptionItemsInput>, PrescriptionUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPrescriptionItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPrescriptionItemsInput, ProductUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPrescriptionItemsInput
    upsert?: ProductUpsertWithoutPrescriptionItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPrescriptionItemsInput, ProductUpdateWithoutPrescriptionItemsInput>, ProductUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type StudentCreateNestedOneWithoutDrugDispensalsInput = {
    create?: XOR<StudentCreateWithoutDrugDispensalsInput, StudentUncheckedCreateWithoutDrugDispensalsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDrugDispensalsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutDrugDispensalsNestedInput = {
    create?: XOR<StudentCreateWithoutDrugDispensalsInput, StudentUncheckedCreateWithoutDrugDispensalsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDrugDispensalsInput
    upsert?: StudentUpsertWithoutDrugDispensalsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutDrugDispensalsInput, StudentUpdateWithoutDrugDispensalsInput>, StudentUncheckedUpdateWithoutDrugDispensalsInput>
  }

  export type StudentCreateNestedOneWithoutMedicalRecordsInput = {
    create?: XOR<StudentCreateWithoutMedicalRecordsInput, StudentUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMedicalRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutMedicalRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutMedicalRecordsInput, StudentUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMedicalRecordsInput
    upsert?: StudentUpsertWithoutMedicalRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutMedicalRecordsInput, StudentUpdateWithoutMedicalRecordsInput>, StudentUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type PrescriptionItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PrescriptionItemCreateWithoutProductInput, PrescriptionItemUncheckedCreateWithoutProductInput> | PrescriptionItemCreateWithoutProductInput[] | PrescriptionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutProductInput | PrescriptionItemCreateOrConnectWithoutProductInput[]
    createMany?: PrescriptionItemCreateManyProductInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PrescriptionItemCreateWithoutProductInput, PrescriptionItemUncheckedCreateWithoutProductInput> | PrescriptionItemCreateWithoutProductInput[] | PrescriptionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutProductInput | PrescriptionItemCreateOrConnectWithoutProductInput[]
    createMany?: PrescriptionItemCreateManyProductInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type EnumunitFieldUpdateOperationsInput = {
    set?: $Enums.unit
  }

  export type PrescriptionItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutProductInput, PrescriptionItemUncheckedCreateWithoutProductInput> | PrescriptionItemCreateWithoutProductInput[] | PrescriptionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutProductInput | PrescriptionItemCreateOrConnectWithoutProductInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutProductInput | PrescriptionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PrescriptionItemCreateManyProductInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutProductInput | PrescriptionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutProductInput | PrescriptionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutProductInput, PrescriptionItemUncheckedCreateWithoutProductInput> | PrescriptionItemCreateWithoutProductInput[] | PrescriptionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutProductInput | PrescriptionItemCreateOrConnectWithoutProductInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutProductInput | PrescriptionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PrescriptionItemCreateManyProductInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutProductInput | PrescriptionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutProductInput | PrescriptionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type SupplierCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseInput
    connect?: SupplierWhereUniqueInput
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type PurchaseItemUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type SupplierUpdateOneWithoutPurchaseNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseInput
    upsert?: SupplierUpsertWithoutPurchaseInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseInput, SupplierUpdateWithoutPurchaseInput>, SupplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutPurchaseItemInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemInput, ProductUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutPurchaseItemInput = {
    create?: XOR<PurchaseCreateWithoutPurchaseItemInput, PurchaseUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutPurchaseItemInput
    connect?: PurchaseWhereUniqueInput
  }

  export type ProductUpdateOneWithoutPurchaseItemNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemInput, ProductUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemInput
    upsert?: ProductUpsertWithoutPurchaseItemInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseItemInput, ProductUpdateWithoutPurchaseItemInput>, ProductUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type PurchaseUpdateOneWithoutPurchaseItemNestedInput = {
    create?: XOR<PurchaseCreateWithoutPurchaseItemInput, PurchaseUncheckedCreateWithoutPurchaseItemInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutPurchaseItemInput
    upsert?: PurchaseUpsertWithoutPurchaseItemInput
    disconnect?: PurchaseWhereInput | boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutPurchaseItemInput, PurchaseUpdateWithoutPurchaseItemInput>, PurchaseUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type StudentCreateNestedOneWithoutBalanceTransactionInput = {
    create?: XOR<StudentCreateWithoutBalanceTransactionInput, StudentUncheckedCreateWithoutBalanceTransactionInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBalanceTransactionInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutBalanceTransactionNestedInput = {
    create?: XOR<StudentCreateWithoutBalanceTransactionInput, StudentUncheckedCreateWithoutBalanceTransactionInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBalanceTransactionInput
    upsert?: StudentUpsertWithoutBalanceTransactionInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutBalanceTransactionInput, StudentUpdateWithoutBalanceTransactionInput>, StudentUncheckedUpdateWithoutBalanceTransactionInput>
  }

  export type PurchaseCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSupplierInput | PurchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSupplierInput | PurchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSupplierInput | PurchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput> | PurchaseCreateWithoutSupplierInput[] | PurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutSupplierInput | PurchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutSupplierInput | PurchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseCreateManySupplierInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutSupplierInput | PurchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutSupplierInput | PurchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumroleFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[]
    notIn?: $Enums.role[]
    not?: NestedEnumroleFilter<$PrismaModel> | $Enums.role
  }

  export type NestedEnumroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[]
    notIn?: $Enums.role[]
    not?: NestedEnumroleWithAggregatesFilter<$PrismaModel> | $Enums.role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleFilter<$PrismaModel>
    _max?: NestedEnumroleFilter<$PrismaModel>
  }

  export type NestedEnummodeFilter<$PrismaModel = never> = {
    equals?: $Enums.mode | EnummodeFieldRefInput<$PrismaModel>
    in?: $Enums.mode[]
    notIn?: $Enums.mode[]
    not?: NestedEnummodeFilter<$PrismaModel> | $Enums.mode
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnummodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.mode | EnummodeFieldRefInput<$PrismaModel>
    in?: $Enums.mode[]
    notIn?: $Enums.mode[]
    not?: NestedEnummodeWithAggregatesFilter<$PrismaModel> | $Enums.mode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummodeFilter<$PrismaModel>
    _max?: NestedEnummodeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumpriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.priority | EnumpriorityFieldRefInput<$PrismaModel>
    in?: $Enums.priority[]
    notIn?: $Enums.priority[]
    not?: NestedEnumpriorityFilter<$PrismaModel> | $Enums.priority
  }

  export type NestedEnumpriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.priority | EnumpriorityFieldRefInput<$PrismaModel>
    in?: $Enums.priority[]
    notIn?: $Enums.priority[]
    not?: NestedEnumpriorityWithAggregatesFilter<$PrismaModel> | $Enums.priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpriorityFilter<$PrismaModel>
    _max?: NestedEnumpriorityFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumconsultationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.consultationStatus | EnumconsultationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.consultationStatus[]
    notIn?: $Enums.consultationStatus[]
    not?: NestedEnumconsultationStatusFilter<$PrismaModel> | $Enums.consultationStatus
  }

  export type NestedEnumconsultationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.consultationStatus | EnumconsultationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.consultationStatus[]
    notIn?: $Enums.consultationStatus[]
    not?: NestedEnumconsultationStatusWithAggregatesFilter<$PrismaModel> | $Enums.consultationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumconsultationStatusFilter<$PrismaModel>
    _max?: NestedEnumconsultationStatusFilter<$PrismaModel>
  }

  export type NestedEnumprescriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.prescriptionStatus | EnumprescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.prescriptionStatus[]
    notIn?: $Enums.prescriptionStatus[]
    not?: NestedEnumprescriptionStatusFilter<$PrismaModel> | $Enums.prescriptionStatus
  }

  export type NestedEnumprescriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.prescriptionStatus | EnumprescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.prescriptionStatus[]
    notIn?: $Enums.prescriptionStatus[]
    not?: NestedEnumprescriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.prescriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprescriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumprescriptionStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumunitFilter<$PrismaModel = never> = {
    equals?: $Enums.unit | EnumunitFieldRefInput<$PrismaModel>
    in?: $Enums.unit[]
    notIn?: $Enums.unit[]
    not?: NestedEnumunitFilter<$PrismaModel> | $Enums.unit
  }

  export type NestedEnumunitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.unit | EnumunitFieldRefInput<$PrismaModel>
    in?: $Enums.unit[]
    notIn?: $Enums.unit[]
    not?: NestedEnumunitWithAggregatesFilter<$PrismaModel> | $Enums.unit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumunitFilter<$PrismaModel>
    _max?: NestedEnumunitFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ConsultationCreateWithoutStudentInput = {
    id?: string
    consultationNo: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    physician: PhysicianCreateNestedOneWithoutConsultationsInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutConsultationInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutStudentInput = {
    id?: string
    consultationNo: string
    physicianId: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutConsultationInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutStudentInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutStudentInput, ConsultationUncheckedCreateWithoutStudentInput>
  }

  export type ConsultationCreateManyStudentInputEnvelope = {
    data: ConsultationCreateManyStudentInput | ConsultationCreateManyStudentInput[]
  }

  export type PrescriptionCreateWithoutStudentInput = {
    id?: string
    prescriptionNo: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    physician: PhysicianCreateNestedOneWithoutPrescriptionsInput
    consultation: ConsultationCreateNestedOneWithoutPrescriptionsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutStudentInput = {
    id?: string
    prescriptionNo: string
    physicianId: string
    consultationId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutStudentInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutStudentInput, PrescriptionUncheckedCreateWithoutStudentInput>
  }

  export type PrescriptionCreateManyStudentInputEnvelope = {
    data: PrescriptionCreateManyStudentInput | PrescriptionCreateManyStudentInput[]
  }

  export type DrugDispensalCreateWithoutStudentInput = {
    id?: string
    dispensalNo: string
    prescriptionId: string
    prescriptionNo: string
    dispensedBy: string
    dispensedItems: string
    totalAmount: number
    notes?: string | null
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type DrugDispensalUncheckedCreateWithoutStudentInput = {
    id?: string
    dispensalNo: string
    prescriptionId: string
    prescriptionNo: string
    dispensedBy: string
    dispensedItems: string
    totalAmount: number
    notes?: string | null
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type DrugDispensalCreateOrConnectWithoutStudentInput = {
    where: DrugDispensalWhereUniqueInput
    create: XOR<DrugDispensalCreateWithoutStudentInput, DrugDispensalUncheckedCreateWithoutStudentInput>
  }

  export type DrugDispensalCreateManyStudentInputEnvelope = {
    data: DrugDispensalCreateManyStudentInput | DrugDispensalCreateManyStudentInput[]
  }

  export type MedicalRecordCreateWithoutStudentInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    recordData?: string | null
    attachments?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type MedicalRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    recordData?: string | null
    attachments?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type MedicalRecordCreateOrConnectWithoutStudentInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutStudentInput, MedicalRecordUncheckedCreateWithoutStudentInput>
  }

  export type MedicalRecordCreateManyStudentInputEnvelope = {
    data: MedicalRecordCreateManyStudentInput | MedicalRecordCreateManyStudentInput[]
  }

  export type VitalSignsCreateWithoutStudentInput = {
    id?: string
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
    consultation?: ConsultationCreateNestedOneWithoutVitalSignsInput
  }

  export type VitalSignsUncheckedCreateWithoutStudentInput = {
    id?: string
    consultationId?: string | null
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type VitalSignsCreateOrConnectWithoutStudentInput = {
    where: VitalSignsWhereUniqueInput
    create: XOR<VitalSignsCreateWithoutStudentInput, VitalSignsUncheckedCreateWithoutStudentInput>
  }

  export type VitalSignsCreateManyStudentInputEnvelope = {
    data: VitalSignsCreateManyStudentInput | VitalSignsCreateManyStudentInput[]
  }

  export type AppointmentCreateWithoutStudentInput = {
    id?: string
    appointmentNo: string
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    physician?: PhysicianCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutStudentInput = {
    id?: string
    appointmentNo: string
    physicianId?: string | null
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type AppointmentCreateOrConnectWithoutStudentInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutStudentInput, AppointmentUncheckedCreateWithoutStudentInput>
  }

  export type AppointmentCreateManyStudentInputEnvelope = {
    data: AppointmentCreateManyStudentInput | AppointmentCreateManyStudentInput[]
  }

  export type QueueCreateWithoutStudentInput = {
    id?: string
    queueNumber: number
    priority?: $Enums.priority
    status?: string
    checkInTime?: Date | string
    calledTime?: Date | string | null
    completedTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type QueueUncheckedCreateWithoutStudentInput = {
    id?: string
    queueNumber: number
    priority?: $Enums.priority
    status?: string
    checkInTime?: Date | string
    calledTime?: Date | string | null
    completedTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type QueueCreateOrConnectWithoutStudentInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutStudentInput, QueueUncheckedCreateWithoutStudentInput>
  }

  export type QueueCreateManyStudentInputEnvelope = {
    data: QueueCreateManyStudentInput | QueueCreateManyStudentInput[]
  }

  export type BalanceTransactionCreateWithoutStudentInput = {
    id?: string
    amount: number
    type: string
    description: string
    paymentMethod?: string | null
    reference?: string | null
    prescriptionId?: string | null
    balanceAfter: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type BalanceTransactionUncheckedCreateWithoutStudentInput = {
    id?: string
    amount: number
    type: string
    description: string
    paymentMethod?: string | null
    reference?: string | null
    prescriptionId?: string | null
    balanceAfter: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type BalanceTransactionCreateOrConnectWithoutStudentInput = {
    where: BalanceTransactionWhereUniqueInput
    create: XOR<BalanceTransactionCreateWithoutStudentInput, BalanceTransactionUncheckedCreateWithoutStudentInput>
  }

  export type BalanceTransactionCreateManyStudentInputEnvelope = {
    data: BalanceTransactionCreateManyStudentInput | BalanceTransactionCreateManyStudentInput[]
  }

  export type ConsultationUpsertWithWhereUniqueWithoutStudentInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutStudentInput, ConsultationUncheckedUpdateWithoutStudentInput>
    create: XOR<ConsultationCreateWithoutStudentInput, ConsultationUncheckedCreateWithoutStudentInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutStudentInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutStudentInput, ConsultationUncheckedUpdateWithoutStudentInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutStudentInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutStudentInput>
  }

  export type ConsultationScalarWhereInput = {
    AND?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    OR?: ConsultationScalarWhereInput[]
    NOT?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    id?: StringFilter<"Consultation"> | string
    consultationNo?: StringFilter<"Consultation"> | string
    studentId?: StringFilter<"Consultation"> | string
    physicianId?: StringFilter<"Consultation"> | string
    chiefComplaint?: StringFilter<"Consultation"> | string
    historyOfPresenting?: StringNullableFilter<"Consultation"> | string | null
    symptoms?: StringFilter<"Consultation"> | string
    physicalExamination?: StringNullableFilter<"Consultation"> | string | null
    diagnosis?: StringFilter<"Consultation"> | string
    differentialDiagnosis?: StringNullableFilter<"Consultation"> | string | null
    treatmentPlan?: StringNullableFilter<"Consultation"> | string | null
    notes?: StringNullableFilter<"Consultation"> | string | null
    followUpDate?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    status?: EnumconsultationStatusFilter<"Consultation"> | $Enums.consultationStatus
    priority?: EnumpriorityFilter<"Consultation"> | $Enums.priority
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    completedAt?: DateTimeNullableFilter<"Consultation"> | Date | string | null
    isDeleted?: BoolFilter<"Consultation"> | boolean
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutStudentInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutStudentInput, PrescriptionUncheckedUpdateWithoutStudentInput>
    create: XOR<PrescriptionCreateWithoutStudentInput, PrescriptionUncheckedCreateWithoutStudentInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutStudentInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutStudentInput, PrescriptionUncheckedUpdateWithoutStudentInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutStudentInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutStudentInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: StringFilter<"Prescription"> | string
    prescriptionNo?: StringFilter<"Prescription"> | string
    studentId?: StringFilter<"Prescription"> | string
    physicianId?: StringFilter<"Prescription"> | string
    consultationId?: StringFilter<"Prescription"> | string
    diagnosis?: StringFilter<"Prescription"> | string
    instructions?: StringNullableFilter<"Prescription"> | string | null
    status?: EnumprescriptionStatusFilter<"Prescription"> | $Enums.prescriptionStatus
    priority?: EnumpriorityFilter<"Prescription"> | $Enums.priority
    isPaid?: BoolFilter<"Prescription"> | boolean
    isDispensed?: BoolFilter<"Prescription"> | boolean
    dispensedBy?: StringNullableFilter<"Prescription"> | string | null
    dispensedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    totalCost?: FloatFilter<"Prescription"> | number
    amountPaid?: FloatFilter<"Prescription"> | number
    discount?: FloatFilter<"Prescription"> | number
    pharmacyNotified?: BoolFilter<"Prescription"> | boolean
    notifiedAt?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    studentNotified?: BoolFilter<"Prescription"> | boolean
    validUntil?: DateTimeNullableFilter<"Prescription"> | Date | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    sync?: BoolFilter<"Prescription"> | boolean
    isDeleted?: BoolFilter<"Prescription"> | boolean
  }

  export type DrugDispensalUpsertWithWhereUniqueWithoutStudentInput = {
    where: DrugDispensalWhereUniqueInput
    update: XOR<DrugDispensalUpdateWithoutStudentInput, DrugDispensalUncheckedUpdateWithoutStudentInput>
    create: XOR<DrugDispensalCreateWithoutStudentInput, DrugDispensalUncheckedCreateWithoutStudentInput>
  }

  export type DrugDispensalUpdateWithWhereUniqueWithoutStudentInput = {
    where: DrugDispensalWhereUniqueInput
    data: XOR<DrugDispensalUpdateWithoutStudentInput, DrugDispensalUncheckedUpdateWithoutStudentInput>
  }

  export type DrugDispensalUpdateManyWithWhereWithoutStudentInput = {
    where: DrugDispensalScalarWhereInput
    data: XOR<DrugDispensalUpdateManyMutationInput, DrugDispensalUncheckedUpdateManyWithoutStudentInput>
  }

  export type DrugDispensalScalarWhereInput = {
    AND?: DrugDispensalScalarWhereInput | DrugDispensalScalarWhereInput[]
    OR?: DrugDispensalScalarWhereInput[]
    NOT?: DrugDispensalScalarWhereInput | DrugDispensalScalarWhereInput[]
    id?: StringFilter<"DrugDispensal"> | string
    dispensalNo?: StringFilter<"DrugDispensal"> | string
    prescriptionId?: StringFilter<"DrugDispensal"> | string
    prescriptionNo?: StringFilter<"DrugDispensal"> | string
    studentId?: StringFilter<"DrugDispensal"> | string
    dispensedBy?: StringFilter<"DrugDispensal"> | string
    dispensedItems?: StringFilter<"DrugDispensal"> | string
    totalAmount?: FloatFilter<"DrugDispensal"> | number
    notes?: StringNullableFilter<"DrugDispensal"> | string | null
    createdAt?: DateTimeFilter<"DrugDispensal"> | Date | string
    isDeleted?: BoolFilter<"DrugDispensal"> | boolean
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutStudentInput, MedicalRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<MedicalRecordCreateWithoutStudentInput, MedicalRecordUncheckedCreateWithoutStudentInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutStudentInput, MedicalRecordUncheckedUpdateWithoutStudentInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutStudentInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type MedicalRecordScalarWhereInput = {
    AND?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
    OR?: MedicalRecordScalarWhereInput[]
    NOT?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
    id?: StringFilter<"MedicalRecord"> | string
    studentId?: StringFilter<"MedicalRecord"> | string
    recordType?: StringFilter<"MedicalRecord"> | string
    title?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    recordData?: StringNullableFilter<"MedicalRecord"> | string | null
    attachments?: StringNullableFilter<"MedicalRecord"> | string | null
    createdBy?: StringFilter<"MedicalRecord"> | string
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    isDeleted?: BoolFilter<"MedicalRecord"> | boolean
  }

  export type VitalSignsUpsertWithWhereUniqueWithoutStudentInput = {
    where: VitalSignsWhereUniqueInput
    update: XOR<VitalSignsUpdateWithoutStudentInput, VitalSignsUncheckedUpdateWithoutStudentInput>
    create: XOR<VitalSignsCreateWithoutStudentInput, VitalSignsUncheckedCreateWithoutStudentInput>
  }

  export type VitalSignsUpdateWithWhereUniqueWithoutStudentInput = {
    where: VitalSignsWhereUniqueInput
    data: XOR<VitalSignsUpdateWithoutStudentInput, VitalSignsUncheckedUpdateWithoutStudentInput>
  }

  export type VitalSignsUpdateManyWithWhereWithoutStudentInput = {
    where: VitalSignsScalarWhereInput
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyWithoutStudentInput>
  }

  export type VitalSignsScalarWhereInput = {
    AND?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
    OR?: VitalSignsScalarWhereInput[]
    NOT?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
    id?: StringFilter<"VitalSigns"> | string
    studentId?: StringFilter<"VitalSigns"> | string
    consultationId?: StringNullableFilter<"VitalSigns"> | string | null
    temperature?: FloatNullableFilter<"VitalSigns"> | number | null
    bloodPressure?: StringNullableFilter<"VitalSigns"> | string | null
    pulse?: IntNullableFilter<"VitalSigns"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    weight?: FloatNullableFilter<"VitalSigns"> | number | null
    height?: FloatNullableFilter<"VitalSigns"> | number | null
    bmi?: FloatNullableFilter<"VitalSigns"> | number | null
    oxygenSaturation?: IntNullableFilter<"VitalSigns"> | number | null
    recordedBy?: StringFilter<"VitalSigns"> | string
    createdAt?: DateTimeFilter<"VitalSigns"> | Date | string
    isDeleted?: BoolFilter<"VitalSigns"> | boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutStudentInput, AppointmentUncheckedUpdateWithoutStudentInput>
    create: XOR<AppointmentCreateWithoutStudentInput, AppointmentUncheckedCreateWithoutStudentInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutStudentInput, AppointmentUncheckedUpdateWithoutStudentInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutStudentInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    appointmentNo?: StringFilter<"Appointment"> | string
    studentId?: StringFilter<"Appointment"> | string
    physicianId?: StringNullableFilter<"Appointment"> | string | null
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    appointmentTime?: StringFilter<"Appointment"> | string
    reason?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    isDeleted?: BoolFilter<"Appointment"> | boolean
  }

  export type QueueUpsertWithWhereUniqueWithoutStudentInput = {
    where: QueueWhereUniqueInput
    update: XOR<QueueUpdateWithoutStudentInput, QueueUncheckedUpdateWithoutStudentInput>
    create: XOR<QueueCreateWithoutStudentInput, QueueUncheckedCreateWithoutStudentInput>
  }

  export type QueueUpdateWithWhereUniqueWithoutStudentInput = {
    where: QueueWhereUniqueInput
    data: XOR<QueueUpdateWithoutStudentInput, QueueUncheckedUpdateWithoutStudentInput>
  }

  export type QueueUpdateManyWithWhereWithoutStudentInput = {
    where: QueueScalarWhereInput
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyWithoutStudentInput>
  }

  export type QueueScalarWhereInput = {
    AND?: QueueScalarWhereInput | QueueScalarWhereInput[]
    OR?: QueueScalarWhereInput[]
    NOT?: QueueScalarWhereInput | QueueScalarWhereInput[]
    id?: StringFilter<"Queue"> | string
    queueNumber?: IntFilter<"Queue"> | number
    studentId?: StringFilter<"Queue"> | string
    priority?: EnumpriorityFilter<"Queue"> | $Enums.priority
    status?: StringFilter<"Queue"> | string
    checkInTime?: DateTimeFilter<"Queue"> | Date | string
    calledTime?: DateTimeNullableFilter<"Queue"> | Date | string | null
    completedTime?: DateTimeNullableFilter<"Queue"> | Date | string | null
    notes?: StringNullableFilter<"Queue"> | string | null
    createdAt?: DateTimeFilter<"Queue"> | Date | string
    updatedAt?: DateTimeFilter<"Queue"> | Date | string
    isDeleted?: BoolFilter<"Queue"> | boolean
  }

  export type BalanceTransactionUpsertWithWhereUniqueWithoutStudentInput = {
    where: BalanceTransactionWhereUniqueInput
    update: XOR<BalanceTransactionUpdateWithoutStudentInput, BalanceTransactionUncheckedUpdateWithoutStudentInput>
    create: XOR<BalanceTransactionCreateWithoutStudentInput, BalanceTransactionUncheckedCreateWithoutStudentInput>
  }

  export type BalanceTransactionUpdateWithWhereUniqueWithoutStudentInput = {
    where: BalanceTransactionWhereUniqueInput
    data: XOR<BalanceTransactionUpdateWithoutStudentInput, BalanceTransactionUncheckedUpdateWithoutStudentInput>
  }

  export type BalanceTransactionUpdateManyWithWhereWithoutStudentInput = {
    where: BalanceTransactionScalarWhereInput
    data: XOR<BalanceTransactionUpdateManyMutationInput, BalanceTransactionUncheckedUpdateManyWithoutStudentInput>
  }

  export type BalanceTransactionScalarWhereInput = {
    AND?: BalanceTransactionScalarWhereInput | BalanceTransactionScalarWhereInput[]
    OR?: BalanceTransactionScalarWhereInput[]
    NOT?: BalanceTransactionScalarWhereInput | BalanceTransactionScalarWhereInput[]
    id?: StringFilter<"BalanceTransaction"> | string
    studentId?: StringFilter<"BalanceTransaction"> | string
    amount?: FloatFilter<"BalanceTransaction"> | number
    type?: StringFilter<"BalanceTransaction"> | string
    description?: StringFilter<"BalanceTransaction"> | string
    paymentMethod?: StringNullableFilter<"BalanceTransaction"> | string | null
    reference?: StringNullableFilter<"BalanceTransaction"> | string | null
    prescriptionId?: StringNullableFilter<"BalanceTransaction"> | string | null
    balanceAfter?: FloatFilter<"BalanceTransaction"> | number
    createdAt?: DateTimeFilter<"BalanceTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BalanceTransaction"> | Date | string
    isDeleted?: BoolFilter<"BalanceTransaction"> | boolean
  }

  export type ConsultationCreateWithoutPhysicianInput = {
    id?: string
    consultationNo: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutConsultationsInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutConsultationInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutPhysicianInput = {
    id?: string
    consultationNo: string
    studentId: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutConsultationInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutPhysicianInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutPhysicianInput, ConsultationUncheckedCreateWithoutPhysicianInput>
  }

  export type ConsultationCreateManyPhysicianInputEnvelope = {
    data: ConsultationCreateManyPhysicianInput | ConsultationCreateManyPhysicianInput[]
  }

  export type PrescriptionCreateWithoutPhysicianInput = {
    id?: string
    prescriptionNo: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutPrescriptionsInput
    consultation: ConsultationCreateNestedOneWithoutPrescriptionsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPhysicianInput = {
    id?: string
    prescriptionNo: string
    studentId: string
    consultationId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPhysicianInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPhysicianInput, PrescriptionUncheckedCreateWithoutPhysicianInput>
  }

  export type PrescriptionCreateManyPhysicianInputEnvelope = {
    data: PrescriptionCreateManyPhysicianInput | PrescriptionCreateManyPhysicianInput[]
  }

  export type AppointmentCreateWithoutPhysicianInput = {
    id?: string
    appointmentNo: string
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutPhysicianInput = {
    id?: string
    appointmentNo: string
    studentId: string
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type AppointmentCreateOrConnectWithoutPhysicianInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPhysicianInput, AppointmentUncheckedCreateWithoutPhysicianInput>
  }

  export type AppointmentCreateManyPhysicianInputEnvelope = {
    data: AppointmentCreateManyPhysicianInput | AppointmentCreateManyPhysicianInput[]
  }

  export type ConsultationUpsertWithWhereUniqueWithoutPhysicianInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutPhysicianInput, ConsultationUncheckedUpdateWithoutPhysicianInput>
    create: XOR<ConsultationCreateWithoutPhysicianInput, ConsultationUncheckedCreateWithoutPhysicianInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutPhysicianInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutPhysicianInput, ConsultationUncheckedUpdateWithoutPhysicianInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutPhysicianInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutPhysicianInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPhysicianInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPhysicianInput, PrescriptionUncheckedUpdateWithoutPhysicianInput>
    create: XOR<PrescriptionCreateWithoutPhysicianInput, PrescriptionUncheckedCreateWithoutPhysicianInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPhysicianInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPhysicianInput, PrescriptionUncheckedUpdateWithoutPhysicianInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPhysicianInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPhysicianInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPhysicianInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPhysicianInput, AppointmentUncheckedUpdateWithoutPhysicianInput>
    create: XOR<AppointmentCreateWithoutPhysicianInput, AppointmentUncheckedCreateWithoutPhysicianInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPhysicianInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPhysicianInput, AppointmentUncheckedUpdateWithoutPhysicianInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPhysicianInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPhysicianInput>
  }

  export type StudentCreateWithoutQueueInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutStudentInput
    appointments?: AppointmentCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutQueueInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalUncheckedCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutStudentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutQueueInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutQueueInput, StudentUncheckedCreateWithoutQueueInput>
  }

  export type StudentUpsertWithoutQueueInput = {
    update: XOR<StudentUpdateWithoutQueueInput, StudentUncheckedUpdateWithoutQueueInput>
    create: XOR<StudentCreateWithoutQueueInput, StudentUncheckedCreateWithoutQueueInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutQueueInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutQueueInput, StudentUncheckedUpdateWithoutQueueInput>
  }

  export type StudentUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutAppointmentsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutStudentInput
    queue?: QueueCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalUncheckedCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutStudentInput
    queue?: QueueUncheckedCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAppointmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAppointmentsInput, StudentUncheckedCreateWithoutAppointmentsInput>
  }

  export type PhysicianCreateWithoutAppointmentsInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutPhysicianInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPhysicianInput
  }

  export type PhysicianUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPhysicianInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPhysicianInput
  }

  export type PhysicianCreateOrConnectWithoutAppointmentsInput = {
    where: PhysicianWhereUniqueInput
    create: XOR<PhysicianCreateWithoutAppointmentsInput, PhysicianUncheckedCreateWithoutAppointmentsInput>
  }

  export type StudentUpsertWithoutAppointmentsInput = {
    update: XOR<StudentUpdateWithoutAppointmentsInput, StudentUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<StudentCreateWithoutAppointmentsInput, StudentUncheckedCreateWithoutAppointmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAppointmentsInput, StudentUncheckedUpdateWithoutAppointmentsInput>
  }

  export type StudentUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutStudentNestedInput
    queue?: QueueUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutStudentNestedInput
    queue?: QueueUncheckedUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type PhysicianUpsertWithoutAppointmentsInput = {
    update: XOR<PhysicianUpdateWithoutAppointmentsInput, PhysicianUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PhysicianCreateWithoutAppointmentsInput, PhysicianUncheckedCreateWithoutAppointmentsInput>
    where?: PhysicianWhereInput
  }

  export type PhysicianUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PhysicianWhereInput
    data: XOR<PhysicianUpdateWithoutAppointmentsInput, PhysicianUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PhysicianUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutPhysicianNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutPhysicianNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPhysicianNestedInput
  }

  export type StudentCreateWithoutVitalSignsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutStudentInput
    appointments?: AppointmentCreateNestedManyWithoutStudentInput
    queue?: QueueCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutVitalSignsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalUncheckedCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutStudentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutStudentInput
    queue?: QueueUncheckedCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutVitalSignsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutVitalSignsInput, StudentUncheckedCreateWithoutVitalSignsInput>
  }

  export type ConsultationCreateWithoutVitalSignsInput = {
    id?: string
    consultationNo: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutConsultationsInput
    physician: PhysicianCreateNestedOneWithoutConsultationsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutVitalSignsInput = {
    id?: string
    consultationNo: string
    studentId: string
    physicianId: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutVitalSignsInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutVitalSignsInput, ConsultationUncheckedCreateWithoutVitalSignsInput>
  }

  export type StudentUpsertWithoutVitalSignsInput = {
    update: XOR<StudentUpdateWithoutVitalSignsInput, StudentUncheckedUpdateWithoutVitalSignsInput>
    create: XOR<StudentCreateWithoutVitalSignsInput, StudentUncheckedCreateWithoutVitalSignsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutVitalSignsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutVitalSignsInput, StudentUncheckedUpdateWithoutVitalSignsInput>
  }

  export type StudentUpdateWithoutVitalSignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUpdateManyWithoutStudentNestedInput
    queue?: QueueUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutVitalSignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutStudentNestedInput
    queue?: QueueUncheckedUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ConsultationUpsertWithoutVitalSignsInput = {
    update: XOR<ConsultationUpdateWithoutVitalSignsInput, ConsultationUncheckedUpdateWithoutVitalSignsInput>
    create: XOR<ConsultationCreateWithoutVitalSignsInput, ConsultationUncheckedCreateWithoutVitalSignsInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutVitalSignsInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutVitalSignsInput, ConsultationUncheckedUpdateWithoutVitalSignsInput>
  }

  export type ConsultationUpdateWithoutVitalSignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutConsultationsNestedInput
    physician?: PhysicianUpdateOneRequiredWithoutConsultationsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutVitalSignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type StudentCreateWithoutConsultationsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    prescriptions?: PrescriptionCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutStudentInput
    appointments?: AppointmentCreateNestedManyWithoutStudentInput
    queue?: QueueCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutConsultationsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalUncheckedCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutStudentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutStudentInput
    queue?: QueueUncheckedCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutConsultationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutConsultationsInput, StudentUncheckedCreateWithoutConsultationsInput>
  }

  export type PhysicianCreateWithoutConsultationsInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    prescriptions?: PrescriptionCreateNestedManyWithoutPhysicianInput
    appointments?: AppointmentCreateNestedManyWithoutPhysicianInput
  }

  export type PhysicianUncheckedCreateWithoutConsultationsInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPhysicianInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPhysicianInput
  }

  export type PhysicianCreateOrConnectWithoutConsultationsInput = {
    where: PhysicianWhereUniqueInput
    create: XOR<PhysicianCreateWithoutConsultationsInput, PhysicianUncheckedCreateWithoutConsultationsInput>
  }

  export type VitalSignsCreateWithoutConsultationInput = {
    id?: string
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutVitalSignsInput
  }

  export type VitalSignsUncheckedCreateWithoutConsultationInput = {
    id?: string
    studentId: string
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type VitalSignsCreateOrConnectWithoutConsultationInput = {
    where: VitalSignsWhereUniqueInput
    create: XOR<VitalSignsCreateWithoutConsultationInput, VitalSignsUncheckedCreateWithoutConsultationInput>
  }

  export type VitalSignsCreateManyConsultationInputEnvelope = {
    data: VitalSignsCreateManyConsultationInput | VitalSignsCreateManyConsultationInput[]
  }

  export type PrescriptionCreateWithoutConsultationInput = {
    id?: string
    prescriptionNo: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutPrescriptionsInput
    physician: PhysicianCreateNestedOneWithoutPrescriptionsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutConsultationInput = {
    id?: string
    prescriptionNo: string
    studentId: string
    physicianId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutConsultationInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput>
  }

  export type PrescriptionCreateManyConsultationInputEnvelope = {
    data: PrescriptionCreateManyConsultationInput | PrescriptionCreateManyConsultationInput[]
  }

  export type StudentUpsertWithoutConsultationsInput = {
    update: XOR<StudentUpdateWithoutConsultationsInput, StudentUncheckedUpdateWithoutConsultationsInput>
    create: XOR<StudentCreateWithoutConsultationsInput, StudentUncheckedCreateWithoutConsultationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutConsultationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutConsultationsInput, StudentUncheckedUpdateWithoutConsultationsInput>
  }

  export type StudentUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptions?: PrescriptionUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUpdateManyWithoutStudentNestedInput
    queue?: QueueUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutStudentNestedInput
    queue?: QueueUncheckedUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type PhysicianUpsertWithoutConsultationsInput = {
    update: XOR<PhysicianUpdateWithoutConsultationsInput, PhysicianUncheckedUpdateWithoutConsultationsInput>
    create: XOR<PhysicianCreateWithoutConsultationsInput, PhysicianUncheckedCreateWithoutConsultationsInput>
    where?: PhysicianWhereInput
  }

  export type PhysicianUpdateToOneWithWhereWithoutConsultationsInput = {
    where?: PhysicianWhereInput
    data: XOR<PhysicianUpdateWithoutConsultationsInput, PhysicianUncheckedUpdateWithoutConsultationsInput>
  }

  export type PhysicianUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptions?: PrescriptionUpdateManyWithoutPhysicianNestedInput
    appointments?: AppointmentUpdateManyWithoutPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPhysicianNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPhysicianNestedInput
  }

  export type VitalSignsUpsertWithWhereUniqueWithoutConsultationInput = {
    where: VitalSignsWhereUniqueInput
    update: XOR<VitalSignsUpdateWithoutConsultationInput, VitalSignsUncheckedUpdateWithoutConsultationInput>
    create: XOR<VitalSignsCreateWithoutConsultationInput, VitalSignsUncheckedCreateWithoutConsultationInput>
  }

  export type VitalSignsUpdateWithWhereUniqueWithoutConsultationInput = {
    where: VitalSignsWhereUniqueInput
    data: XOR<VitalSignsUpdateWithoutConsultationInput, VitalSignsUncheckedUpdateWithoutConsultationInput>
  }

  export type VitalSignsUpdateManyWithWhereWithoutConsultationInput = {
    where: VitalSignsScalarWhereInput
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyWithoutConsultationInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutConsultationInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutConsultationInput, PrescriptionUncheckedUpdateWithoutConsultationInput>
    create: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutConsultationInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutConsultationInput, PrescriptionUncheckedUpdateWithoutConsultationInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutConsultationInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutConsultationInput>
  }

  export type StudentCreateWithoutPrescriptionsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutStudentInput
    appointments?: AppointmentCreateNestedManyWithoutStudentInput
    queue?: QueueCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalUncheckedCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutStudentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutStudentInput
    queue?: QueueUncheckedCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPrescriptionsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPrescriptionsInput, StudentUncheckedCreateWithoutPrescriptionsInput>
  }

  export type PhysicianCreateWithoutPrescriptionsInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutPhysicianInput
    appointments?: AppointmentCreateNestedManyWithoutPhysicianInput
  }

  export type PhysicianUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    staffId: string
    firstName: string
    lastName: string
    otherNames?: string | null
    specialization: string
    qualification: string
    licenseNumber: string
    email: string
    phone: string
    profilePhoto?: string | null
    isActive?: boolean
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPhysicianInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPhysicianInput
  }

  export type PhysicianCreateOrConnectWithoutPrescriptionsInput = {
    where: PhysicianWhereUniqueInput
    create: XOR<PhysicianCreateWithoutPrescriptionsInput, PhysicianUncheckedCreateWithoutPrescriptionsInput>
  }

  export type ConsultationCreateWithoutPrescriptionsInput = {
    id?: string
    consultationNo: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutConsultationsInput
    physician: PhysicianCreateNestedOneWithoutConsultationsInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    consultationNo: string
    studentId: string
    physicianId: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutPrescriptionsInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutPrescriptionsInput, ConsultationUncheckedCreateWithoutPrescriptionsInput>
  }

  export type PrescriptionItemCreateWithoutPrescriptionInput = {
    id?: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    product: ProductCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateWithoutPrescriptionInput = {
    id?: string
    productId: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PrescriptionItemCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionItemCreateManyPrescriptionInput | PrescriptionItemCreateManyPrescriptionInput[]
  }

  export type StudentUpsertWithoutPrescriptionsInput = {
    update: XOR<StudentUpdateWithoutPrescriptionsInput, StudentUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<StudentCreateWithoutPrescriptionsInput, StudentUncheckedCreateWithoutPrescriptionsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPrescriptionsInput, StudentUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type StudentUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUpdateManyWithoutStudentNestedInput
    queue?: QueueUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutStudentNestedInput
    queue?: QueueUncheckedUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type PhysicianUpsertWithoutPrescriptionsInput = {
    update: XOR<PhysicianUpdateWithoutPrescriptionsInput, PhysicianUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<PhysicianCreateWithoutPrescriptionsInput, PhysicianUncheckedCreateWithoutPrescriptionsInput>
    where?: PhysicianWhereInput
  }

  export type PhysicianUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: PhysicianWhereInput
    data: XOR<PhysicianUpdateWithoutPrescriptionsInput, PhysicianUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PhysicianUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutPhysicianNestedInput
    appointments?: AppointmentUpdateManyWithoutPhysicianNestedInput
  }

  export type PhysicianUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutPhysicianNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPhysicianNestedInput
  }

  export type ConsultationUpsertWithoutPrescriptionsInput = {
    update: XOR<ConsultationUpdateWithoutPrescriptionsInput, ConsultationUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<ConsultationCreateWithoutPrescriptionsInput, ConsultationUncheckedCreateWithoutPrescriptionsInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutPrescriptionsInput, ConsultationUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type ConsultationUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutConsultationsNestedInput
    physician?: PhysicianUpdateOneRequiredWithoutConsultationsNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionItemScalarWhereInput = {
    AND?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    OR?: PrescriptionItemScalarWhereInput[]
    NOT?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    id?: StringFilter<"PrescriptionItem"> | string
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    productId?: StringFilter<"PrescriptionItem"> | string
    drugName?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    route?: StringNullableFilter<"PrescriptionItem"> | string | null
    instructions?: StringFilter<"PrescriptionItem"> | string
    quantityPrescribed?: IntFilter<"PrescriptionItem"> | number
    quantityDispensed?: IntFilter<"PrescriptionItem"> | number
    unitPrice?: FloatFilter<"PrescriptionItem"> | number
    totalPrice?: FloatFilter<"PrescriptionItem"> | number
    isDispensed?: BoolFilter<"PrescriptionItem"> | boolean
    dispensedAt?: DateTimeNullableFilter<"PrescriptionItem"> | Date | string | null
    dispensedBy?: StringNullableFilter<"PrescriptionItem"> | string | null
    createdAt?: DateTimeFilter<"PrescriptionItem"> | Date | string
    updatedAt?: DateTimeFilter<"PrescriptionItem"> | Date | string
    isDeleted?: BoolFilter<"PrescriptionItem"> | boolean
  }

  export type PrescriptionCreateWithoutPrescriptionItemsInput = {
    id?: string
    prescriptionNo: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    student: StudentCreateNestedOneWithoutPrescriptionsInput
    physician: PhysicianCreateNestedOneWithoutPrescriptionsInput
    consultation: ConsultationCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateWithoutPrescriptionItemsInput = {
    id?: string
    prescriptionNo: string
    studentId: string
    physicianId: string
    consultationId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
  }

  export type PrescriptionCreateOrConnectWithoutPrescriptionItemsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPrescriptionItemsInput, PrescriptionUncheckedCreateWithoutPrescriptionItemsInput>
  }

  export type ProductCreateWithoutPrescriptionItemsInput = {
    id?: string
    name: string
    barcode: string
    genericName?: string | null
    brandName?: string | null
    category?: string | null
    manufacturer?: string | null
    batchNumber?: string | null
    expiryDate?: Date | string | null
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel?: number | null
    maxStockLevel?: number | null
    taxRate: number
    unit: $Enums.unit
    description: string
    dosageForm?: string | null
    strength?: string | null
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    purchaseItem?: PurchaseItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPrescriptionItemsInput = {
    id?: string
    name: string
    barcode: string
    genericName?: string | null
    brandName?: string | null
    category?: string | null
    manufacturer?: string | null
    batchNumber?: string | null
    expiryDate?: Date | string | null
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel?: number | null
    maxStockLevel?: number | null
    taxRate: number
    unit: $Enums.unit
    description: string
    dosageForm?: string | null
    strength?: string | null
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    purchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPrescriptionItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPrescriptionItemsInput, ProductUncheckedCreateWithoutPrescriptionItemsInput>
  }

  export type PrescriptionUpsertWithoutPrescriptionItemsInput = {
    update: XOR<PrescriptionUpdateWithoutPrescriptionItemsInput, PrescriptionUncheckedUpdateWithoutPrescriptionItemsInput>
    create: XOR<PrescriptionCreateWithoutPrescriptionItemsInput, PrescriptionUncheckedCreateWithoutPrescriptionItemsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutPrescriptionItemsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutPrescriptionItemsInput, PrescriptionUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type PrescriptionUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutPrescriptionsNestedInput
    physician?: PhysicianUpdateOneRequiredWithoutPrescriptionsNestedInput
    consultation?: ConsultationUpdateOneRequiredWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUpsertWithoutPrescriptionItemsInput = {
    update: XOR<ProductUpdateWithoutPrescriptionItemsInput, ProductUncheckedUpdateWithoutPrescriptionItemsInput>
    create: XOR<ProductCreateWithoutPrescriptionItemsInput, ProductUncheckedCreateWithoutPrescriptionItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPrescriptionItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPrescriptionItemsInput, ProductUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type ProductUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeSalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: IntFieldUpdateOperationsInput | number
    unit?: EnumunitFieldUpdateOperationsInput | $Enums.unit
    description?: StringFieldUpdateOperationsInput | string
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    controlledSubstance?: BoolFieldUpdateOperationsInput | boolean
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    purchaseItem?: PurchaseItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeSalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: IntFieldUpdateOperationsInput | number
    unit?: EnumunitFieldUpdateOperationsInput | $Enums.unit
    description?: StringFieldUpdateOperationsInput | string
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    controlledSubstance?: BoolFieldUpdateOperationsInput | boolean
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    purchaseItem?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StudentCreateWithoutDrugDispensalsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutStudentInput
    appointments?: AppointmentCreateNestedManyWithoutStudentInput
    queue?: QueueCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutDrugDispensalsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutStudentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutStudentInput
    queue?: QueueUncheckedCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutDrugDispensalsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutDrugDispensalsInput, StudentUncheckedCreateWithoutDrugDispensalsInput>
  }

  export type StudentUpsertWithoutDrugDispensalsInput = {
    update: XOR<StudentUpdateWithoutDrugDispensalsInput, StudentUncheckedUpdateWithoutDrugDispensalsInput>
    create: XOR<StudentCreateWithoutDrugDispensalsInput, StudentUncheckedCreateWithoutDrugDispensalsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutDrugDispensalsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutDrugDispensalsInput, StudentUncheckedUpdateWithoutDrugDispensalsInput>
  }

  export type StudentUpdateWithoutDrugDispensalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUpdateManyWithoutStudentNestedInput
    queue?: QueueUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutDrugDispensalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutStudentNestedInput
    queue?: QueueUncheckedUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutMedicalRecordsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutStudentInput
    appointments?: AppointmentCreateNestedManyWithoutStudentInput
    queue?: QueueCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutMedicalRecordsInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalUncheckedCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutStudentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutStudentInput
    queue?: QueueUncheckedCreateNestedManyWithoutStudentInput
    balanceTransaction?: BalanceTransactionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutMedicalRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMedicalRecordsInput, StudentUncheckedCreateWithoutMedicalRecordsInput>
  }

  export type StudentUpsertWithoutMedicalRecordsInput = {
    update: XOR<StudentUpdateWithoutMedicalRecordsInput, StudentUncheckedUpdateWithoutMedicalRecordsInput>
    create: XOR<StudentCreateWithoutMedicalRecordsInput, StudentUncheckedCreateWithoutMedicalRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutMedicalRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutMedicalRecordsInput, StudentUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type StudentUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUpdateManyWithoutStudentNestedInput
    queue?: QueueUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutStudentNestedInput
    queue?: QueueUncheckedUpdateManyWithoutStudentNestedInput
    balanceTransaction?: BalanceTransactionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type PrescriptionItemCreateWithoutProductInput = {
    id?: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    prescription: PrescriptionCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateWithoutProductInput = {
    id?: string
    prescriptionId: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PrescriptionItemCreateOrConnectWithoutProductInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutProductInput, PrescriptionItemUncheckedCreateWithoutProductInput>
  }

  export type PrescriptionItemCreateManyProductInputEnvelope = {
    data: PrescriptionItemCreateManyProductInput | PrescriptionItemCreateManyProductInput[]
  }

  export type PurchaseItemCreateWithoutProductInput = {
    id?: string
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    Purchase?: PurchaseCreateNestedOneWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutProductInput = {
    id?: string
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    purchaseId?: string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PurchaseItemCreateOrConnectWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemCreateManyProductInputEnvelope = {
    data: PurchaseItemCreateManyProductInput | PurchaseItemCreateManyProductInput[]
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutProductInput, PrescriptionItemUncheckedUpdateWithoutProductInput>
    create: XOR<PrescriptionItemCreateWithoutProductInput, PrescriptionItemUncheckedCreateWithoutProductInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutProductInput, PrescriptionItemUncheckedUpdateWithoutProductInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutProductInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseItemScalarWhereInput = {
    AND?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    OR?: PurchaseItemScalarWhereInput[]
    NOT?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    id?: StringFilter<"PurchaseItem"> | string
    productId?: StringNullableFilter<"PurchaseItem"> | string | null
    cost?: FloatFilter<"PurchaseItem"> | number
    productName?: StringNullableFilter<"PurchaseItem"> | string | null
    selectedPrice?: FloatFilter<"PurchaseItem"> | number
    priceType?: StringFilter<"PurchaseItem"> | string
    quantity?: IntFilter<"PurchaseItem"> | number
    discount?: FloatFilter<"PurchaseItem"> | number
    total?: FloatFilter<"PurchaseItem"> | number
    profit?: FloatFilter<"PurchaseItem"> | number
    sync?: BoolFilter<"PurchaseItem"> | boolean
    syncedAt?: DateTimeNullableFilter<"PurchaseItem"> | Date | string | null
    purchaseId?: StringNullableFilter<"PurchaseItem"> | string | null
    customRetailPrice?: FloatNullableFilter<"PurchaseItem"> | number | null
    customWholesalePrice?: FloatNullableFilter<"PurchaseItem"> | number | null
    expiryDate?: DateTimeNullableFilter<"PurchaseItem"> | Date | string | null
    batchNumber?: StringNullableFilter<"PurchaseItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseItem"> | Date | string
    isDeleted?: BoolFilter<"PurchaseItem"> | boolean
  }

  export type PurchaseItemCreateWithoutPurchaseInput = {
    id?: string
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    product?: ProductCreateNestedOneWithoutPurchaseItemInput
  }

  export type PurchaseItemUncheckedCreateWithoutPurchaseInput = {
    id?: string
    productId?: string | null
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PurchaseItemCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemCreateManyPurchaseInputEnvelope = {
    data: PurchaseItemCreateManyPurchaseInput | PurchaseItemCreateManyPurchaseInput[]
  }

  export type SupplierCreateWithoutPurchaseInput = {
    id?: string
    name: string
    type: string
    companyName?: string | null
    email: string
    address: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type SupplierUncheckedCreateWithoutPurchaseInput = {
    id?: string
    name: string
    type: string
    companyName?: string | null
    email: string
    address: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type SupplierCreateOrConnectWithoutPurchaseInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type SupplierUpsertWithoutPurchaseInput = {
    update: XOR<SupplierUpdateWithoutPurchaseInput, SupplierUncheckedUpdateWithoutPurchaseInput>
    create: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseInput, SupplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type SupplierUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupplierUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCreateWithoutPurchaseItemInput = {
    id?: string
    name: string
    barcode: string
    genericName?: string | null
    brandName?: string | null
    category?: string | null
    manufacturer?: string | null
    batchNumber?: string | null
    expiryDate?: Date | string | null
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel?: number | null
    maxStockLevel?: number | null
    taxRate: number
    unit: $Enums.unit
    description: string
    dosageForm?: string | null
    strength?: string | null
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseItemInput = {
    id?: string
    name: string
    barcode: string
    genericName?: string | null
    brandName?: string | null
    category?: string | null
    manufacturer?: string | null
    batchNumber?: string | null
    expiryDate?: Date | string | null
    wholeSalePrice: number
    retailPrice: number
    cost: number
    quantity: number
    reorderLevel?: number | null
    maxStockLevel?: number | null
    taxRate: number
    unit: $Enums.unit
    description: string
    dosageForm?: string | null
    strength?: string | null
    requiresPrescription?: boolean
    controlledSubstance?: boolean
    storageConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseItemInput, ProductUncheckedCreateWithoutPurchaseItemInput>
  }

  export type PurchaseCreateWithoutPurchaseItemInput = {
    id?: string
    taxRate: number
    subTotal: number
    notes?: string | null
    amountPaid?: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceNo: string
    isDeleted?: boolean
    Supplier?: SupplierCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutPurchaseItemInput = {
    id?: string
    taxRate: number
    subTotal: number
    notes?: string | null
    amountPaid?: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceNo: string
    supplierId?: string | null
    isDeleted?: boolean
  }

  export type PurchaseCreateOrConnectWithoutPurchaseItemInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutPurchaseItemInput, PurchaseUncheckedCreateWithoutPurchaseItemInput>
  }

  export type ProductUpsertWithoutPurchaseItemInput = {
    update: XOR<ProductUpdateWithoutPurchaseItemInput, ProductUncheckedUpdateWithoutPurchaseItemInput>
    create: XOR<ProductCreateWithoutPurchaseItemInput, ProductUncheckedCreateWithoutPurchaseItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseItemInput, ProductUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type ProductUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeSalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: IntFieldUpdateOperationsInput | number
    unit?: EnumunitFieldUpdateOperationsInput | $Enums.unit
    description?: StringFieldUpdateOperationsInput | string
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    controlledSubstance?: BoolFieldUpdateOperationsInput | boolean
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptionItems?: PrescriptionItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeSalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: NullableIntFieldUpdateOperationsInput | number | null
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    taxRate?: IntFieldUpdateOperationsInput | number
    unit?: EnumunitFieldUpdateOperationsInput | $Enums.unit
    description?: StringFieldUpdateOperationsInput | string
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    controlledSubstance?: BoolFieldUpdateOperationsInput | boolean
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PurchaseUpsertWithoutPurchaseItemInput = {
    update: XOR<PurchaseUpdateWithoutPurchaseItemInput, PurchaseUncheckedUpdateWithoutPurchaseItemInput>
    create: XOR<PurchaseCreateWithoutPurchaseItemInput, PurchaseUncheckedCreateWithoutPurchaseItemInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutPurchaseItemInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutPurchaseItemInput, PurchaseUncheckedUpdateWithoutPurchaseItemInput>
  }

  export type PurchaseUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Supplier?: SupplierUpdateOneWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutPurchaseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentCreateWithoutBalanceTransactionInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutStudentInput
    appointments?: AppointmentCreateNestedManyWithoutStudentInput
    queue?: QueueCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutBalanceTransactionInput = {
    id?: string
    matricNumber: string
    firstName: string
    lastName: string
    otherNames?: string | null
    email?: string | null
    phone?: string | null
    department: string
    level: string
    faculty: string
    dateOfBirth: Date | string
    gender: string
    bloodGroup?: string | null
    genotype?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    emergencyContact: string
    emergencyPhone: string
    emergencyRelationship?: string | null
    profilePhoto?: string | null
    address?: string | null
    stateOfOrigin?: string | null
    nationality?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
    consultations?: ConsultationUncheckedCreateNestedManyWithoutStudentInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutStudentInput
    drugDispensals?: DrugDispensalUncheckedCreateNestedManyWithoutStudentInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutStudentInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutStudentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutStudentInput
    queue?: QueueUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutBalanceTransactionInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutBalanceTransactionInput, StudentUncheckedCreateWithoutBalanceTransactionInput>
  }

  export type StudentUpsertWithoutBalanceTransactionInput = {
    update: XOR<StudentUpdateWithoutBalanceTransactionInput, StudentUncheckedUpdateWithoutBalanceTransactionInput>
    create: XOR<StudentCreateWithoutBalanceTransactionInput, StudentUncheckedCreateWithoutBalanceTransactionInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutBalanceTransactionInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutBalanceTransactionInput, StudentUncheckedUpdateWithoutBalanceTransactionInput>
  }

  export type StudentUpdateWithoutBalanceTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUpdateManyWithoutStudentNestedInput
    queue?: QueueUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutBalanceTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    otherNames?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    faculty?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    emergencyRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    stateOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultations?: ConsultationUncheckedUpdateManyWithoutStudentNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutStudentNestedInput
    drugDispensals?: DrugDispensalUncheckedUpdateManyWithoutStudentNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutStudentNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutStudentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutStudentNestedInput
    queue?: QueueUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type PurchaseCreateWithoutSupplierInput = {
    id?: string
    taxRate: number
    subTotal: number
    notes?: string | null
    amountPaid?: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceNo: string
    isDeleted?: boolean
    purchaseItem?: PurchaseItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutSupplierInput = {
    id?: string
    taxRate: number
    subTotal: number
    notes?: string | null
    amountPaid?: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceNo: string
    isDeleted?: boolean
    purchaseItem?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseCreateManySupplierInputEnvelope = {
    data: PurchaseCreateManySupplierInput | PurchaseCreateManySupplierInput[]
  }

  export type PurchaseUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutSupplierInput, PurchaseUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseCreateWithoutSupplierInput, PurchaseUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutSupplierInput, PurchaseUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    taxRate?: FloatFilter<"Purchase"> | number
    subTotal?: FloatFilter<"Purchase"> | number
    notes?: StringNullableFilter<"Purchase"> | string | null
    amountPaid?: FloatNullableFilter<"Purchase"> | number | null
    grandTotal?: FloatFilter<"Purchase"> | number
    paidAmount?: FloatFilter<"Purchase"> | number
    balance?: FloatFilter<"Purchase"> | number
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    referenceNo?: StringFilter<"Purchase"> | string
    supplierId?: StringNullableFilter<"Purchase"> | string | null
    isDeleted?: BoolFilter<"Purchase"> | boolean
  }

  export type ConsultationCreateManyStudentInput = {
    id?: string
    consultationNo: string
    physicianId: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type PrescriptionCreateManyStudentInput = {
    id?: string
    prescriptionNo: string
    physicianId: string
    consultationId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
  }

  export type DrugDispensalCreateManyStudentInput = {
    id?: string
    dispensalNo: string
    prescriptionId: string
    prescriptionNo: string
    dispensedBy: string
    dispensedItems: string
    totalAmount: number
    notes?: string | null
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type MedicalRecordCreateManyStudentInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    recordData?: string | null
    attachments?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type VitalSignsCreateManyStudentInput = {
    id?: string
    consultationId?: string | null
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type AppointmentCreateManyStudentInput = {
    id?: string
    appointmentNo: string
    physicianId?: string | null
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type QueueCreateManyStudentInput = {
    id?: string
    queueNumber: number
    priority?: $Enums.priority
    status?: string
    checkInTime?: Date | string
    calledTime?: Date | string | null
    completedTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type BalanceTransactionCreateManyStudentInput = {
    id?: string
    amount: number
    type: string
    description: string
    paymentMethod?: string | null
    reference?: string | null
    prescriptionId?: string | null
    balanceAfter: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type ConsultationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    physician?: PhysicianUpdateOneRequiredWithoutConsultationsNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutConsultationNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutConsultationNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    physician?: PhysicianUpdateOneRequiredWithoutPrescriptionsNestedInput
    consultation?: ConsultationUpdateOneRequiredWithoutPrescriptionsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DrugDispensalUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispensalNo?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    dispensedBy?: StringFieldUpdateOperationsInput | string
    dispensedItems?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DrugDispensalUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispensalNo?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    dispensedBy?: StringFieldUpdateOperationsInput | string
    dispensedItems?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DrugDispensalUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispensalNo?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    dispensedBy?: StringFieldUpdateOperationsInput | string
    dispensedItems?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordData?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordData?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recordData?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VitalSignsUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    consultation?: ConsultationUpdateOneWithoutVitalSignsNestedInput
  }

  export type VitalSignsUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VitalSignsUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    physician?: PhysicianUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    physicianId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    physicianId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QueueUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    status?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    calledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QueueUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    status?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    calledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QueueUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    queueNumber?: IntFieldUpdateOperationsInput | number
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    status?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    calledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BalanceTransactionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BalanceTransactionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BalanceTransactionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationCreateManyPhysicianInput = {
    id?: string
    consultationNo: string
    studentId: string
    chiefComplaint: string
    historyOfPresenting?: string | null
    symptoms: string
    physicalExamination?: string | null
    diagnosis: string
    differentialDiagnosis?: string | null
    treatmentPlan?: string | null
    notes?: string | null
    followUpDate?: Date | string | null
    status?: $Enums.consultationStatus
    priority?: $Enums.priority
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
  }

  export type PrescriptionCreateManyPhysicianInput = {
    id?: string
    prescriptionNo: string
    studentId: string
    consultationId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
  }

  export type AppointmentCreateManyPhysicianInput = {
    id?: string
    appointmentNo: string
    studentId: string
    appointmentDate: Date | string
    appointmentTime: string
    reason: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type ConsultationUpdateWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutConsultationsNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutConsultationNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutConsultationNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateManyWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    historyOfPresenting?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: StringFieldUpdateOperationsInput | string
    physicalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: StringFieldUpdateOperationsInput | string
    differentialDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumconsultationStatusFieldUpdateOperationsInput | $Enums.consultationStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionUpdateWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutPrescriptionsNestedInput
    consultation?: ConsultationUpdateOneRequiredWithoutPrescriptionsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentUpdateWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppointmentUncheckedUpdateManyWithoutPhysicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    appointmentTime?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VitalSignsCreateManyConsultationInput = {
    id?: string
    studentId: string
    temperature?: number | null
    bloodPressure?: string | null
    pulse?: number | null
    respiratoryRate?: number | null
    weight?: number | null
    height?: number | null
    bmi?: number | null
    oxygenSaturation?: number | null
    recordedBy: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type PrescriptionCreateManyConsultationInput = {
    id?: string
    prescriptionNo: string
    studentId: string
    physicianId: string
    diagnosis: string
    instructions?: string | null
    status?: $Enums.prescriptionStatus
    priority?: $Enums.priority
    isPaid?: boolean
    isDispensed?: boolean
    dispensedBy?: string | null
    dispensedAt?: Date | string | null
    totalCost?: number
    amountPaid?: number
    discount?: number
    pharmacyNotified?: boolean
    notifiedAt?: Date | string | null
    studentNotified?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sync?: boolean
    isDeleted?: boolean
  }

  export type VitalSignsUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutVitalSignsNestedInput
  }

  export type VitalSignsUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VitalSignsUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutPrescriptionsNestedInput
    physician?: PhysicianUpdateOneRequiredWithoutPrescriptionsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionNo?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    physicianId?: StringFieldUpdateOperationsInput | string
    diagnosis?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumprescriptionStatusFieldUpdateOperationsInput | $Enums.prescriptionStatus
    priority?: EnumpriorityFieldUpdateOperationsInput | $Enums.priority
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    pharmacyNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotified?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sync?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemCreateManyPrescriptionInput = {
    id?: string
    productId: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PrescriptionItemUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemCreateManyProductInput = {
    id?: string
    prescriptionId: string
    drugName: string
    dosage: string
    frequency: string
    duration: string
    route?: string | null
    instructions: string
    quantityPrescribed: number
    quantityDispensed?: number
    unitPrice: number
    totalPrice: number
    isDispensed?: boolean
    dispensedAt?: Date | string | null
    dispensedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PurchaseItemCreateManyProductInput = {
    id?: string
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    purchaseId?: string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PrescriptionItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    prescription?: PrescriptionUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    drugName?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: StringFieldUpdateOperationsInput | string
    quantityPrescribed?: IntFieldUpdateOperationsInput | number
    quantityDispensed?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispensedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    Purchase?: PurchaseUpdateOneWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseId?: NullableStringFieldUpdateOperationsInput | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseItemCreateManyPurchaseInput = {
    id?: string
    productId?: string | null
    cost: number
    productName?: string | null
    selectedPrice: number
    priceType: string
    quantity: number
    discount: number
    total: number
    profit: number
    sync?: boolean
    syncedAt?: Date | string | null
    customRetailPrice?: number | null
    customWholesalePrice?: number | null
    expiryDate?: Date | string | null
    batchNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
  }

  export type PurchaseItemUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneWithoutPurchaseItemNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    selectedPrice?: FloatFieldUpdateOperationsInput | number
    priceType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    sync?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRetailPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    customWholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PurchaseCreateManySupplierInput = {
    id?: string
    taxRate: number
    subTotal: number
    notes?: string | null
    amountPaid?: number | null
    grandTotal: number
    paidAmount: number
    balance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referenceNo: string
    isDeleted?: boolean
  }

  export type PurchaseUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    purchaseItem?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    purchaseItem?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    subTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNo?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}